=== SEARCH 1: WhatsApp functions ===
.venv\Lib\site-packages\aiohttp\client_reqrep.py:853:                f"Method cannot contain non-token characters {method!r} "
.venv\Lib\site-packages\aiohttp\cookiejar.py:54:    DATE_TOKENS_RE = re.compile(
.venv\Lib\site-packages\aiohttp\cookiejar.py:56:        r"(?P<token>[\x00-\x08\x0A-\x1F\d:a-zA-Z\x7F-\xFF]+)"
.venv\Lib\site-packages\aiohttp\cookiejar.py:442:        for token_match in cls.DATE_TOKENS_RE.finditer(date_str):
.venv\Lib\site-packages\aiohttp\cookiejar.py:444:            token = token_match.group("token")
.venv\Lib\site-packages\aiohttp\cookiejar.py:447:                time_match = cls.DATE_HMS_TIME_RE.match(token)
.venv\Lib\site-packages\aiohttp\cookiejar.py:454:                day_match = cls.DATE_DAY_OF_MONTH_RE.match(token)
.venv\Lib\site-packages\aiohttp\cookiejar.py:461:                month_match = cls.DATE_MONTH_RE.match(token)
.venv\Lib\site-packages\aiohttp\cookiejar.py:469:                year_match = cls.DATE_YEAR_RE.match(token)
.venv\Lib\site-packages\aiohttp\helpers.py:114:TOKEN = CHAR ^ CTL ^ SEPARATORS
.venv\Lib\site-packages\aiohttp\helpers.py:408:    Should be valid extension token (see RFC 2183)
.venv\Lib\site-packages\aiohttp\helpers.py:418:    if not disptype or not (TOKEN > set(disptype)):
.venv\Lib\site-packages\aiohttp\helpers.py:425:            if not key or not (TOKEN > set(key)):
.venv\Lib\site-packages\aiohttp\http_parser.py:68:# and https://www.rfc-editor.org/rfc/rfc9110.html#name-tokens
.venv\Lib\site-packages\aiohttp\http_parser.py:70:#     method = token
.venv\Lib\site-packages\aiohttp\http_parser.py:73:#     token = 1*tchar
.venv\Lib\site-packages\aiohttp\http_parser.py:75:TOKENRE: Final[Pattern[str]] = re.compile(f"[0-9A-Za-z{_TCHAR_SPECIALS}]+")
.venv\Lib\site-packages\aiohttp\http_parser.py:173:            if not TOKENRE.fullmatch(name):
.venv\Lib\site-packages\aiohttp\http_parser.py:595:        if not TOKENRE.fullmatch(method):
.venv\Lib\site-packages\aiohttp\multipart.py:36:from .helpers import CHAR, TOKEN, parse_mimetype, reify
.venv\Lib\site-packages\aiohttp\multipart.py:83:    def is_token(string: str) -> bool:
.venv\Lib\site-packages\aiohttp\multipart.py:84:        return bool(string) and TOKEN >= set(string)
.venv\Lib\site-packages\aiohttp\multipart.py:90:        return is_token(string) and string.count("'") == 2
.venv\Lib\site-packages\aiohttp\multipart.py:109:    if not is_token(disptype):
.venv\Lib\site-packages\aiohttp\multipart.py:129:        if not is_token(key):
.venv\Lib\site-packages\aiohttp\multipart.py:136:            elif not is_token(value):
.venv\Lib\site-packages\aiohttp\multipart.py:159:            elif is_token(value):
.venv\Lib\site-packages\aiohttp\multipart.py:859:        # parameter      = token "=" ( token / quoted-string )
.venv\Lib\site-packages\aiohttp\multipart.py:860:        # token          = 1*tchar
.venv\Lib\site-packages\aiohttp\web_request.py:88:_TOKEN: Final[str] = rf"[{_TCHAR}]+"
.venv\Lib\site-packages\aiohttp\web_request.py:103:    r"({token})=({token}|{quoted_string})(:\d{{1,4}})?".format(
.venv\Lib\site-packages\aiohttp\web_request.py:104:        token=_TOKEN, quoted_string=_QUOTED_STRING
.venv\Lib\site-packages\aiohttp\web_request.py:339:          in section 4: either a 'token' or a 'quoted-string'.
.venv\Lib\site-packages\aiohttp\_cookie_helpers.py:24:# RFC 6265 defines cookie-name token as per RFC 2616 Section 2.2,
.venv\Lib\site-packages\anyio\abc\_eventloop.py:81:    def current_token(cls) -> object:
.venv\Lib\site-packages\anyio\abc\_eventloop.py:85:        :return: a token object, specific to the event loop running in the current
.venv\Lib\site-packages\anyio\abc\_eventloop.py:195:    def create_capacity_limiter(cls, total_tokens: float) -> CapacityLimiter:
.venv\Lib\site-packages\anyio\abc\_eventloop.py:220:        token: object,
.venv\Lib\site-packages\anyio\abc\_eventloop.py:230:        token: object,
.venv\Lib\site-packages\anyio\from_thread.py:33:from .lowlevel import EventLoopToken
.venv\Lib\site-packages\anyio\from_thread.py:45:def _token_or_error(token: EventLoopToken | None) -> EventLoopToken:
.venv\Lib\site-packages\anyio\from_thread.py:46:    if token is not None:
.venv\Lib\site-packages\anyio\from_thread.py:47:        return token
.venv\Lib\site-packages\anyio\from_thread.py:50:        return threadlocals.current_token
.venv\Lib\site-packages\anyio\from_thread.py:53:            "Not running inside an AnyIO worker thread, and no event loop token was "
.venv\Lib\site-packages\anyio\from_thread.py:61:    token: EventLoopToken | None = None,
.venv\Lib\site-packages\anyio\from_thread.py:68:    :param token: an event loop token to use to get back to the event loop thread
.venv\Lib\site-packages\anyio\from_thread.py:71:    :raises MissingTokenError: if no token was provided and called from outside an
.venv\Lib\site-packages\anyio\from_thread.py:73:    :raises RunFinishedError: if the event loop tied to ``token`` is no longer running
.venv\Lib\site-packages\anyio\from_thread.py:76:        Added the ``token`` parameter.
.venv\Lib\site-packages\anyio\from_thread.py:79:    explicit_token = token is not None
.venv\Lib\site-packages\anyio\from_thread.py:80:    token = _token_or_error(token)
.venv\Lib\site-packages\anyio\from_thread.py:81:    return token.backend_class.run_async_from_thread(
.venv\Lib\site-packages\anyio\from_thread.py:82:        func, args, token=token.native_token if explicit_token else None
.venv\Lib\site-packages\anyio\from_thread.py:89:    token: EventLoopToken | None = None,
.venv\Lib\site-packages\anyio\from_thread.py:96:    :param token: an event loop token to use to get back to the event loop thread
.venv\Lib\site-packages\anyio\from_thread.py:99:    :raises MissingTokenError: if no token was provided and called from outside an
.venv\Lib\site-packages\anyio\from_thread.py:101:    :raises RunFinishedError: if the event loop tied to ``token`` is no longer running
.venv\Lib\site-packages\anyio\from_thread.py:104:        Added the ``token`` parameter.
.venv\Lib\site-packages\anyio\from_thread.py:107:    explicit_token = token is not None
.venv\Lib\site-packages\anyio\from_thread.py:108:    token = _token_or_error(token)
.venv\Lib\site-packages\anyio\from_thread.py:109:    return token.backend_class.run_sync_from_thread(
.venv\Lib\site-packages\anyio\from_thread.py:110:        func, args, token=token.native_token if explicit_token else None
.venv\Lib\site-packages\anyio\from_thread.py:559:        token: EventLoopToken = threadlocals.current_token
.venv\Lib\site-packages\anyio\from_thread.py:565:    token.backend_class.check_cancelled()
.venv\Lib\site-packages\anyio\lowlevel.py:61:class EventLoopToken:
.venv\Lib\site-packages\anyio\lowlevel.py:69:    native_token: object
.venv\Lib\site-packages\anyio\lowlevel.py:72:def current_token() -> EventLoopToken:
.venv\Lib\site-packages\anyio\lowlevel.py:74:    Return a token object that can be used to call code in the current event loop from
.venv\Lib\site-packages\anyio\lowlevel.py:81:    raw_token = backend_class.current_token()
.venv\Lib\site-packages\anyio\lowlevel.py:82:    return EventLoopToken(backend_class, raw_token)
.venv\Lib\site-packages\anyio\lowlevel.py:92:class RunvarToken(Generic[T]):
.venv\Lib\site-packages\anyio\lowlevel.py:118:        native_token = current_token().native_token
.venv\Lib\site-packages\anyio\lowlevel.py:120:            return _run_vars[native_token]
.venv\Lib\site-packages\anyio\lowlevel.py:122:            run_vars = _run_vars[native_token] = {}
.venv\Lib\site-packages\anyio\lowlevel.py:146:    def set(self, value: T) -> RunvarToken[T]:
.venv\Lib\site-packages\anyio\lowlevel.py:148:        token = RunvarToken(self, current_vars.get(self, RunVar.NO_VALUE_SET))
.venv\Lib\site-packages\anyio\lowlevel.py:150:        return token
.venv\Lib\site-packages\anyio\lowlevel.py:152:    def reset(self, token: RunvarToken[T]) -> None:
.venv\Lib\site-packages\anyio\lowlevel.py:153:        if token._var is not self:
.venv\Lib\site-packages\anyio\lowlevel.py:154:            raise ValueError("This token does not belong to this RunVar")
.venv\Lib\site-packages\anyio\lowlevel.py:156:        if token._redeemed:
.venv\Lib\site-packages\anyio\lowlevel.py:157:            raise ValueError("This token has already been used")
.venv\Lib\site-packages\anyio\lowlevel.py:159:        if token._value is _NoValueSet.NO_VALUE_SET:
.venv\Lib\site-packages\anyio\lowlevel.py:165:            self._current_vars[self] = token._value
.venv\Lib\site-packages\anyio\lowlevel.py:167:        token._redeemed = True
.venv\Lib\site-packages\anyio\pytest_plugin.py:48:            token = sniffio.current_async_library_cvar.set(backend_name)
.venv\Lib\site-packages\anyio\pytest_plugin.py:49:            _runner_stack.callback(sniffio.current_async_library_cvar.reset, token)
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1945:    _total_tokens: float = 0
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1947:    def __new__(cls, total_tokens: float) -> CapacityLimiter:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1950:    def __init__(self, total_tokens: float):
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1953:        self.total_tokens = total_tokens
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1967:    def total_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1968:        return self._total_tokens
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1970:    @total_tokens.setter
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1971:    def total_tokens(self, value: float) -> None:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1973:            raise TypeError("total_tokens must be an int or math.inf")
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1975:            raise ValueError("total_tokens must be >= 1")
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1977:        waiters_to_notify = max(value - self._total_tokens, 0)
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1978:        self._total_tokens = value
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1987:    def borrowed_tokens(self) -> int:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1991:    def available_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1992:        return self._total_tokens - len(self._borrowers)
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:1996:        if self._wait_queue and len(self._borrowers) < self._total_tokens:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2006:                "this borrower is already holding one of this CapacityLimiter's tokens"
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2009:        if self._wait_queue or len(self._borrowers) >= self._total_tokens:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2049:                "this borrower isn't holding any of this CapacityLimiter's tokens"
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2056:            self.borrowed_tokens,
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2057:            self.total_tokens,
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2328:    def current_token(cls) -> object:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2423:    def create_capacity_limiter(cls, total_tokens: float) -> abc.CapacityLimiter:
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2424:        return CapacityLimiter(total_tokens)
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2504:        token: object,
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2521:            "AbstractEventLoop", token or threadlocals.current_token.native_token
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2539:        token: object,
.venv\Lib\site-packages\anyio\_backends\_asyncio.py:2552:            "AbstractEventLoop", token or threadlocals.current_token.native_token
.venv\Lib\site-packages\anyio\_backends\_trio.py:238:        self._token = trio.lowlevel.current_trio_token()
.venv\Lib\site-packages\anyio\_backends\_trio.py:255:            trio_token=self._token,
.venv\Lib\site-packages\anyio\_backends\_trio.py:775:        total_tokens: float | None = None,
.venv\Lib\site-packages\anyio\_backends\_trio.py:783:        total_tokens: float | None = None,
.venv\Lib\site-packages\anyio\_backends\_trio.py:790:            assert total_tokens is not None
.venv\Lib\site-packages\anyio\_backends\_trio.py:791:            self.__original = trio.CapacityLimiter(total_tokens)
.venv\Lib\site-packages\anyio\_backends\_trio.py:805:    def total_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_backends\_trio.py:806:        return self.__original.total_tokens
.venv\Lib\site-packages\anyio\_backends\_trio.py:808:    @total_tokens.setter
.venv\Lib\site-packages\anyio\_backends\_trio.py:809:    def total_tokens(self, value: float) -> None:
.venv\Lib\site-packages\anyio\_backends\_trio.py:810:        self.__original.total_tokens = value
.venv\Lib\site-packages\anyio\_backends\_trio.py:813:    def borrowed_tokens(self) -> int:
.venv\Lib\site-packages\anyio\_backends\_trio.py:814:        return self.__original.borrowed_tokens
.venv\Lib\site-packages\anyio\_backends\_trio.py:817:    def available_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_backends\_trio.py:818:        return self.__original.available_tokens
.venv\Lib\site-packages\anyio\_backends\_trio.py:841:            borrowed_tokens=orig.borrowed_tokens,
.venv\Lib\site-packages\anyio\_backends\_trio.py:842:            total_tokens=orig.total_tokens,
.venv\Lib\site-packages\anyio\_backends\_trio.py:1005:    def current_token(cls) -> object:
.venv\Lib\site-packages\anyio\_backends\_trio.py:1006:        return trio.lowlevel.current_trio_token()
.venv\Lib\site-packages\anyio\_backends\_trio.py:1065:    def create_capacity_limiter(cls, total_tokens: float) -> CapacityLimiter:
.venv\Lib\site-packages\anyio\_backends\_trio.py:1066:        return CapacityLimiter(total_tokens)
.venv\Lib\site-packages\anyio\_backends\_trio.py:1077:            with claim_worker_thread(TrioBackend, token):
.venv\Lib\site-packages\anyio\_backends\_trio.py:1080:        token = TrioBackend.current_token()
.venv\Lib\site-packages\anyio\_backends\_trio.py:1096:        token: object,
.venv\Lib\site-packages\anyio\_backends\_trio.py:1098:        trio_token = cast("trio.lowlevel.TrioToken | None", token)
.venv\Lib\site-packages\anyio\_backends\_trio.py:1100:            return trio.from_thread.run(func, *args, trio_token=trio_token)
.venv\Lib\site-packages\anyio\_backends\_trio.py:1109:        token: object,
.venv\Lib\site-packages\anyio\_backends\_trio.py:1111:        trio_token = cast("trio.lowlevel.TrioToken | None", token)
.venv\Lib\site-packages\anyio\_backends\_trio.py:1113:            return trio.from_thread.run_sync(func, *args, trio_token=trio_token)
.venv\Lib\site-packages\anyio\_core\_eventloop.py:66:    token = None
.venv\Lib\site-packages\anyio\_core\_eventloop.py:70:        token = sniffio.current_async_library_cvar.set(backend)
.venv\Lib\site-packages\anyio\_core\_eventloop.py:76:        if token:
.venv\Lib\site-packages\anyio\_core\_eventloop.py:77:            sniffio.current_async_library_cvar.reset(token)
.venv\Lib\site-packages\anyio\_core\_eventloop.py:143:    backend_class: type[AsyncBackend], token: object
.venv\Lib\site-packages\anyio\_core\_eventloop.py:145:    from ..lowlevel import EventLoopToken
.venv\Lib\site-packages\anyio\_core\_eventloop.py:147:    threadlocals.current_token = EventLoopToken(backend_class, token)
.venv\Lib\site-packages\anyio\_core\_eventloop.py:151:        del threadlocals.current_token
.venv\Lib\site-packages\anyio\_core\_exceptions.py:140:    not calling from an AnyIO worker thread, and no ``token`` was passed.
.venv\Lib\site-packages\anyio\_core\_exceptions.py:147:    loop associated with the explicitly passed token has already finished.
.venv\Lib\site-packages\anyio\_core\_exceptions.py:152:            "The event loop associated with the given token has already finished"
.venv\Lib\site-packages\anyio\_core\_synchronization.py:33:    :ivar int borrowed_tokens: number of tokens currently borrowed by tasks
.venv\Lib\site-packages\anyio\_core\_synchronization.py:34:    :ivar float total_tokens: total number of available tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:35:    :ivar tuple borrowers: tasks or other objects currently holding tokens borrowed from
.venv\Lib\site-packages\anyio\_core\_synchronization.py:42:    borrowed_tokens: int
.venv\Lib\site-packages\anyio\_core\_synchronization.py:43:    total_tokens: float
.venv\Lib\site-packages\anyio\_core\_synchronization.py:515:    def __new__(cls, total_tokens: float) -> CapacityLimiter:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:517:            return get_async_backend().create_capacity_limiter(total_tokens)
.venv\Lib\site-packages\anyio\_core\_synchronization.py:519:            return CapacityLimiterAdapter(total_tokens)
.venv\Lib\site-packages\anyio\_core\_synchronization.py:533:    def total_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:535:        The total number of tokens available for borrowing.
.venv\Lib\site-packages\anyio\_core\_synchronization.py:537:        This is a read-write property. If the total number of tokens is increased, the
.venv\Lib\site-packages\anyio\_core\_synchronization.py:539:        tokens.
.venv\Lib\site-packages\anyio\_core\_synchronization.py:547:    @total_tokens.setter
.venv\Lib\site-packages\anyio\_core\_synchronization.py:548:    def total_tokens(self, value: float) -> None:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:552:    def borrowed_tokens(self) -> int:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:553:        """The number of tokens that have currently been borrowed."""
.venv\Lib\site-packages\anyio\_core\_synchronization.py:557:    def available_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:558:        """The number of tokens currently available to be borrowed"""
.venv\Lib\site-packages\anyio\_core\_synchronization.py:563:        Acquire a token for the current task without waiting for one to become
.venv\Lib\site-packages\anyio\_core\_synchronization.py:566:        :raises ~anyio.WouldBlock: if there are no tokens available for borrowing
.venv\Lib\site-packages\anyio\_core\_synchronization.py:573:        Acquire a token without waiting for one to become available.
.venv\Lib\site-packages\anyio\_core\_synchronization.py:575:        :param borrower: the entity borrowing a token
.venv\Lib\site-packages\anyio\_core\_synchronization.py:576:        :raises ~anyio.WouldBlock: if there are no tokens available for borrowing
.venv\Lib\site-packages\anyio\_core\_synchronization.py:583:        Acquire a token for the current task, waiting if necessary for one to become
.venv\Lib\site-packages\anyio\_core\_synchronization.py:591:        Acquire a token, waiting if necessary for one to become available.
.venv\Lib\site-packages\anyio\_core\_synchronization.py:593:        :param borrower: the entity borrowing a token
.venv\Lib\site-packages\anyio\_core\_synchronization.py:600:        Release the token held by the current task.
.venv\Lib\site-packages\anyio\_core\_synchronization.py:602:        :raises RuntimeError: if the current task has not borrowed a token from this
.venv\Lib\site-packages\anyio\_core\_synchronization.py:610:        Release the token held by the given borrower.
.venv\Lib\site-packages\anyio\_core\_synchronization.py:612:        :raises RuntimeError: if the borrower has not borrowed a token from this
.venv\Lib\site-packages\anyio\_core\_synchronization.py:631:    def __new__(cls, total_tokens: float) -> CapacityLimiterAdapter:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:634:    def __init__(self, total_tokens: float) -> None:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:635:        self.total_tokens = total_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:641:                self._total_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:658:    def total_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:660:            return self._total_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:662:        return self._internal_limiter.total_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:664:    @total_tokens.setter
.venv\Lib\site-packages\anyio\_core\_synchronization.py:665:    def total_tokens(self, value: float) -> None:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:667:            raise TypeError("total_tokens must be an int or math.inf")
.venv\Lib\site-packages\anyio\_core\_synchronization.py:669:            raise ValueError("total_tokens must be >= 1")
.venv\Lib\site-packages\anyio\_core\_synchronization.py:672:            self._total_tokens = value
.venv\Lib\site-packages\anyio\_core\_synchronization.py:675:        self._limiter.total_tokens = value
.venv\Lib\site-packages\anyio\_core\_synchronization.py:678:    def borrowed_tokens(self) -> int:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:682:        return self._internal_limiter.borrowed_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:685:    def available_tokens(self) -> float:
.venv\Lib\site-packages\anyio\_core\_synchronization.py:687:            return self._total_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:689:        return self._internal_limiter.available_tokens
.venv\Lib\site-packages\anyio\_core\_synchronization.py:712:                borrowed_tokens=0,
.venv\Lib\site-packages\anyio\_core\_synchronization.py:713:                total_tokens=self.total_tokens,
.venv\Lib\site-packages\cffi\_imp_emulation.py:19:    import tokenize
.venv\Lib\site-packages\cffi\_imp_emulation.py:76:                encoding = tokenize.detect_encoding(file.readline)[0]
.venv\Lib\site-packages\click\core.py:226:    :param token_normalize_func: an optional function that is used to
.venv\Lib\site-packages\click\core.py:227:                                 normalize tokens (options, choices,
.venv\Lib\site-packages\click\core.py:242:        Click 9.0. ``args`` will contain remaining unparsed tokens.
.venv\Lib\site-packages\click\core.py:265:        ``token_normalize_func`` parameters.
.venv\Lib\site-packages\click\core.py:288:        token_normalize_func: t.Callable[[str], str] | None = None,
.venv\Lib\site-packages\click\core.py:394:        if token_normalize_func is None and parent is not None:
.venv\Lib\site-packages\click\core.py:395:            token_normalize_func = parent.token_normalize_func
.venv\Lib\site-packages\click\core.py:397:        #: An optional normalization function for tokens.  This is
.venv\Lib\site-packages\click\core.py:399:        self.token_normalize_func: t.Callable[[str], str] | None = token_normalize_func
.venv\Lib\site-packages\click\core.py:449:            " 'args' will contain remaining unparsed tokens.",
.venv\Lib\site-packages\click\core.py:1895:        if cmd is None and ctx.token_normalize_func is not None:
.venv\Lib\site-packages\click\core.py:1896:            cmd_name = ctx.token_normalize_func(cmd_name)
.venv\Lib\site-packages\click\parser.py:121:    if ctx is None or ctx.token_normalize_func is None:
.venv\Lib\site-packages\click\parser.py:124:    return f"{prefix}{ctx.token_normalize_func(opt)}"
.venv\Lib\site-packages\click\shell_completion.py:469:    incomplete escape sequence and uses the partial token as-is.
.venv\Lib\site-packages\click\shell_completion.py:492:        for token in lex:
.venv\Lib\site-packages\click\shell_completion.py:493:            out.append(token)
.venv\Lib\site-packages\click\shell_completion.py:496:        # the partial token as-is. The quote or escape character is in
.venv\Lib\site-packages\click\shell_completion.py:497:        # lex.state, not lex.token.
.venv\Lib\site-packages\click\shell_completion.py:498:        out.append(lex.token)
.venv\Lib\site-packages\click\types.py:293:        By default uses :meth:`Context.token_normalize_func` and if not case
.venv\Lib\site-packages\click\types.py:300:        if ctx is not None and ctx.token_normalize_func is not None:
.venv\Lib\site-packages\click\types.py:301:            normed_value = ctx.token_normalize_func(normed_value)
.venv\Lib\site-packages\cryptography\fernet.py:21:class InvalidToken(Exception):
.venv\Lib\site-packages\cryptography\fernet.py:84:    def decrypt(self, token: bytes | str, ttl: int | None = None) -> bytes:
.venv\Lib\site-packages\cryptography\fernet.py:85:        timestamp, data = Fernet._get_unverified_token_data(token)
.venv\Lib\site-packages\cryptography\fernet.py:93:        self, token: bytes | str, ttl: int, current_time: int
.venv\Lib\site-packages\cryptography\fernet.py:99:        timestamp, data = Fernet._get_unverified_token_data(token)
.venv\Lib\site-packages\cryptography\fernet.py:102:    def extract_timestamp(self, token: bytes | str) -> int:
.venv\Lib\site-packages\cryptography\fernet.py:103:        timestamp, data = Fernet._get_unverified_token_data(token)
.venv\Lib\site-packages\cryptography\fernet.py:104:        # Verify the token was not tampered with.
.venv\Lib\site-packages\cryptography\fernet.py:109:    def _get_unverified_token_data(token: bytes | str) -> tuple[int, bytes]:
.venv\Lib\site-packages\cryptography\fernet.py:110:        if not isinstance(token, (str, bytes)):
.venv\Lib\site-packages\cryptography\fernet.py:111:            raise TypeError("token must be bytes or str")
.venv\Lib\site-packages\cryptography\fernet.py:114:            data = base64.urlsafe_b64decode(token)
.venv\Lib\site-packages\cryptography\fernet.py:116:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:119:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:122:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:133:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:144:                raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:147:                raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:160:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:167:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:187:        timestamp, data = Fernet._get_unverified_token_data(msg)
.venv\Lib\site-packages\cryptography\fernet.py:192:            except InvalidToken:
.venv\Lib\site-packages\cryptography\fernet.py:195:            raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:204:            except InvalidToken:
.venv\Lib\site-packages\cryptography\fernet.py:206:        raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:214:            except InvalidToken:
.venv\Lib\site-packages\cryptography\fernet.py:216:        raise InvalidToken
.venv\Lib\site-packages\cryptography\fernet.py:222:            except InvalidToken:
.venv\Lib\site-packages\cryptography\fernet.py:224:        raise InvalidToken
.venv\Lib\site-packages\cryptography\hazmat\primitives\twofactor\hotp.py:13:from cryptography.hazmat.primitives.twofactor import InvalidToken
.venv\Lib\site-packages\cryptography\hazmat\primitives\twofactor\hotp.py:80:            raise InvalidToken("Supplied HOTP value does not match.")
.venv\Lib\site-packages\cryptography\hazmat\primitives\twofactor\totp.py:10:from cryptography.hazmat.primitives.twofactor import InvalidToken
.venv\Lib\site-packages\cryptography\hazmat\primitives\twofactor\totp.py:45:            raise InvalidToken("Supplied TOTP value does not match.")
.venv\Lib\site-packages\cryptography\hazmat\primitives\twofactor\__init__.py:8:class InvalidToken(Exception):
.venv\Lib\site-packages\dateutil\parser\_parser.py:74:        self.tokenstack = []
.venv\Lib\site-packages\dateutil\parser\_parser.py:77:    def get_token(self):
.venv\Lib\site-packages\dateutil\parser\_parser.py:79:        This function breaks the time string into lexical units (tokens), which
.venv\Lib\site-packages\dateutil\parser\_parser.py:87:        any dot-separated strings before breaking it into tokens; as such, this
.venv\Lib\site-packages\dateutil\parser\_parser.py:88:        function maintains a "token stack", for when the ambiguous context
.venv\Lib\site-packages\dateutil\parser\_parser.py:89:        demands that multiple tokens be parsed at once.
.venv\Lib\site-packages\dateutil\parser\_parser.py:91:        if self.tokenstack:
.venv\Lib\site-packages\dateutil\parser\_parser.py:92:            return self.tokenstack.pop(0)
.venv\Lib\site-packages\dateutil\parser\_parser.py:95:        token = None
.venv\Lib\site-packages\dateutil\parser\_parser.py:99:            # We only realize that we've reached the end of a token when we
.venv\Lib\site-packages\dateutil\parser\_parser.py:100:            # find a character that's not part of the current token - since
.venv\Lib\site-packages\dateutil\parser\_parser.py:101:            # that character may be part of the next token, it's stored in the
.venv\Lib\site-packages\dateutil\parser\_parser.py:114:                # First character of the token - determines if we're starting
.venv\Lib\site-packages\dateutil\parser\_parser.py:116:                token = nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:122:                    token = ' '
.venv\Lib\site-packages\dateutil\parser\_parser.py:123:                    break  # emit token
.venv\Lib\site-packages\dateutil\parser\_parser.py:125:                    break  # emit token
.venv\Lib\site-packages\dateutil\parser\_parser.py:131:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:133:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:137:                    break  # emit token
.venv\Lib\site-packages\dateutil\parser\_parser.py:142:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:143:                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):
.venv\Lib\site-packages\dateutil\parser\_parser.py:144:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:148:                    break  # emit token
.venv\Lib\site-packages\dateutil\parser\_parser.py:151:                # parsing, and the tokens will be broken up later.
.venv\Lib\site-packages\dateutil\parser\_parser.py:154:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:155:                elif self.isnum(nextchar) and token[-1] == '.':
.venv\Lib\site-packages\dateutil\parser\_parser.py:156:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:160:                    break  # emit token
.venv\Lib\site-packages\dateutil\parser\_parser.py:163:                # break up the tokens later.
.venv\Lib\site-packages\dateutil\parser\_parser.py:165:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:166:                elif self.isword(nextchar) and token[-1] == '.':
.venv\Lib\site-packages\dateutil\parser\_parser.py:167:                    token += nextchar
.venv\Lib\site-packages\dateutil\parser\_parser.py:171:                    break  # emit token
.venv\Lib\site-packages\dateutil\parser\_parser.py:173:        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or
.venv\Lib\site-packages\dateutil\parser\_parser.py:174:                                       token[-1] in '.,')):
.venv\Lib\site-packages\dateutil\parser\_parser.py:175:            l = self._split_decimal.split(token)
.venv\Lib\site-packages\dateutil\parser\_parser.py:176:            token = l[0]
.venv\Lib\site-packages\dateutil\parser\_parser.py:179:                    self.tokenstack.append(tok)
.venv\Lib\site-packages\dateutil\parser\_parser.py:181:        if state == '0.' and token.count('.') == 0:
.venv\Lib\site-packages\dateutil\parser\_parser.py:182:            token = token.replace(',', '.')
.venv\Lib\site-packages\dateutil\parser\_parser.py:184:        return token
.venv\Lib\site-packages\dateutil\parser\_parser.py:190:        token = self.get_token()
.venv\Lib\site-packages\dateutil\parser\_parser.py:191:        if token is None:
.venv\Lib\site-packages\dateutil\parser\_parser.py:194:        return token
.venv\Lib\site-packages\dateutil\parser\_parser.py:619:            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
.venv\Lib\site-packages\dateutil\parser\_parser.py:621:            a tuple containing the fuzzy tokens.
.venv\Lib\site-packages\dateutil\parser\_parser.py:640:        res, skipped_tokens = self._parse(timestr, **kwargs)
.venv\Lib\site-packages\dateutil\parser\_parser.py:656:        if kwargs.get('fuzzy_with_tokens', False):
.venv\Lib\site-packages\dateutil\parser\_parser.py:657:            return ret, skipped_tokens
.venv\Lib\site-packages\dateutil\parser\_parser.py:664:                     "tzname", "tzoffset", "ampm","any_unused_tokens"]
.venv\Lib\site-packages\dateutil\parser\_parser.py:667:               fuzzy_with_tokens=False):
.venv\Lib\site-packages\dateutil\parser\_parser.py:694:        :param fuzzy_with_tokens:
.venv\Lib\site-packages\dateutil\parser\_parser.py:703:                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
.venv\Lib\site-packages\dateutil\parser\_parser.py:707:        if fuzzy_with_tokens:
.venv\Lib\site-packages\dateutil\parser\_parser.py:719:        l = _timelex.split(timestr)         # Splits the timestr into tokens
.venv\Lib\site-packages\dateutil\parser\_parser.py:739:                    # Numeric token
.venv\Lib\site-packages\dateutil\parser\_parser.py:740:                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)
.venv\Lib\site-packages\dateutil\parser\_parser.py:869:        if fuzzy_with_tokens:
.venv\Lib\site-packages\dateutil\parser\_parser.py:870:            skipped_tokens = self._recombine_skipped(l, skipped_idxs)
.venv\Lib\site-packages\dateutil\parser\_parser.py:871:            return res, tuple(skipped_tokens)
.venv\Lib\site-packages\dateutil\parser\_parser.py:875:    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
.venv\Lib\site-packages\dateutil\parser\_parser.py:876:        # Token is a number
.venv\Lib\site-packages\dateutil\parser\_parser.py:877:        value_repr = tokens[idx]
.venv\Lib\site-packages\dateutil\parser\_parser.py:881:            six.raise_from(ValueError('Unknown numeric token'), e)
.venv\Lib\site-packages\dateutil\parser\_parser.py:885:        len_l = len(tokens)
.venv\Lib\site-packages\dateutil\parser\_parser.py:890:             (tokens[idx + 1] != ':' and
.venv\Lib\site-packages\dateutil\parser\_parser.py:891:              info.hms(tokens[idx + 1]) is None))):
.venv\Lib\site-packages\dateutil\parser\_parser.py:893:            s = tokens[idx]
.venv\Lib\site-packages\dateutil\parser\_parser.py:899:        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):
.venv\Lib\site-packages\dateutil\parser\_parser.py:901:            s = tokens[idx]
.venv\Lib\site-packages\dateutil\parser\_parser.py:903:            if not ymd and '.' not in tokens[idx]:
.venv\Lib\site-packages\dateutil\parser\_parser.py:917:            s = tokens[idx]
.venv\Lib\site-packages\dateutil\parser\_parser.py:929:        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:
.venv\Lib\site-packages\dateutil\parser\_parser.py:931:            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)
.venv\Lib\site-packages\dateutil\parser\_parser.py:932:            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)
.venv\Lib\site-packages\dateutil\parser\_parser.py:938:        elif idx + 2 < len_l and tokens[idx + 1] == ':':
.venv\Lib\site-packages\dateutil\parser\_parser.py:941:            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?
.venv\Lib\site-packages\dateutil\parser\_parser.py:944:            if idx + 4 < len_l and tokens[idx + 3] == ':':
.venv\Lib\site-packages\dateutil\parser\_parser.py:945:                res.second, res.microsecond = self._parsems(tokens[idx + 4])
.venv\Lib\site-packages\dateutil\parser\_parser.py:951:        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):
.venv\Lib\site-packages\dateutil\parser\_parser.py:952:            sep = tokens[idx + 1]
.venv\Lib\site-packages\dateutil\parser\_parser.py:955:            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):
.venv\Lib\site-packages\dateutil\parser\_parser.py:956:                if tokens[idx + 2].isdigit():
.venv\Lib\site-packages\dateutil\parser\_parser.py:958:                    ymd.append(tokens[idx + 2])
.venv\Lib\site-packages\dateutil\parser\_parser.py:961:                    value = info.month(tokens[idx + 2])
.venv\Lib\site-packages\dateutil\parser\_parser.py:968:                if idx + 3 < len_l and tokens[idx + 3] == sep:
.venv\Lib\site-packages\dateutil\parser\_parser.py:970:                    value = info.month(tokens[idx + 4])
.venv\Lib\site-packages\dateutil\parser\_parser.py:975:                        ymd.append(tokens[idx + 4])
.venv\Lib\site-packages\dateutil\parser\_parser.py:981:        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):
.venv\Lib\site-packages\dateutil\parser\_parser.py:982:            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:
.venv\Lib\site-packages\dateutil\parser\_parser.py:985:                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))
.venv\Lib\site-packages\dateutil\parser\_parser.py:992:        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):
.venv\Lib\site-packages\dateutil\parser\_parser.py:995:            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))
.venv\Lib\site-packages\dateutil\parser\_parser.py:1006:    def _find_hms_idx(self, idx, tokens, info, allow_jump):
.venv\Lib\site-packages\dateutil\parser\_parser.py:1007:        len_l = len(tokens)
.venv\Lib\site-packages\dateutil\parser\_parser.py:1009:        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
.venv\Lib\site-packages\dateutil\parser\_parser.py:1010:            # There is an "h", "m", or "s" label following this token.  We take
.venv\Lib\site-packages\dateutil\parser\_parser.py:1011:            # assign the upcoming label to the current token.
.venv\Lib\site-packages\dateutil\parser\_parser.py:1015:        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and
.venv\Lib\site-packages\dateutil\parser\_parser.py:1016:              info.hms(tokens[idx+2]) is not None):
.venv\Lib\site-packages\dateutil\parser\_parser.py:1021:        elif idx > 0 and info.hms(tokens[idx-1]) is not None:
.venv\Lib\site-packages\dateutil\parser\_parser.py:1022:            # There is a "h", "m", or "s" preceding this token.  Since neither
.venv\Lib\site-packages\dateutil\parser\_parser.py:1024:            # token, so we use the previous label.
.venv\Lib\site-packages\dateutil\parser\_parser.py:1028:        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and
.venv\Lib\site-packages\dateutil\parser\_parser.py:1029:              info.hms(tokens[idx-2]) is not None):
.venv\Lib\site-packages\dateutil\parser\_parser.py:1030:            # If we are looking at the final token, we allow for a
.venv\Lib\site-packages\dateutil\parser\_parser.py:1056:    def _could_be_tzname(self, hour, tzname, tzoffset, token):
.venv\Lib\site-packages\dateutil\parser\_parser.py:1060:                len(token) <= 5 and
.venv\Lib\site-packages\dateutil\parser\_parser.py:1061:                (all(x in string.ascii_uppercase for x in token)
.venv\Lib\site-packages\dateutil\parser\_parser.py:1062:                 or token in self.info.UTCZONE))
.venv\Lib\site-packages\dateutil\parser\_parser.py:1111:    def _parse_hms(self, idx, tokens, info, hms_idx):
.venv\Lib\site-packages\dateutil\parser\_parser.py:1120:            hms = info.hms(tokens[hms_idx])
.venv\Lib\site-packages\dateutil\parser\_parser.py:1124:            hms = info.hms(tokens[hms_idx]) + 1
.venv\Lib\site-packages\dateutil\parser\_parser.py:1130:    # Handling for individual tokens.  These are kept as methods instead
.venv\Lib\site-packages\dateutil\parser\_parser.py:1250:    def _recombine_skipped(self, tokens, skipped_idxs):
.venv\Lib\site-packages\dateutil\parser\_parser.py:1252:        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
.venv\Lib\site-packages\dateutil\parser\_parser.py:1254:        >>> _recombine_skipped(tokens, skipped_idxs)
.venv\Lib\site-packages\dateutil\parser\_parser.py:1257:        skipped_tokens = []
.venv\Lib\site-packages\dateutil\parser\_parser.py:1260:                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]
.venv\Lib\site-packages\dateutil\parser\_parser.py:1262:                skipped_tokens.append(tokens[idx])
.venv\Lib\site-packages\dateutil\parser\_parser.py:1264:        return skipped_tokens
.venv\Lib\site-packages\dateutil\parser\_parser.py:1338:    :param fuzzy_with_tokens:
.venv\Lib\site-packages\dateutil\parser\_parser.py:1347:            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
.venv\Lib\site-packages\dateutil\parser\_parser.py:1352:        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
.venv\Lib\site-packages\dateutil\parser\_parser.py:1354:        a tuple containing the fuzzy tokens.
.venv\Lib\site-packages\dateutil\parser\_parser.py:1578:        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({",",":"})
.venv\Lib\site-packages\dateutil\tz\tz.py:1086:        if res is None or res.any_unused_tokens:
.venv\Lib\site-packages\docx\oxml\shape.py:15:    XsdToken,
.venv\Lib\site-packages\docx\oxml\shape.py:65:    uri: str = RequiredAttribute("uri", XsdToken)  # pyright: ignore[reportAssignmentType]
.venv\Lib\site-packages\docx\oxml\simpletypes.py:162:class XsdToken(BaseStringType):
.venv\Lib\site-packages\elevenlabs\conversational_ai\client.py:415:            An expiring token that enables a conversation to start. These can be generated for an agent using the /v1/convai/conversation/get_signed_url endpoint
.venv\Lib\site-packages\elevenlabs\conversational_ai\client.py:1491:            An expiring token that enables a conversation to start. These can be generated for an agent using the /v1/convai/conversation/get_signed_url endpoint
.venv\Lib\site-packages\elevenlabs\types\auth_settings.py:13:    shareable_token: typing.Optional[str] = None
.venv\Lib\site-packages\elevenlabs\types\conversation_token_db_model.py:5:from .conversation_token_purpose import ConversationTokenPurpose
.venv\Lib\site-packages\elevenlabs\types\conversation_token_db_model.py:10:class ConversationTokenDbModel(UncheckedBaseModel):
.venv\Lib\site-packages\elevenlabs\types\conversation_token_db_model.py:12:    conversation_token: str
.venv\Lib\site-packages\elevenlabs\types\conversation_token_db_model.py:14:    purpose: typing.Optional[ConversationTokenPurpose] = None
.venv\Lib\site-packages\elevenlabs\types\conversation_token_purpose.py:5:ConversationTokenPurpose = typing.Union[typing.Literal["signed_url", "shareable_link"], typing.Any]
.venv\Lib\site-packages\elevenlabs\types\get_agent_link_response_model.py:5:from .conversation_token_db_model import ConversationTokenDbModel
.venv\Lib\site-packages\elevenlabs\types\get_agent_link_response_model.py:12:    token: typing.Optional[ConversationTokenDbModel] = None
.venv\Lib\site-packages\elevenlabs\types\model.py:21:    token_cost_factor: typing.Optional[float] = None
.venv\Lib\site-packages\elevenlabs\types\prompt_agent.py:21:    max_tokens: typing.Optional[int] = None
.venv\Lib\site-packages\elevenlabs\types\__init__.py:58:from .conversation_token_db_model import ConversationTokenDbModel
.venv\Lib\site-packages\elevenlabs\types\__init__.py:59:from .conversation_token_purpose import ConversationTokenPurpose
.venv\Lib\site-packages\elevenlabs\types\__init__.py:256:    "ConversationTokenDbModel",
.venv\Lib\site-packages\elevenlabs\types\__init__.py:257:    "ConversationTokenPurpose",
.venv\Lib\site-packages\elevenlabs\__init__.py:57:    ConversationTokenDbModel,
.venv\Lib\site-packages\elevenlabs\__init__.py:58:    ConversationTokenPurpose,
.venv\Lib\site-packages\elevenlabs\__init__.py:314:    "ConversationTokenDbModel",
.venv\Lib\site-packages\elevenlabs\__init__.py:315:    "ConversationTokenPurpose",
.venv\Lib\site-packages\firebase_admin\app_check.py:19:from jwt import PyJWKClient, ExpiredSignatureError, InvalidTokenError, DecodeError
.venv\Lib\site-packages\firebase_admin\app_check.py:28:def verify_token(token: str, app=None) -> Dict[str, Any]:
.venv\Lib\site-packages\firebase_admin\app_check.py:29:    """Verifies a Firebase App Check token.
.venv\Lib\site-packages\firebase_admin\app_check.py:32:        token: A token from App Check.
.venv\Lib\site-packages\firebase_admin\app_check.py:36:        Dict[str, Any]: The token's decoded claims.
.venv\Lib\site-packages\firebase_admin\app_check.py:40:        or if the token's headers or payload are invalid.
.venv\Lib\site-packages\firebase_admin\app_check.py:43:    return _get_app_check_service(app).verify_token(token)
.venv\Lib\site-packages\firebase_admin\app_check.py:73:    def verify_token(self, token: str) -> Dict[str, Any]:
.venv\Lib\site-packages\firebase_admin\app_check.py:74:        """Verifies a Firebase App Check token."""
.venv\Lib\site-packages\firebase_admin\app_check.py:75:        _Validators.check_string("app check token", token)
.venv\Lib\site-packages\firebase_admin\app_check.py:81:            signing_key = self._jwks_client.get_signing_key_from_jwt(token)
.venv\Lib\site-packages\firebase_admin\app_check.py:82:            self._has_valid_token_headers(jwt.get_unverified_header(token))
.venv\Lib\site-packages\firebase_admin\app_check.py:83:            verified_claims = self._decode_and_verify(token, signing_key.key)
.venv\Lib\site-packages\firebase_admin\app_check.py:84:        except (InvalidTokenError, DecodeError) as exception:
.venv\Lib\site-packages\firebase_admin\app_check.py:86:                f'Verifying App Check token failed. Error: {exception}'
.venv\Lib\site-packages\firebase_admin\app_check.py:92:    def _has_valid_token_headers(self, headers: Any) -> None:
.venv\Lib\site-packages\firebase_admin\app_check.py:93:        """Checks whether the token has valid headers for App Check."""
.venv\Lib\site-packages\firebase_admin\app_check.py:94:        # Ensure the token's header has type JWT
.venv\Lib\site-packages\firebase_admin\app_check.py:96:            raise ValueError("The provided App Check token has an incorrect type header")
.venv\Lib\site-packages\firebase_admin\app_check.py:97:        # Ensure the token's header uses the algorithm RS256
.venv\Lib\site-packages\firebase_admin\app_check.py:101:                'The provided App Check token has an incorrect alg header. '
.venv\Lib\site-packages\firebase_admin\app_check.py:105:    def _decode_and_verify(self, token: str, signing_key: str):
.venv\Lib\site-packages\firebase_admin\app_check.py:106:        """Decodes and verifies the token from App Check."""
.venv\Lib\site-packages\firebase_admin\app_check.py:110:                token,
.venv\Lib\site-packages\firebase_admin\app_check.py:117:                'The provided App Check token has an invalid signature.'
.venv\Lib\site-packages\firebase_admin\app_check.py:121:                'The provided App Check token has an incorrect "aud" (audience) claim. '
.venv\Lib\site-packages\firebase_admin\app_check.py:126:                'The provided App Check token has an incorrect "iss" (issuer) claim. '
.venv\Lib\site-packages\firebase_admin\app_check.py:131:                'The provided App Check token has expired.'
.venv\Lib\site-packages\firebase_admin\app_check.py:133:        except InvalidTokenError as exception:
.venv\Lib\site-packages\firebase_admin\app_check.py:135:                f'Decoding App Check token failed. Error: {exception}'
.venv\Lib\site-packages\firebase_admin\app_check.py:140:            raise ValueError('Firebase App Check token has incorrect "aud" (audience) claim.')
.venv\Lib\site-packages\firebase_admin\app_check.py:142:            raise ValueError('Token does not contain the correct "iss" (issuer).')
.venv\Lib\site-packages\firebase_admin\app_check.py:144:            'The provided App Check token "sub" (subject) claim',
.venv\Lib\site-packages\firebase_admin\auth.py:26:from firebase_admin import _token_gen
.venv\Lib\site-packages\firebase_admin\auth.py:44:    'ExpiredIdTokenError',
.venv\Lib\site-packages\firebase_admin\auth.py:53:    'InvalidIdTokenError',
.venv\Lib\site-packages\firebase_admin\auth.py:61:    'RevokedIdTokenError',
.venv\Lib\site-packages\firebase_admin\auth.py:64:    'TokenSignError',
.venv\Lib\site-packages\firebase_admin\auth.py:83:    'create_custom_token',
.venv\Lib\site-packages\firebase_admin\auth.py:99:    'get_user_by_phone_number',
.venv\Lib\site-packages\firebase_admin\auth.py:104:    'revoke_refresh_tokens',
.venv\Lib\site-packages\firebase_admin\auth.py:109:    'verify_id_token',
.venv\Lib\site-packages\firebase_admin\auth.py:114:CertificateFetchError = _token_gen.CertificateFetchError
.venv\Lib\site-packages\firebase_admin\auth.py:122:ExpiredIdTokenError = _token_gen.ExpiredIdTokenError
.venv\Lib\site-packages\firebase_admin\auth.py:123:ExpiredSessionCookieError = _token_gen.ExpiredSessionCookieError
.venv\Lib\site-packages\firebase_admin\auth.py:130:InvalidIdTokenError = _auth_utils.InvalidIdTokenError
.venv\Lib\site-packages\firebase_admin\auth.py:131:InvalidSessionCookieError = _token_gen.InvalidSessionCookieError
.venv\Lib\site-packages\firebase_admin\auth.py:138:RevokedIdTokenError = _token_gen.RevokedIdTokenError
.venv\Lib\site-packages\firebase_admin\auth.py:139:RevokedSessionCookieError = _token_gen.RevokedSessionCookieError
.venv\Lib\site-packages\firebase_admin\auth.py:141:TokenSignError = _token_gen.TokenSignError
.venv\Lib\site-packages\firebase_admin\auth.py:180:def create_custom_token(uid, developer_claims=None, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:181:    """Builds and signs a Firebase custom auth token.
.venv\Lib\site-packages\firebase_admin\auth.py:184:        uid: ID of the user for whom the token is created.
.venv\Lib\site-packages\firebase_admin\auth.py:185:        developer_claims: A dictionary of claims to be included in the token
.venv\Lib\site-packages\firebase_admin\auth.py:190:        bytes: A token minted from the input parameters.
.venv\Lib\site-packages\firebase_admin\auth.py:194:        TokenSignError: If an error occurs while signing the token using the remote IAM service.
.venv\Lib\site-packages\firebase_admin\auth.py:197:    return client.create_custom_token(uid, developer_claims)
.venv\Lib\site-packages\firebase_admin\auth.py:200:def verify_id_token(id_token, app=None, check_revoked=False, clock_skew_seconds=0):
.venv\Lib\site-packages\firebase_admin\auth.py:203:    Accepts a signed token string, verifies that it is current, and issued
.venv\Lib\site-packages\firebase_admin\auth.py:207:        id_token: A string of the encoded JWT.
.venv\Lib\site-packages\firebase_admin\auth.py:209:        check_revoked: Boolean, If true, checks whether the token has been revoked or
.venv\Lib\site-packages\firebase_admin\auth.py:211:        clock_skew_seconds: The number of seconds to tolerate when checking the token.
.venv\Lib\site-packages\firebase_admin\auth.py:217:        ValueError: If ``id_token`` is a not a string or is empty.
.venv\Lib\site-packages\firebase_admin\auth.py:218:        InvalidIdTokenError: If ``id_token`` is not a valid Firebase ID token.
.venv\Lib\site-packages\firebase_admin\auth.py:219:        ExpiredIdTokenError: If the specified ID token has expired.
.venv\Lib\site-packages\firebase_admin\auth.py:220:        RevokedIdTokenError: If ``check_revoked`` is ``True`` and the ID token has been revoked.
.venv\Lib\site-packages\firebase_admin\auth.py:222:            required to verify the ID token.
.venv\Lib\site-packages\firebase_admin\auth.py:227:    return client.verify_id_token(
.venv\Lib\site-packages\firebase_admin\auth.py:228:        id_token, check_revoked=check_revoked, clock_skew_seconds=clock_skew_seconds)
.venv\Lib\site-packages\firebase_admin\auth.py:231:def create_session_cookie(id_token, expires_in, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:232:    """Creates a new Firebase session cookie from the given ID token and options.
.venv\Lib\site-packages\firebase_admin\auth.py:237:        id_token: The Firebase ID token to exchange for a session cookie.
.venv\Lib\site-packages\firebase_admin\auth.py:251:    return client._token_generator.create_session_cookie(id_token, expires_in)
.venv\Lib\site-packages\firebase_admin\auth.py:282:    verified_claims = client._token_verifier.verify_session_cookie(
.venv\Lib\site-packages\firebase_admin\auth.py:290:def revoke_refresh_tokens(uid, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:291:    """Revokes all refresh tokens for an existing user.
.venv\Lib\site-packages\firebase_admin\auth.py:293:    This function updates the user's ``tokens_valid_after_timestamp`` to the current UTC
.venv\Lib\site-packages\firebase_admin\auth.py:297:    While this revokes all sessions for a specified user and disables any new ID tokens for
.venv\Lib\site-packages\firebase_admin\auth.py:298:    existing sessions from getting minted, existing ID tokens may remain active until their
.venv\Lib\site-packages\firebase_admin\auth.py:299:    natural expiration (one hour). To verify that ID tokens are revoked, use
.venv\Lib\site-packages\firebase_admin\auth.py:300:    ``verify_id_token(idToken, check_revoked=True)``.
.venv\Lib\site-packages\firebase_admin\auth.py:308:        FirebaseError: If an error occurs while revoking the refresh token.
.venv\Lib\site-packages\firebase_admin\auth.py:311:    client.revoke_refresh_tokens(uid)
.venv\Lib\site-packages\firebase_admin\auth.py:352:def get_user_by_phone_number(phone_number, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:356:        phone_number: A phone number string.
.venv\Lib\site-packages\firebase_admin\auth.py:368:    return client.get_user_by_phone_number(phone_number=phone_number)
.venv\Lib\site-packages\firebase_admin\auth.py:399:def list_users(page_token=None, max_results=_user_mgt.MAX_LIST_USERS_RESULTS, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:402:    The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\auth.py:408:        page_token: A non-empty page token string, which indicates the starting point of the page
.venv\Lib\site-packages\firebase_admin\auth.py:418:        ValueError: If ``max_results`` or ``page_token`` are invalid.
.venv\Lib\site-packages\firebase_admin\auth.py:422:    return client.list_users(page_token=page_token, max_results=max_results)
.venv\Lib\site-packages\firebase_admin\auth.py:437:        phone_number: The user's primary phone number (optional).
.venv\Lib\site-packages\firebase_admin\auth.py:468:        phone_number: The user's primary phone number (optional). Can be removed by explicitly
.venv\Lib\site-packages\firebase_admin\auth.py:477:            set by ``revoke_refresh_tokens`` and it is discouraged to set this field directly.
.venv\Lib\site-packages\firebase_admin\auth.py:496:    These claims propagate to all the devices where the user is already signed in (after token
.venv\Lib\site-packages\firebase_admin\auth.py:497:    expiration or when token refresh is forced), and next time the user signs in. The claims
.venv\Lib\site-packages\firebase_admin\auth.py:498:    can be accessed via the user's ID token JWT. If a reserved OIDC claim is specified (sub, iat,
.venv\Lib\site-packages\firebase_admin\auth.py:670:        id_token_response_type=None, code_response_type=None, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:690:            Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\auth.py:691:        id_token_response_type: A boolean which sets whether to enable the ID token response flow
.venv\Lib\site-packages\firebase_admin\auth.py:693:            Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\auth.py:705:        enabled=enabled, client_secret=client_secret, id_token_response_type=id_token_response_type,
.venv\Lib\site-packages\firebase_admin\auth.py:711:        client_secret=None, id_token_response_type=None, code_response_type=None, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:728:            Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\auth.py:729:        id_token_response_type: A boolean which sets whether to enable the ID token response flow
.venv\Lib\site-packages\firebase_admin\auth.py:731:            Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\auth.py:743:        enabled=enabled, client_secret=client_secret, id_token_response_type=id_token_response_type,
.venv\Lib\site-packages\firebase_admin\auth.py:764:        page_token=None, max_results=_auth_providers.MAX_LIST_CONFIGS_RESULTS, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:767:    The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\auth.py:773:        page_token: A non-empty page token string, which indicates the starting point of the
.venv\Lib\site-packages\firebase_admin\auth.py:784:        ValueError: If ``max_results`` or ``page_token`` are invalid.
.venv\Lib\site-packages\firebase_admin\auth.py:788:    return client.list_oidc_provider_configs(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\auth.py:902:        page_token=None, max_results=_auth_providers.MAX_LIST_CONFIGS_RESULTS, app=None):
.venv\Lib\site-packages\firebase_admin\auth.py:905:    The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\auth.py:911:        page_token: A non-empty page token string, which indicates the starting point of the
.venv\Lib\site-packages\firebase_admin\auth.py:922:        ValueError: If ``max_results`` or ``page_token`` are invalid.
.venv\Lib\site-packages\firebase_admin\auth.py:926:    return client.list_saml_provider_configs(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\credentials.py:37:AccessTokenInfo = collections.namedtuple('AccessTokenInfo', ['access_token', 'expiry'])
.venv\Lib\site-packages\firebase_admin\credentials.py:38:"""Data included in an OAuth2 access token.
.venv\Lib\site-packages\firebase_admin\credentials.py:40:Contains the access token string and the expiry time. The expirty time is exposed as a
.venv\Lib\site-packages\firebase_admin\credentials.py:46:    """Provides OAuth2 access tokens for accessing Firebase services."""
.venv\Lib\site-packages\firebase_admin\credentials.py:48:    def get_access_token(self):
.venv\Lib\site-packages\firebase_admin\credentials.py:49:        """Fetches a Google OAuth2 access token using this credential instance.
.venv\Lib\site-packages\firebase_admin\credentials.py:52:          AccessTokenInfo: An access token obtained using the credential.
.venv\Lib\site-packages\firebase_admin\credentials.py:56:        return AccessTokenInfo(google_cred.token, google_cred.expiry)
.venv\Lib\site-packages\firebase_admin\credentials.py:176:class RefreshToken(Base):
.venv\Lib\site-packages\firebase_admin\credentials.py:177:    """A credential initialized from an existing refresh token."""
.venv\Lib\site-packages\firebase_admin\credentials.py:181:    def __init__(self, refresh_token):
.venv\Lib\site-packages\firebase_admin\credentials.py:182:        """Initializes a credential from a refresh token JSON file.
.venv\Lib\site-packages\firebase_admin\credentials.py:184:        The JSON must consist of client_id, client_secret and refresh_token fields. Refresh
.venv\Lib\site-packages\firebase_admin\credentials.py:185:        token files are typically created and managed by the gcloud SDK. To instantiate
.venv\Lib\site-packages\firebase_admin\credentials.py:186:        a credential from a refresh token file, either specify the file path or a dict
.venv\Lib\site-packages\firebase_admin\credentials.py:190:          refresh_token: Path to a refresh token file or a dict representing the contents of a
.venv\Lib\site-packages\firebase_admin\credentials.py:191:              refresh token file.
.venv\Lib\site-packages\firebase_admin\credentials.py:195:          ValueError: If the refresh token configuration is invalid.
.venv\Lib\site-packages\firebase_admin\credentials.py:198:        if _is_file_path(refresh_token):
.venv\Lib\site-packages\firebase_admin\credentials.py:199:            with open(refresh_token, encoding='utf-8') as json_file:
.venv\Lib\site-packages\firebase_admin\credentials.py:201:        elif isinstance(refresh_token, dict):
.venv\Lib\site-packages\firebase_admin\credentials.py:202:            json_data = refresh_token
.venv\Lib\site-packages\firebase_admin\credentials.py:205:                f'Invalid refresh token argument: "{refresh_token}". Refresh token argument must '
.venv\Lib\site-packages\firebase_admin\credentials.py:210:                'Invalid refresh token configuration. JSON must contain a '
.venv\Lib\site-packages\firebase_admin\credentials.py:223:    def refresh_token(self):
.venv\Lib\site-packages\firebase_admin\credentials.py:224:        return self._g_credential.refresh_token
.venv\Lib\site-packages\firebase_admin\exceptions.py:140:    """Request not authenticated due to missing, invalid, or expired OAuth token."""
.venv\Lib\site-packages\firebase_admin\exceptions.py:149:    This can happen because the OAuth token does not have the right scopes, the client doesn't
.venv\Lib\site-packages\firebase_admin\functions.py:234:            'oidc_token': {
.venv\Lib\site-packages\firebase_admin\functions.py:293:            id_token = self._credential.token
.venv\Lib\site-packages\firebase_admin\functions.py:295:                {**task.http_request['headers'], 'Authorization': f'Bearer ${id_token}'}
.venv\Lib\site-packages\firebase_admin\functions.py:296:            # Delete oidc token
.venv\Lib\site-packages\firebase_admin\functions.py:297:            del task.http_request['oidc_token']
.venv\Lib\site-packages\firebase_admin\functions.py:299:            task.http_request['oidc_token'] = \
.venv\Lib\site-packages\firebase_admin\messaging.py:180:    """Sends the given mutlicast message to each token asynchronously via Firebase Cloud Messaging
.venv\Lib\site-packages\firebase_admin\messaging.py:207:        token=token
.venv\Lib\site-packages\firebase_admin\messaging.py:208:    ) for token in multicast_message.tokens]
.venv\Lib\site-packages\firebase_admin\messaging.py:212:    """Sends the given mutlicast message to each token via Firebase Cloud Messaging (FCM).
.venv\Lib\site-packages\firebase_admin\messaging.py:238:        token=token
.venv\Lib\site-packages\firebase_admin\messaging.py:239:    ) for token in multicast_message.tokens]
.venv\Lib\site-packages\firebase_admin\messaging.py:242:def subscribe_to_topic(tokens, topic, app=None):
.venv\Lib\site-packages\firebase_admin\messaging.py:243:    """Subscribes a list of registration tokens to an FCM topic.
.venv\Lib\site-packages\firebase_admin\messaging.py:246:        tokens: A non-empty list of device registration tokens. List may not have more than 1000
.venv\Lib\site-packages\firebase_admin\messaging.py:259:        tokens, topic, 'iid/v1:batchAdd')
.venv\Lib\site-packages\firebase_admin\messaging.py:261:def unsubscribe_from_topic(tokens, topic, app=None):
.venv\Lib\site-packages\firebase_admin\messaging.py:262:    """Unsubscribes a list of registration tokens from an FCM topic.
.venv\Lib\site-packages\firebase_admin\messaging.py:265:        tokens: A non-empty list of device registration tokens. List may not have more than 1000
.venv\Lib\site-packages\firebase_admin\messaging.py:278:        tokens, topic, 'iid/v1:batchRemove')
.venv\Lib\site-packages\firebase_admin\messaging.py:290:        """Index of the registration token to which this error is related to."""
.venv\Lib\site-packages\firebase_admin\messaging.py:317:        """Number of tokens that were successfully subscribed or unsubscribed."""
.venv\Lib\site-packages\firebase_admin\messaging.py:322:        """Number of tokens that could not be subscribed or unsubscribed due to errors."""
.venv\Lib\site-packages\firebase_admin\messaging.py:382:    IID_HEADERS = {'access_token_auth': 'true'}
.venv\Lib\site-packages\firebase_admin\messaging.py:489:    def make_topic_management_request(self, tokens, topic, operation):
.venv\Lib\site-packages\firebase_admin\messaging.py:491:        if isinstance(tokens, str):
.venv\Lib\site-packages\firebase_admin\messaging.py:492:            tokens = [tokens]
.venv\Lib\site-packages\firebase_admin\messaging.py:493:        if not isinstance(tokens, list) or not tokens:
.venv\Lib\site-packages\firebase_admin\messaging.py:494:            raise ValueError('Tokens must be a string or a non-empty list of strings.')
.venv\Lib\site-packages\firebase_admin\messaging.py:495:        invalid_str = [t for t in tokens if not isinstance(t, str) or not t]
.venv\Lib\site-packages\firebase_admin\messaging.py:497:            raise ValueError('Tokens must be non-empty strings.')
.venv\Lib\site-packages\firebase_admin\messaging.py:505:            'registration_tokens': tokens,
.venv\Lib\site-packages\firebase_admin\ml.py:149:def list_models(list_filter=None, page_size=None, page_token=None, app=None):
.venv\Lib\site-packages\firebase_admin\ml.py:156:        page_token: A next page token returned from a previous page of results. None
.venv\Lib\site-packages\firebase_admin\ml.py:165:        ml_service.list_models, list_filter, page_size, page_token, app=app)
.venv\Lib\site-packages\firebase_admin\ml.py:608:    def __init__(self, list_models_func, list_filter, page_size, page_token, app):
.venv\Lib\site-packages\firebase_admin\ml.py:612:        self._page_token = page_token
.venv\Lib\site-packages\firebase_admin\ml.py:614:        self._list_response = list_models_func(list_filter, page_size, page_token)
.venv\Lib\site-packages\firebase_admin\ml.py:629:    def next_page_token(self):
.venv\Lib\site-packages\firebase_admin\ml.py:630:        """Token identifying the next page of results."""
.venv\Lib\site-packages\firebase_admin\ml.py:631:        return self._list_response.get('nextPageToken', '')
.venv\Lib\site-packages\firebase_admin\ml.py:636:        return bool(self.next_page_token)
.venv\Lib\site-packages\firebase_admin\ml.py:649:                self.next_page_token,
.venv\Lib\site-packages\firebase_admin\ml.py:767:def _validate_page_token(page_token):
.venv\Lib\site-packages\firebase_admin\ml.py:768:    if page_token is not None:
.venv\Lib\site-packages\firebase_admin\ml.py:769:        if not isinstance(page_token, str):
.venv\Lib\site-packages\firebase_admin\ml.py:770:            raise TypeError('Page token must be a string or None.')
.venv\Lib\site-packages\firebase_admin\ml.py:913:    def list_models(self, list_filter, page_size, page_token):
.venv\Lib\site-packages\firebase_admin\ml.py:917:        _validate_page_token(page_token)
.venv\Lib\site-packages\firebase_admin\ml.py:923:        if page_token:
.venv\Lib\site-packages\firebase_admin\ml.py:924:            params['page_token'] = page_token
.venv\Lib\site-packages\firebase_admin\project_management.py:555:            next_page_token = response.get('nextPageToken')
.venv\Lib\site-packages\firebase_admin\project_management.py:556:            if not next_page_token:
.venv\Lib\site-packages\firebase_admin\project_management.py:561:                f'?pageToken={next_page_token}'
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:163:def list_tenants(page_token=None, max_results=_MAX_LIST_TENANTS_RESULTS, app=None):
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:166:    The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:172:        page_token: A non-empty page token string, which indicates the starting point of the page
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:182:        ValueError: If ``max_results`` or ``page_token`` are invalid.
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:186:    def download(page_token, max_results):
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:187:        return tenant_mgt_service.list_tenants(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:188:    return ListTenantsPage(download, page_token, max_results)
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:331:    def list_tenants(self, page_token=None, max_results=_MAX_LIST_TENANTS_RESULTS):
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:333:        if page_token is not None:
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:334:            if not isinstance(page_token, str) or not page_token:
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:335:                raise ValueError('Page token must be a non-empty string.')
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:344:        if page_token:
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:345:            payload['pageToken'] = page_token
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:360:    def __init__(self, download, page_token, max_results):
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:363:        self._current = download(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:371:    def next_page_token(self):
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:372:        """Page token string for the next page (empty string indicates no more pages)."""
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:373:        return self._current.get('nextPageToken', '')
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:378:        return bool(self.next_page_token)
.venv\Lib\site-packages\firebase_admin\tenant_mgt.py:387:            return ListTenantsPage(self._download, self.next_page_token, self._max_results)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:23:from firebase_admin import _token_gen
.venv\Lib\site-packages\firebase_admin\_auth_client.py:64:        self._token_generator = _token_gen.TokenGenerator(
.venv\Lib\site-packages\firebase_admin\_auth_client.py:66:        self._token_verifier = _token_gen.TokenVerifier(app)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:77:    def create_custom_token(self, uid, developer_claims=None):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:78:        """Builds and signs a Firebase custom auth token.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:81:            uid: ID of the user for whom the token is created.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:82:            developer_claims: A dictionary of claims to be included in the token
.venv\Lib\site-packages\firebase_admin\_auth_client.py:86:            bytes: A token minted from the input parameters.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:90:            TokenSignError: If an error occurs while signing the token using the remote IAM service.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:92:        return self._token_generator.create_custom_token(
.venv\Lib\site-packages\firebase_admin\_auth_client.py:95:    def verify_id_token(self, id_token, check_revoked=False, clock_skew_seconds=0):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:98:        Accepts a signed token string, verifies that it is current, was issued
.venv\Lib\site-packages\firebase_admin\_auth_client.py:102:            id_token: A string of the encoded JWT.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:103:            check_revoked: Boolean, If true, checks whether the token has been revoked or
.venv\Lib\site-packages\firebase_admin\_auth_client.py:105:            clock_skew_seconds: The number of seconds to tolerate when checking the token.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:112:            ValueError: If ``id_token`` is a not a string or is empty.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:113:            InvalidIdTokenError: If ``id_token`` is not a valid Firebase ID token.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:114:            ExpiredIdTokenError: If the specified ID token has expired.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:115:            RevokedIdTokenError: If ``check_revoked`` is ``True`` and the ID token has been
.venv\Lib\site-packages\firebase_admin\_auth_client.py:117:            TenantIdMismatchError: If ``id_token`` belongs to a tenant that is different than
.venv\Lib\site-packages\firebase_admin\_auth_client.py:120:                required to verify the ID token.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:130:        verified_claims = self._token_verifier.verify_id_token(id_token, clock_skew_seconds)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:132:            token_tenant_id = verified_claims.get('firebase', {}).get('tenant')
.venv\Lib\site-packages\firebase_admin\_auth_client.py:133:            if self.tenant_id != token_tenant_id:
.venv\Lib\site-packages\firebase_admin\_auth_client.py:135:                    f'Invalid tenant ID: {token_tenant_id}')
.venv\Lib\site-packages\firebase_admin\_auth_client.py:139:                verified_claims, _token_gen.RevokedIdTokenError, 'ID token')
.venv\Lib\site-packages\firebase_admin\_auth_client.py:142:    def revoke_refresh_tokens(self, uid):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:143:        """Revokes all refresh tokens for an existing user.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:145:        This method updates the user's ``tokens_valid_after_timestamp`` to the current UTC
.venv\Lib\site-packages\firebase_admin\_auth_client.py:149:        While this revokes all sessions for a specified user and disables any new ID tokens for
.venv\Lib\site-packages\firebase_admin\_auth_client.py:150:        existing sessions from getting minted, existing ID tokens may remain active until their
.venv\Lib\site-packages\firebase_admin\_auth_client.py:151:        natural expiration (one hour). To verify that ID tokens are revoked, use
.venv\Lib\site-packages\firebase_admin\_auth_client.py:152:        ``verify_id_token(idToken, check_revoked=True)``.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:159:            FirebaseError: If an error occurs while revoking the refresh token.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:197:    def get_user_by_phone_number(self, phone_number):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:201:            phone_number: A phone number string.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:211:        response = self._user_manager.get_user(phone_number=phone_number)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:245:                return identifier.phone_number == user_record.phone_number
.venv\Lib\site-packages\firebase_admin\_auth_client.py:264:    def list_users(self, page_token=None, max_results=_user_mgt.MAX_LIST_USERS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:267:        The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\_auth_client.py:273:            page_token: A non-empty page token string, which indicates the starting point of the
.venv\Lib\site-packages\firebase_admin\_auth_client.py:283:            ValueError: If max_results or page_token are invalid.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:286:        def download(page_token, max_results):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:287:            return self._user_manager.list_users(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:288:        return _user_mgt.ListUsersPage(download, page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:302:            phone_number: The user's primary phone number (optional).
.venv\Lib\site-packages\firebase_admin\_auth_client.py:330:            phone_number: The user's primary phone number (optional). Can be removed by explicitly
.venv\Lib\site-packages\firebase_admin\_auth_client.py:340:                is set by ``revoke_refresh_tokens`` and it is discouraged to set this field
.venv\Lib\site-packages\firebase_admin\_auth_client.py:359:        These claims propagate to all the devices where the user is already signed in (after token
.venv\Lib\site-packages\firebase_admin\_auth_client.py:360:        expiration or when token refresh is forced), and next time the user signs in. The claims
.venv\Lib\site-packages\firebase_admin\_auth_client.py:361:        can be accessed via the user's ID token JWT. If a reserved OIDC claim is specified (sub,
.venv\Lib\site-packages\firebase_admin\_auth_client.py:521:            client_secret=None, id_token_response_type=None, code_response_type=None):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:540:                Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:541:            id_token_response_type: A boolean which sets whether to enable the ID token response
.venv\Lib\site-packages\firebase_admin\_auth_client.py:544:                Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:556:            id_token_response_type=id_token_response_type, code_response_type=code_response_type)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:560:            client_secret=None, id_token_response_type=None, code_response_type=None):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:576:                Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:577:            id_token_response_type: A boolean which sets whether to enable the ID token response
.venv\Lib\site-packages\firebase_admin\_auth_client.py:580:                Having both the code and ID token response flows is currently not supported.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:592:            id_token_response_type=id_token_response_type, code_response_type=code_response_type)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:608:            self, page_token=None, max_results=_auth_providers.MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:611:        The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\_auth_client.py:617:            page_token: A non-empty page token string, which indicates the starting point of the
.venv\Lib\site-packages\firebase_admin\_auth_client.py:627:            ValueError: If ``max_results`` or ``page_token`` are invalid.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:630:        return self._provider_manager.list_oidc_provider_configs(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:732:            self, page_token=None, max_results=_auth_providers.MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_client.py:735:        The ``page_token`` argument governs the starting point of the page. The ``max_results``
.venv\Lib\site-packages\firebase_admin\_auth_client.py:741:            page_token: A non-empty page token string, which indicates the starting point of the
.venv\Lib\site-packages\firebase_admin\_auth_client.py:751:            ValueError: If ``max_results`` or ``page_token`` are invalid.
.venv\Lib\site-packages\firebase_admin\_auth_client.py:754:        return self._provider_manager.list_saml_provider_configs(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_client.py:760:        if verified_claims.get('iat') * 1000 < user.tokens_valid_after_timestamp:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:67:    def id_token_response_type(self):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:68:        return self._data.get('responseType', {}).get('idToken', False)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:111:    def __init__(self, download, page_token, max_results):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:114:        self._current = download(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:122:    def next_page_token(self):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:123:        """Page token string for the next page (empty string indicates no more pages)."""
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:124:        return self._current.get('nextPageToken', '')
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:129:        return bool(self.next_page_token)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:139:            return self.__class__(self._download, self.next_page_token, self._max_results)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:195:            client_secret=None, id_token_response_type=None, code_response_type=None):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:208:        if id_token_response_type is False and code_response_type is False:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:210:        if id_token_response_type is not None:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:211:            response_type['idToken'] = _auth_utils.validate_boolean(
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:212:                id_token_response_type, 'id_token_response_type')
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:227:            enabled=None, client_secret=None, id_token_response_type=None,
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:245:        if id_token_response_type is False and code_response_type is False:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:247:        if id_token_response_type is not None:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:248:            response_type['idToken'] = _auth_utils.validate_boolean(
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:249:                id_token_response_type, 'id_token_response_type')
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:271:    def list_oidc_provider_configs(self, page_token=None, max_results=MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:273:            self._fetch_oidc_provider_configs, page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:275:    def _fetch_oidc_provider_configs(self, page_token=None, max_results=MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:276:        return self._fetch_provider_configs('/oauthIdpConfigs', page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:353:    def list_saml_provider_configs(self, page_token=None, max_results=MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:355:            self._fetch_saml_provider_configs, page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:357:    def _fetch_saml_provider_configs(self, page_token=None, max_results=MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:358:        return self._fetch_provider_configs('/inboundSamlConfigs', page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:360:    def _fetch_provider_configs(self, path, page_token=None, max_results=MAX_LIST_CONFIGS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:362:        if page_token is not None:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:363:            if not isinstance(page_token, str) or not page_token:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:364:                raise ValueError('Page token must be a non-empty string.')
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:373:        if page_token:
.venv\Lib\site-packages\firebase_admin\_auth_providers.py:374:            params += f'&pageToken={page_token}'
.venv\Lib\site-packages\firebase_admin\_auth_utils.py:338:class InvalidIdTokenError(exceptions.InvalidArgumentError):
.venv\Lib\site-packages\firebase_admin\_auth_utils.py:339:    """The provided ID token is not a valid Firebase ID token."""
.venv\Lib\site-packages\firebase_admin\_auth_utils.py:341:    default_message = 'The provided ID token is invalid'
.venv\Lib\site-packages\firebase_admin\_auth_utils.py:438:    'INVALID_ID_TOKEN': InvalidIdTokenError,
.venv\Lib\site-packages\firebase_admin\_auth_utils.py:439:    'PHONE_NUMBER_EXISTS': PhoneNumberAlreadyExistsError,
.venv\Lib\site-packages\firebase_admin\_http_client.py:181:        to contain access token and any other Google Auth headers."""
.venv\Lib\site-packages\firebase_admin\_http_client.py:203:            # Apply auth headers (which might include an implicit refresh if token is expired)
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:30:    contain exactly one of token, topic or condition fields.
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:40:        token: The registration token of the device to which the message should be sent (optional).
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:47:                 fcm_options=None, token=None, topic=None, condition=None):
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:54:        self.token = token
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:63:    """A message that can be sent to multiple tokens via Firebase Cloud Messaging.
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:66:        tokens: A list of registration tokens of targeted devices.
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:75:    def __init__(self, tokens, data=None, notification=None, android=None, webpush=None, apns=None,
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:77:        _Validators.check_string_list('MulticastMessage.tokens', tokens)
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:78:        if len(tokens) > 500:
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:79:            raise ValueError('MulticastMessage.tokens must not contain more than 500 tokens.')
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:80:        self.tokens = tokens
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:532:            'live_activity_token': _Validators.check_string(
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:533:                'APNSConfig.live_activity_token', apns.live_activity_token),
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:694:            'token': _Validators.check_string('Message.token', o.token, non_empty=True),
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:701:        target_count = sum(t in result for t in ['token', 'topic', 'condition'])
.venv\Lib\site-packages\firebase_admin\_messaging_encoder.py:703:            raise ValueError('Exactly one of token, topic or condition must be specified.')
.venv\Lib\site-packages\firebase_admin\_messaging_utils.py:46:        restricted_package_name: The package name of the application where the registration tokens
.venv\Lib\site-packages\firebase_admin\_messaging_utils.py:337:        live_activity_token: A live activity token string (optional).
.venv\Lib\site-packages\firebase_admin\_messaging_utils.py:343:    def __init__(self, headers=None, payload=None, fcm_options=None, live_activity_token=None):
.venv\Lib\site-packages\firebase_admin\_messaging_utils.py:347:        self.live_activity_token = live_activity_token
.venv\Lib\site-packages\firebase_admin\_messaging_utils.py:493:    """The authenticated sender ID is different from the sender ID for the registration token."""
.venv\Lib\site-packages\firebase_admin\_messaging_utils.py:502:    This usually means that the token used is no longer valid and a new one must be used."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:15:"""Firebase token minting and validation sub module."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:27:import google.oauth2.id_token
.venv\Lib\site-packages\firebase_admin\_token_gen.py:35:# ID token constants
.venv\Lib\site-packages\firebase_admin\_token_gen.py:36:ID_TOKEN_ISSUER_PREFIX = 'https://securetoken.google.com/'
.venv\Lib\site-packages\firebase_admin\_token_gen.py:37:ID_TOKEN_CERT_URI = ('https://www.googleapis.com/robot/v1/metadata/x509/'
.venv\Lib\site-packages\firebase_admin\_token_gen.py:38:                     'securetoken@system.gserviceaccount.com')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:46:# Custom token constants
.venv\Lib\site-packages\firebase_admin\_token_gen.py:47:MAX_TOKEN_LIFETIME_SECONDS = int(datetime.timedelta(hours=1).total_seconds())
.venv\Lib\site-packages\firebase_admin\_token_gen.py:107:class TokenGenerator:
.venv\Lib\site-packages\firebase_admin\_token_gen.py:108:    """Generates custom tokens and session cookies."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:156:                url = 'https://firebase.google.com/docs/auth/admin/create-custom-tokens'
.venv\Lib\site-packages\firebase_admin\_token_gen.py:161:                    'details on creating custom tokens.') from error
.venv\Lib\site-packages\firebase_admin\_token_gen.py:164:    def create_custom_token(self, uid, developer_claims=None, tenant_id=None):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:165:        """Builds and signs a Firebase custom auth token."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:193:            'exp': now + MAX_TOKEN_LIFETIME_SECONDS,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:205:            msg = f'Failed to sign custom token. {error}'
.venv\Lib\site-packages\firebase_admin\_token_gen.py:206:            raise TokenSignError(msg, error) from error
.venv\Lib\site-packages\firebase_admin\_token_gen.py:209:    def create_session_cookie(self, id_token, expires_in):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:210:        """Creates a session cookie from the provided ID token."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:211:        id_token = id_token.decode('utf-8') if isinstance(id_token, bytes) else id_token
.venv\Lib\site-packages\firebase_admin\_token_gen.py:212:        if not isinstance(id_token, str) or not id_token:
.venv\Lib\site-packages\firebase_admin\_token_gen.py:214:                f'Illegal ID token provided: {id_token}. ID token must be a non-empty string.')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:231:            'idToken': id_token,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:269:class TokenVerifier:
.venv\Lib\site-packages\firebase_admin\_token_gen.py:270:    """Verifies ID tokens and session cookies."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:275:        self.id_token_verifier = _JWTVerifier(
.venv\Lib\site-packages\firebase_admin\_token_gen.py:276:            project_id=app.project_id, short_name='ID token',
.venv\Lib\site-packages\firebase_admin\_token_gen.py:277:            operation='verify_id_token()',
.venv\Lib\site-packages\firebase_admin\_token_gen.py:278:            doc_url='https://firebase.google.com/docs/auth/admin/verify-id-tokens',
.venv\Lib\site-packages\firebase_admin\_token_gen.py:279:            cert_url=ID_TOKEN_CERT_URI,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:280:            issuer=ID_TOKEN_ISSUER_PREFIX,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:281:            invalid_token_error=_auth_utils.InvalidIdTokenError,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:282:            expired_token_error=ExpiredIdTokenError)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:286:            doc_url='https://firebase.google.com/docs/auth/admin/verify-id-tokens',
.venv\Lib\site-packages\firebase_admin\_token_gen.py:289:            invalid_token_error=InvalidSessionCookieError,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:290:            expired_token_error=ExpiredSessionCookieError)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:292:    def verify_id_token(self, id_token, clock_skew_seconds=0):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:293:        return self.id_token_verifier.verify(id_token, self.request, clock_skew_seconds)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:300:    """Verifies Firebase JWTs (ID tokens or session cookies)."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:313:        self._invalid_token_error = kwargs.pop('invalid_token_error')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:314:        self._expired_token_error = kwargs.pop('expired_token_error')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:316:    def verify(self, token, request, clock_skew_seconds=0):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:318:        token = token.encode('utf-8') if isinstance(token, str) else token
.venv\Lib\site-packages\firebase_admin\_token_gen.py:319:        if not isinstance(token, bytes) or not token:
.venv\Lib\site-packages\firebase_admin\_token_gen.py:321:                f'Illegal {self.short_name} provided: {token}. {self.short_name} must be a '
.venv\Lib\site-packages\firebase_admin\_token_gen.py:336:        header, payload = self._decode_unverified(token)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:345:        verify_id_token_msg = (
.venv\Lib\site-packages\firebase_admin\_token_gen.py:354:                'token.')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:360:                    'custom token.')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:366:                f'"{header.get("alg")}". {verify_id_token_msg}')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:371:                f'{verify_id_token_msg}')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:376:                f'{verify_id_token_msg}')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:379:                f'Firebase {self.short_name} has no "sub" (subject) claim. {verify_id_token_msg}')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:383:                f'{verify_id_token_msg}')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:387:                f'characters. {verify_id_token_msg}')
.venv\Lib\site-packages\firebase_admin\_token_gen.py:390:            raise self._invalid_token_error(error_message)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:396:                verified_claims = google.oauth2.id_token.verify_token(
.venv\Lib\site-packages\firebase_admin\_token_gen.py:397:                    token,
.venv\Lib\site-packages\firebase_admin\_token_gen.py:407:            if 'Token expired' in str(error):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:408:                raise self._expired_token_error(str(error), cause=error)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:409:            raise self._invalid_token_error(str(error), cause=error)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:411:    def _decode_unverified(self, token):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:413:            header = jwt.decode_header(token)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:414:            payload = jwt.decode(token, verify=False)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:417:            raise self._invalid_token_error(str(error), cause=error)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:420:class TokenSignError(exceptions.UnknownError):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:421:    """Unexpected error while signing a Firebase custom token."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:428:    """Failed to fetch some public key certificates required to verify a token."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:434:class ExpiredIdTokenError(_auth_utils.InvalidIdTokenError):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:435:    """The provided ID token is expired."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:438:        _auth_utils.InvalidIdTokenError.__init__(self, message, cause)
.venv\Lib\site-packages\firebase_admin\_token_gen.py:441:class RevokedIdTokenError(_auth_utils.InvalidIdTokenError):
.venv\Lib\site-packages\firebase_admin\_token_gen.py:442:    """The provided ID token has been revoked."""
.venv\Lib\site-packages\firebase_admin\_token_gen.py:445:        _auth_utils.InvalidIdTokenError.__init__(self, message)
.venv\Lib\site-packages\firebase_admin\_user_identifier.py:67:    def __init__(self, phone_number):
.venv\Lib\site-packages\firebase_admin\_user_identifier.py:71:            phone_number: A phone number string.
.venv\Lib\site-packages\firebase_admin\_user_identifier.py:73:        self._phone_number = _auth_utils.validate_phone(phone_number, required=True)
.venv\Lib\site-packages\firebase_admin\_user_identifier.py:76:    def phone_number(self):
.venv\Lib\site-packages\firebase_admin\_user_identifier.py:77:        return self._phone_number
.venv\Lib\site-packages\firebase_admin\_user_import.py:113:        phone_number: User's phone number (optional).
.venv\Lib\site-packages\firebase_admin\_user_import.py:126:    def __init__(self, uid, email=None, email_verified=None, display_name=None, phone_number=None,
.venv\Lib\site-packages\firebase_admin\_user_import.py:132:        self.phone_number = phone_number
.venv\Lib\site-packages\firebase_admin\_user_import.py:167:    def phone_number(self):
.venv\Lib\site-packages\firebase_admin\_user_import.py:168:        return self._phone_number
.venv\Lib\site-packages\firebase_admin\_user_import.py:170:    @phone_number.setter
.venv\Lib\site-packages\firebase_admin\_user_import.py:171:    def phone_number(self, phone_number):
.venv\Lib\site-packages\firebase_admin\_user_import.py:172:        self._phone_number = _auth_utils.validate_phone(phone_number)
.venv\Lib\site-packages\firebase_admin\_user_import.py:242:            'phoneNumber': self.phone_number,
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:79:        """The time at which the user was last active (ID token refreshed).
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:110:    def phone_number(self):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:168:    def phone_number(self):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:213:    def tokens_valid_after_timestamp(self):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:214:        """Returns the time, in milliseconds since the epoch, before which tokens are invalid.
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:220:            All tokens issued before that time are considered revoked.
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:353:    def __init__(self, download, page_token, max_results):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:356:        self._current = download(page_token, max_results)
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:364:    def next_page_token(self):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:365:        """Page token string for the next page (empty string indicates no more pages)."""
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:366:        return self._current.get('nextPageToken', '')
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:371:        return bool(self.next_page_token)
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:380:            return ListUsersPage(self._download, self.next_page_token, self._max_results)
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:477:    def phone_number(self):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:616:        elif 'phone_number' in kwargs:
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:617:            key, key_type = kwargs.pop('phone_number'), 'phone number'
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:658:                payload['phoneNumber'].append(identifier.phone_number)
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:675:    def list_users(self, page_token=None, max_results=MAX_LIST_USERS_RESULTS):
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:677:        if page_token is not None:
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:678:            if not isinstance(page_token, str) or not page_token:
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:679:                raise ValueError('Page token must be a non-empty string.')
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:687:        if page_token:
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:688:            payload['nextPageToken'] = page_token
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:692:    def create_user(self, uid=None, display_name=None, email=None, phone_number=None,
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:699:            'phoneNumber': _auth_utils.validate_phone(phone_number),
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:712:    def update_user(self, uid, display_name=None, email=None, phone_number=None,
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:740:        if phone_number is not None:
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:741:            if phone_number is DELETE_ATTRIBUTE:
.venv\Lib\site-packages\firebase_admin\_user_mgt.py:744:                payload['phoneNumber'] = _auth_utils.validate_phone(phone_number)
.venv\Lib\site-packages\firebase_admin\_utils.py:345:        self.token = 'owner'
.venv\Lib\site-packages\flask\ctx.py:249:        self._cv_tokens: list[contextvars.Token[AppContext]] = []
.venv\Lib\site-packages\flask\ctx.py:253:        self._cv_tokens.append(_cv_app.set(self))
.venv\Lib\site-packages\flask\ctx.py:259:            if len(self._cv_tokens) == 1:
.venv\Lib\site-packages\flask\ctx.py:265:            _cv_app.reset(self._cv_tokens.pop())
.venv\Lib\site-packages\flask\ctx.py:333:        self._cv_tokens: list[
.venv\Lib\site-packages\flask\ctx.py:334:            tuple[contextvars.Token[RequestContext], AppContext | None]
.venv\Lib\site-packages\flask\ctx.py:378:        self._cv_tokens.append((_cv_request.set(self), app_ctx))
.venv\Lib\site-packages\flask\ctx.py:404:        clear_request = len(self._cv_tokens) == 1
.venv\Lib\site-packages\flask\ctx.py:417:            token, app_ctx = self._cv_tokens.pop()
.venv\Lib\site-packages\flask\ctx.py:418:            _cv_request.reset(token)
.venv\Lib\site-packages\google\api\error_reason_pb2.py:32:    b'\n\x1dgoogle/api/error_reason.proto\x12\ngoogle.api*\xba\x07\n\x0b\x45rrorReason\x12\x1c\n\x18\x45RROR_REASON_UNSPECIFIED\x10\x00\x12\x14\n\x10SERVICE_DISABLED\x10\x01\x12\x14\n\x10\x42ILLING_DISABLED\x10\x02\x12\x13\n\x0f\x41PI_KEY_INVALID\x10\x03\x12\x1b\n\x17\x41PI_KEY_SERVICE_BLOCKED\x10\x04\x12!\n\x1d\x41PI_KEY_HTTP_REFERRER_BLOCKED\x10\x07\x12\x1e\n\x1a\x41PI_KEY_IP_ADDRESS_BLOCKED\x10\x08\x12\x1f\n\x1b\x41PI_KEY_ANDROID_APP_BLOCKED\x10\t\x12\x1b\n\x17\x41PI_KEY_IOS_APP_BLOCKED\x10\r\x12\x17\n\x13RATE_LIMIT_EXCEEDED\x10\x05\x12\x1b\n\x17RESOURCE_QUOTA_EXCEEDED\x10\x06\x12 \n\x1cLOCATION_TAX_POLICY_VIOLATED\x10\n\x12\x17\n\x13USER_PROJECT_DENIED\x10\x0b\x12\x16\n\x12\x43ONSUMER_SUSPENDED\x10\x0c\x12\x14\n\x10\x43ONSUMER_INVALID\x10\x0e\x12\x1c\n\x18SECURITY_POLICY_VIOLATED\x10\x0f\x12\x18\n\x14\x41\x43\x43\x45SS_TOKEN_EXPIRED\x10\x10\x12#\n\x1f\x41\x43\x43\x45SS_TOKEN_SCOPE_INSUFFICIENT\x10\x11\x12\x19\n\x15\x41\x43\x43OUNT_STATE_INVALID\x10\x12\x12!\n\x1d\x41\x43\x43\x45SS_TOKEN_TYPE_UNSUPPORTED\x10\x13\x12\x17\n\x13\x43REDENTIALS_MISSING\x10\x14\x12\x1c\n\x18RESOURCE_PROJECT_INVALID\x10\x15\x12\x1a\n\x16SESSION_COOKIE_INVALID\x10\x17\x12\x19\n\x15USER_BLOCKED_BY_ADMIN\x10\x18\x12\'\n#RESOURCE_USAGE_RESTRICTION_VIOLATED\x10\x19\x12 \n\x1cSYSTEM_PARAMETER_UNSUPPORTED\x10\x1a\x12\x1d\n\x19ORG_RESTRICTION_VIOLATION\x10\x1b\x12"\n\x1eORG_RESTRICTION_HEADER_INVALID\x10\x1c\x12\x17\n\x13SERVICE_NOT_VISIBLE\x10\x1d\x12\x11\n\rGCP_SUSPENDED\x10\x1e\x12\x1c\n\x18LOCATION_POLICY_VIOLATED\x10\x1f\x12\x12\n\x0eMISSING_ORIGIN\x10!\x12\x1a\n\x16OVERLOADED_CREDENTIALS\x10"Bp\n\x0e\x63om.google.apiB\x10\x45rrorReasonProtoP\x01ZCgoogle.golang.org/genproto/googleapis/api/error_reason;error_reason\xa2\x02\x04GAPIb\x06proto3'
.venv\Lib\site-packages\google\api_core\client_options.py:84:        scopes (Optional[Sequence[str]]): OAuth access token override scopes.
.venv\Lib\site-packages\google\api_core\operations_v1\abstract_operations_client.py:145:        page_token: Optional[str] = None,
.venv\Lib\site-packages\google\api_core\operations_v1\abstract_operations_client.py:192:        if page_token is not None:
.venv\Lib\site-packages\google\api_core\operations_v1\abstract_operations_client.py:193:            request.page_token = page_token
.venv\Lib\site-packages\google\api_core\operations_v1\operations_async_client.py:234:            request_token_field="page_token",
.venv\Lib\site-packages\google\api_core\operations_v1\operations_async_client.py:235:            response_token_field="next_page_token",
.venv\Lib\site-packages\google\api_core\operations_v1\operations_client.py:248:            request_token_field="page_token",
.venv\Lib\site-packages\google\api_core\operations_v1\operations_client.py:249:            response_token_field="next_page_token",
.venv\Lib\site-packages\google\api_core\operations_v1\operations_rest_client_async.py:163:        page_token: Optional[str] = None,
.venv\Lib\site-packages\google\api_core\operations_v1\operations_rest_client_async.py:209:        if page_token is not None:
.venv\Lib\site-packages\google\api_core\operations_v1\operations_rest_client_async.py:210:            request.page_token = page_token
.venv\Lib\site-packages\google\api_core\operations_v1\pagers.py:60:        while self._response.next_page_token:
.venv\Lib\site-packages\google\api_core\operations_v1\pagers.py:61:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\api_core\operations_v1\pagers_async.py:60:        while self._response.next_page_token:
.venv\Lib\site-packages\google\api_core\operations_v1\pagers_async.py:61:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\api_core\operations_v1\transports\rest_asyncio.py:141:            # TODO(https://github.com/googleapis/python-api-core/issues/725): Set always_use_jwt_access token when supported.
.venv\Lib\site-packages\google\api_core\page_iterator.py:18:where the request takes a page token and the response is a list of results with
.venv\Lib\site-packages\google\api_core\page_iterator.py:19:a token for the next page. See `list pagination`_ in the Google API Style Guide
.venv\Lib\site-packages\google\api_core\page_iterator.py:57:    ...     print('Next page token: {}'.format(iterator.next_page_token))
.venv\Lib\site-packages\google\api_core\page_iterator.py:63:    Next page token: eav1OzQB0OM8rLdGXOEsyQWSG
.venv\Lib\site-packages\google\api_core\page_iterator.py:69:    Next page token: None
.venv\Lib\site-packages\google\api_core\page_iterator.py:154:        page_token (str): A token identifying a page in a result set to start
.venv\Lib\site-packages\google\api_core\page_iterator.py:163:        page_token=None,
.venv\Lib\site-packages\google\api_core\page_iterator.py:183:        self.next_page_token = page_token
.venv\Lib\site-packages\google\api_core\page_iterator.py:184:        """str: The token for the next page of results. If this is set before
.venv\Lib\site-packages\google\api_core\page_iterator.py:300:        page_token (str): A token identifying a page in a result set to start
.venv\Lib\site-packages\google\api_core\page_iterator.py:313:        next_token (str): The name of the field used in the response for page
.venv\Lib\site-packages\google\api_core\page_iterator.py:314:            tokens.
.venv\Lib\site-packages\google\api_core\page_iterator.py:320:    _PAGE_TOKEN = "pageToken"
.venv\Lib\site-packages\google\api_core\page_iterator.py:322:    _NEXT_TOKEN = "nextPageToken"
.venv\Lib\site-packages\google\api_core\page_iterator.py:323:    _RESERVED_PARAMS = frozenset([_PAGE_TOKEN])
.venv\Lib\site-packages\google\api_core\page_iterator.py:333:        page_token=None,
.venv\Lib\site-packages\google\api_core\page_iterator.py:338:        next_token=_NEXT_TOKEN,
.venv\Lib\site-packages\google\api_core\page_iterator.py:341:            client, item_to_value, page_token=page_token, max_results=max_results
.venv\Lib\site-packages\google\api_core\page_iterator.py:349:        self._next_token = next_token
.venv\Lib\site-packages\google\api_core\page_iterator.py:377:            self.next_page_token = response.get(self._next_token)
.venv\Lib\site-packages\google\api_core\page_iterator.py:395:        return self.next_page_token is not None
.venv\Lib\site-packages\google\api_core\page_iterator.py:404:        if self.next_page_token is not None:
.venv\Lib\site-packages\google\api_core\page_iterator.py:405:            result[self._PAGE_TOKEN] = self.next_page_token
.venv\Lib\site-packages\google\api_core\page_iterator.py:462:            page_token=page_iter.page_token,
.venv\Lib\site-packages\google\api_core\page_iterator.py:480:            self.next_page_token = self._gax_page_iter.page_token or None
.venv\Lib\site-packages\google\api_core\page_iterator.py:489:    .. note:: The class does not take a ``page_token`` argument because it can
.venv\Lib\site-packages\google\api_core\page_iterator.py:503:        request_token_field (str): The field in the request message used to
.venv\Lib\site-packages\google\api_core\page_iterator.py:504:            specify the page token.
.venv\Lib\site-packages\google\api_core\page_iterator.py:505:        response_token_field (str): The field in the response message that has
.venv\Lib\site-packages\google\api_core\page_iterator.py:506:            the token for the next page.
.venv\Lib\site-packages\google\api_core\page_iterator.py:512:    _DEFAULT_REQUEST_TOKEN_FIELD = "page_token"
.venv\Lib\site-packages\google\api_core\page_iterator.py:513:    _DEFAULT_RESPONSE_TOKEN_FIELD = "next_page_token"
.venv\Lib\site-packages\google\api_core\page_iterator.py:522:        request_token_field=_DEFAULT_REQUEST_TOKEN_FIELD,
.venv\Lib\site-packages\google\api_core\page_iterator.py:523:        response_token_field=_DEFAULT_RESPONSE_TOKEN_FIELD,
.venv\Lib\site-packages\google\api_core\page_iterator.py:532:        self._request_token_field = request_token_field
.venv\Lib\site-packages\google\api_core\page_iterator.py:533:        self._response_token_field = response_token_field
.venv\Lib\site-packages\google\api_core\page_iterator.py:545:        if self.next_page_token is not None:
.venv\Lib\site-packages\google\api_core\page_iterator.py:546:            setattr(self._request, self._request_token_field, self.next_page_token)
.venv\Lib\site-packages\google\api_core\page_iterator.py:550:        self.next_page_token = getattr(response, self._response_token_field)
.venv\Lib\site-packages\google\api_core\page_iterator.py:571:        return True if self.next_page_token else False
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:18:where the request takes a page token and the response is a list of results with
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:19:a token for the next page. See `list pagination`_ in the Google API Style Guide
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:55:    ...     print('Next page token: {}'.format(iterator.next_page_token))
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:61:    Next page token: eav1OzQB0OM8rLdGXOEsyQWSG
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:67:    Next page token: None
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:91:        page_token (str): A token identifying a page in a result set to start
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:100:        page_token=None,
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:120:        self.next_page_token = page_token
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:121:        """str: The token for the next page of results. If this is set before
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:205:    .. note:: The class does not take a ``page_token`` argument because it can
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:219:        request_token_field (str): The field in the request message used to
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:220:            specify the page token.
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:221:        response_token_field (str): The field in the response message that has
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:222:            the token for the next page.
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:228:    _DEFAULT_REQUEST_TOKEN_FIELD = "page_token"
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:229:    _DEFAULT_RESPONSE_TOKEN_FIELD = "next_page_token"
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:238:        request_token_field=_DEFAULT_REQUEST_TOKEN_FIELD,
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:239:        response_token_field=_DEFAULT_RESPONSE_TOKEN_FIELD,
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:246:        self._request_token_field = request_token_field
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:247:        self._response_token_field = response_token_field
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:259:        if self.next_page_token is not None:
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:260:            setattr(self._request, self._request_token_field, self.next_page_token)
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:264:        self.next_page_token = getattr(response, self._response_token_field)
.venv\Lib\site-packages\google\api_core\page_iterator_async.py:285:        return True if self.next_page_token else False
.venv\Lib\site-packages\google\auth\aio\credentials.py:27:    All credentials have a :attr:`token` that is used for authentication and
.venv\Lib\site-packages\google\auth\aio\credentials.py:28:    may also optionally set an :attr:`expiry` to indicate when the token will
.venv\Lib\site-packages\google\auth\aio\credentials.py:35:    Although the token and expiration will change as the credentials are
.venv\Lib\site-packages\google\auth\aio\credentials.py:46:    async def apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\aio\credentials.py:47:        """Apply the token to the authentication header.
.venv\Lib\site-packages\google\auth\aio\credentials.py:51:            token (Optional[str]): If specified, overrides the current access
.venv\Lib\site-packages\google\auth\aio\credentials.py:52:                token.
.venv\Lib\site-packages\google\auth\aio\credentials.py:54:        self._apply(headers, token=token)
.venv\Lib\site-packages\google\auth\aio\credentials.py:57:        """Refreshes the access token.
.venv\Lib\site-packages\google\auth\aio\credentials.py:73:        apply the token to the authentication header.
.venv\Lib\site-packages\google\auth\aio\credentials.py:87:    """Asynchronous Credentials representing an immutable access token.
.venv\Lib\site-packages\google\auth\aio\credentials.py:89:    The credentials are considered immutable except the tokens which can be
.venv\Lib\site-packages\google\auth\aio\credentials.py:92:        credentials = StaticCredentials(token="token123")
.venv\Lib\site-packages\google\auth\aio\credentials.py:95:    token is valid and not expired. StaticCredentials will never attempt to
.venv\Lib\site-packages\google\auth\aio\credentials.py:96:    refresh the token.
.venv\Lib\site-packages\google\auth\aio\credentials.py:99:    def __init__(self, token):
.venv\Lib\site-packages\google\auth\aio\credentials.py:102:            token (str): The access token.
.venv\Lib\site-packages\google\auth\aio\credentials.py:105:        self.token = token
.venv\Lib\site-packages\google\auth\aio\credentials.py:111:    # Note: before_request should never try to refresh access tokens.
.venv\Lib\site-packages\google\auth\aio\credentials.py:130:    async def apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\aio\credentials.py:133:        The optional ``token`` argument is not supported.
.venv\Lib\site-packages\google\auth\aio\credentials.py:136:            google.auth.exceptions.InvalidValue: If a token was specified.
.venv\Lib\site-packages\google\auth\aio\credentials.py:138:        if token is not None:
.venv\Lib\site-packages\google\auth\aio\credentials.py:139:            raise exceptions.InvalidValue("Anonymous credentials don't support tokens.")
.venv\Lib\site-packages\google\auth\api_key.py:31:    def __init__(self, token):
.venv\Lib\site-packages\google\auth\api_key.py:34:            token (str): API key string
.venv\Lib\site-packages\google\auth\api_key.py:39:        if not token:
.venv\Lib\site-packages\google\auth\api_key.py:40:            raise exceptions.InvalidValue("Token must be a non-empty API key string")
.venv\Lib\site-packages\google\auth\api_key.py:41:        self.token = token
.venv\Lib\site-packages\google\auth\api_key.py:55:    def apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\api_key.py:56:        """Apply the API key token to the x-goog-api-key header.
.venv\Lib\site-packages\google\auth\api_key.py:59:            token (Optional[str]): If specified, overrides the current access
.venv\Lib\site-packages\google\auth\api_key.py:60:                token.
.venv\Lib\site-packages\google\auth\api_key.py:62:        headers["x-goog-api-key"] = token or self.token
.venv\Lib\site-packages\google\auth\api_key.py:67:        apply the token to the x-goog-api-key header.
.venv\Lib\site-packages\google\auth\app_engine.py:87:    tokens.
.venv\Lib\site-packages\google\auth\app_engine.py:104:                :func:`google.appengine.api.app_identity.get_access_token`.
.venv\Lib\site-packages\google\auth\app_engine.py:130:        token, ttl = app_identity.get_access_token(scopes, self._service_account_id)
.venv\Lib\site-packages\google\auth\app_engine.py:133:        self.token, self.expiry = token, expiry
.venv\Lib\site-packages\google\auth\aws.py:34:`AWS STS GetCallerIdentity`_ API that can be exchanged for Google access tokens
.venv\Lib\site-packages\google\auth\aws.py:64:# The AWS authorization header name for the security session token if available.
.venv\Lib\site-packages\google\auth\aws.py:65:_AWS_SECURITY_TOKEN_HEADER = "x-amz-security-token"
.venv\Lib\site-packages\google\auth\aws.py:72:# IMDSV2 session token lifetime. This is set to a low value because the session token is used immediately.
.venv\Lib\site-packages\google\auth\aws.py:73:_IMDSV2_SESSION_TOKEN_TTL_SECONDS = "300"
.venv\Lib\site-packages\google\auth\aws.py:152:        # Add session token if available.
.venv\Lib\site-packages\google\auth\aws.py:153:        if aws_security_credentials.session_token is not None:
.venv\Lib\site-packages\google\auth\aws.py:154:            headers[_AWS_SECURITY_TOKEN_HEADER] = aws_security_credentials.session_token
.venv\Lib\site-packages\google\auth\aws.py:274:    # Add AWS session token if available.
.venv\Lib\site-packages\google\auth\aws.py:275:    if aws_security_credentials.session_token is not None:
.venv\Lib\site-packages\google\auth\aws.py:277:            _AWS_SECURITY_TOKEN_HEADER
.venv\Lib\site-packages\google\auth\aws.py:278:        ] = aws_security_credentials.session_token
.venv\Lib\site-packages\google\auth\aws.py:349:    """A class that models AWS security credentials with an optional session token.
.venv\Lib\site-packages\google\auth\aws.py:354:            session_token (Optional[str]): The optional AWS security credentials session token. This should be set when using temporary credentials.
.venv\Lib\site-packages\google\auth\aws.py:359:    session_token: Optional[str] = None
.venv\Lib\site-packages\google\auth\aws.py:364:    AWS security credentials to exchange for a Google Cloud access token. The AWS external account credential does
.venv\Lib\site-packages\google\auth\aws.py:376:                containing information about the requested audience and subject token type.
.venv\Lib\site-packages\google\auth\aws.py:395:                containing information about the requested audience and subject token type.
.venv\Lib\site-packages\google\auth\aws.py:417:        self._imdsv2_session_token_url = credential_source.get(
.venv\Lib\site-packages\google\auth\aws.py:418:            "imdsv2_session_token_url"
.venv\Lib\site-packages\google\auth\aws.py:431:        env_aws_session_token = os.environ.get(environment_vars.AWS_SESSION_TOKEN)
.venv\Lib\site-packages\google\auth\aws.py:434:                env_aws_access_key_id, env_aws_secret_access_key, env_aws_session_token
.venv\Lib\site-packages\google\auth\aws.py:437:        imdsv2_session_token = self._get_imdsv2_session_token(request)
.venv\Lib\site-packages\google\auth\aws.py:438:        role_name = self._get_metadata_role_name(request, imdsv2_session_token)
.venv\Lib\site-packages\google\auth\aws.py:442:            request, role_name, imdsv2_session_token
.venv\Lib\site-packages\google\auth\aws.py:448:            credentials.get("Token"),
.venv\Lib\site-packages\google\auth\aws.py:468:        imdsv2_session_token = self._get_imdsv2_session_token(request)
.venv\Lib\site-packages\google\auth\aws.py:469:        if imdsv2_session_token is not None:
.venv\Lib\site-packages\google\auth\aws.py:470:            headers = {"X-aws-ec2-metadata-token": imdsv2_session_token}
.venv\Lib\site-packages\google\auth\aws.py:490:    def _get_imdsv2_session_token(self, request):
.venv\Lib\site-packages\google\auth\aws.py:491:        if request is not None and self._imdsv2_session_token_url is not None:
.venv\Lib\site-packages\google\auth\aws.py:493:                "X-aws-ec2-metadata-token-ttl-seconds": _IMDSV2_SESSION_TOKEN_TTL_SECONDS
.venv\Lib\site-packages\google\auth\aws.py:496:            imdsv2_session_token_response = request(
.venv\Lib\site-packages\google\auth\aws.py:497:                url=self._imdsv2_session_token_url, method="PUT", headers=headers
.venv\Lib\site-packages\google\auth\aws.py:500:            if imdsv2_session_token_response.status != http_client.OK:
.venv\Lib\site-packages\google\auth\aws.py:502:                    "Unable to retrieve AWS Session Token: {}".format(
.venv\Lib\site-packages\google\auth\aws.py:503:                        imdsv2_session_token_response.data
.venv\Lib\site-packages\google\auth\aws.py:507:            return imdsv2_session_token_response.data
.venv\Lib\site-packages\google\auth\aws.py:512:        self, request, role_name, imdsv2_session_token
.venv\Lib\site-packages\google\auth\aws.py:523:            imdsv2_session_token (str): The AWS IMDSv2 session token to be added as a
.venv\Lib\site-packages\google\auth\aws.py:535:        if imdsv2_session_token is not None:
.venv\Lib\site-packages\google\auth\aws.py:536:            headers["X-aws-ec2-metadata-token"] = imdsv2_session_token
.venv\Lib\site-packages\google\auth\aws.py:560:    def _get_metadata_role_name(self, request, imdsv2_session_token):
.venv\Lib\site-packages\google\auth\aws.py:569:            imdsv2_session_token (str): The AWS IMDSv2 session token to be added as a
.venv\Lib\site-packages\google\auth\aws.py:585:        if imdsv2_session_token is not None:
.venv\Lib\site-packages\google\auth\aws.py:586:            headers = {"X-aws-ec2-metadata-token": imdsv2_session_token}
.venv\Lib\site-packages\google\auth\aws.py:610:    AWS STS GetCallerIdentity service for Google access tokens.
.venv\Lib\site-packages\google\auth\aws.py:616:        subject_token_type,
.venv\Lib\site-packages\google\auth\aws.py:617:        token_url=external_account._DEFAULT_TOKEN_URL,
.venv\Lib\site-packages\google\auth\aws.py:627:            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.
.venv\Lib\site-packages\google\auth\aws.py:630:                    urn:ietf:params:aws:token-type:aws4_request
.venv\Lib\site-packages\google\auth\aws.py:632:            token_url (Optional [str]): The STS endpoint URL. If not provided, will default to "https://sts.googleapis.com/v1/token".
.venv\Lib\site-packages\google\auth\aws.py:634:                to provide instructions on how to retrieve external credential to be exchanged for Google access tokens.
.venv\Lib\site-packages\google\auth\aws.py:644:                        imdsv2_session_token_url": "http://169.254.169.254/latest/api/token"
.venv\Lib\site-packages\google\auth\aws.py:649:                be exchanged for Google access tokens. Either an AWS security credentials supplier
.venv\Lib\site-packages\google\auth\aws.py:656:                access token retrieval logic.
.venv\Lib\site-packages\google\auth\aws.py:665:            subject_token_type=subject_token_type,
.venv\Lib\site-packages\google\auth\aws.py:666:            token_url=token_url,
.venv\Lib\site-packages\google\auth\aws.py:719:    def retrieve_subject_token(self, request):
.venv\Lib\site-packages\google\auth\aws.py:720:        """Retrieves the subject token using the credential_source object.
.venv\Lib\site-packages\google\auth\aws.py:721:        The subject token is a serialized `AWS GetCallerIdentity signed request`_.
.venv\Lib\site-packages\google\auth\aws.py:740:        signed request. This will be the subject-token to pass to GCP STS.
.venv\Lib\site-packages\google\auth\aws.py:743:            https://cloud.google.com/iam/docs/access-resources-aws#exchange-token
.venv\Lib\site-packages\google\auth\aws.py:749:            str: The retrieved subject token.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:47:    OAuth 2.0 access tokens associated with the instance's service account,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:126:    def _refresh_token(self, request):
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:127:        """Refresh the access token and scopes.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:141:            # Always fetch token with default service account email.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:142:            self.token, self.expiry = _metadata.get_service_account_token(
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:268:_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:269:_DEFAULT_TOKEN_URI = "https://www.googleapis.com/oauth2/v4/token"
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:272:class IDTokenCredentials(
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:275:    credentials.CredentialsWithTokenUri,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:277:    """Open ID Connect ID Token-based service account credentials.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:281:    ID token can be requested from `GCE metadata server identity endpoint`_, IAM
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:282:    token endpoint or other token endpoints you specify. If metadata server
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:294:        token_uri=None,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:306:                used when requesting the ID Token. The ID Token's ``aud`` claim
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:308:            token_uri (str): The OAuth 2.0 Token URI.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:312:                use to sign JWT tokens.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:319:                is False. If set to True, ``token_uri``, ``additional_claims``,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:328:                ``token_uri``, ``additional_claims``, ``service_account_email``,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:331:        super(IDTokenCredentials, self).__init__()
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:338:            if token_uri or additional_claims or service_account_email or signer:
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:340:                    "If use_metadata_identity_endpoint is set, token_uri, "
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:344:            self._token_uri = None
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:362:            self._token_uri = token_uri or _DEFAULT_TOKEN_URI
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:374:            used when requesting the ID Token.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:376:            google.auth.service_account.IDTokenCredentials: A new credentials
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:392:                token_uri=self._token_uri,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:416:                token_uri=self._token_uri,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:424:    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:425:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:431:                "If use_metadata_identity_endpoint is set, token_uri" " must not be set"
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:437:                token_uri=token_uri,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:448:        ID token.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:453:        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:461:            # The audience must be the auth token endpoint's URI
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:462:            "aud": self._token_uri,
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:463:            # The target audience specifies which service the ID token is
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:470:        token = jwt.encode(self._signer, payload)
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:472:        return token
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:475:        """Request ID token from metadata identity endpoint.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:482:            Tuple[str, datetime.datetime]: The ID token and the expiry of the ID token.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:487:            ValueError: If extracting expiry from the obtained ID token fails.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:493:                metrics.API_CLIENT_HEADER: metrics.token_request_id_token_mds()
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:495:            id_token = _metadata.get(
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:502:        _, payload, _, _ = jwt._unverified_decode(id_token)
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:503:        return id_token, datetime.datetime.utcfromtimestamp(payload["exp"])
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:506:        """Refreshes the ID token.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:515:            ValueError: If extracting expiry from the obtained ID token fails.
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:518:            self.token, self.expiry = self._call_metadata_identity_endpoint(request)
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:521:            access_token, expiry, _ = _client.id_token_jwt_grant(
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:522:                request, self._token_uri, assertion
.venv\Lib\site-packages\google\auth\compute_engine\credentials.py:524:            self.token = access_token
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:345:def get_service_account_token(request, service_account="default", scopes=None):
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:346:    """Get the OAuth 2.0 access token for a service account.
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:353:            an access token.
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:357:        Tuple[str, datetime]: The access token and its expiration.
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:371:        metrics.API_CLIENT_HEADER: metrics.token_request_access_token_mds()
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:374:    path = "instance/service-accounts/{0}/token".format(service_account)
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:375:    token_json = get(request, path, params=params, headers=metrics_header)
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:376:    token_expiry = _helpers.utcnow() + datetime.timedelta(
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:377:        seconds=token_json["expires_in"]
.venv\Lib\site-packages\google\auth\compute_engine\_metadata.py:379:    return token_json["access_token"], token_expiry
.venv\Lib\site-packages\google\auth\compute_engine\__init__.py:19:from google.auth.compute_engine.credentials import IDTokenCredentials
.venv\Lib\site-packages\google\auth\compute_engine\__init__.py:22:__all__ = ["Credentials", "IDTokenCredentials", "detect_gce_residency_linux"]
.venv\Lib\site-packages\google\auth\credentials.py:38:    All credentials have a :attr:`token` that is used for authentication and
.venv\Lib\site-packages\google\auth\credentials.py:39:    may also optionally set an :attr:`expiry` to indicate when the token will
.venv\Lib\site-packages\google\auth\credentials.py:46:    Although the token and expiration will change as the credentials are
.venv\Lib\site-packages\google\auth\credentials.py:58:        """Optional[datetime]: When the token expires and is no longer valid.
.venv\Lib\site-packages\google\auth\credentials.py:59:        If this is None, the token is assumed to never expire."""
.venv\Lib\site-packages\google\auth\credentials.py:82:          Prefer checking :attr:`token_state` instead.
.venv\Lib\site-packages\google\auth\credentials.py:95:        This is True if the credentials have a :attr:`token` and the token
.venv\Lib\site-packages\google\auth\credentials.py:99:          Prefer checking :attr:`token_state` instead.
.venv\Lib\site-packages\google\auth\credentials.py:101:        return self.token is not None and not self.expired
.venv\Lib\site-packages\google\auth\credentials.py:104:    def token_state(self):
.venv\Lib\site-packages\google\auth\credentials.py:106:        See `:obj:`TokenState`
.venv\Lib\site-packages\google\auth\credentials.py:108:        if self.token is None:
.venv\Lib\site-packages\google\auth\credentials.py:109:            return TokenState.INVALID
.venv\Lib\site-packages\google\auth\credentials.py:113:            return TokenState.FRESH
.venv\Lib\site-packages\google\auth\credentials.py:117:            return TokenState.INVALID
.venv\Lib\site-packages\google\auth\credentials.py:121:            return TokenState.STALE
.venv\Lib\site-packages\google\auth\credentials.py:123:        return TokenState.FRESH
.venv\Lib\site-packages\google\auth\credentials.py:148:        """Refreshes the access token.
.venv\Lib\site-packages\google\auth\credentials.py:163:        """The x-goog-api-client header for token usage metric.
.venv\Lib\site-packages\google\auth\credentials.py:167:        signed jwt access token is used in the API service request
.venv\Lib\site-packages\google\auth\credentials.py:169:        this method to provide the header value, if the token usage metric is
.venv\Lib\site-packages\google\auth\credentials.py:177:    def apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\credentials.py:178:        """Apply the token to the authentication header.
.venv\Lib\site-packages\google\auth\credentials.py:182:            token (Optional[str]): If specified, overrides the current access
.venv\Lib\site-packages\google\auth\credentials.py:183:                token.
.venv\Lib\site-packages\google\auth\credentials.py:185:        self._apply(headers, token)
.venv\Lib\site-packages\google\auth\credentials.py:196:        if self.token_state == TokenState.STALE:
.venv\Lib\site-packages\google\auth\credentials.py:201:        if self.token_state == TokenState.INVALID or use_blocking_refresh_fallback:
.venv\Lib\site-packages\google\auth\credentials.py:212:        apply the token to the authentication header.
.venv\Lib\site-packages\google\auth\credentials.py:259:class CredentialsWithTokenUri(Credentials):
.venv\Lib\site-packages\google\auth\credentials.py:260:    """Abstract base for credentials supporting ``with_token_uri`` factory"""
.venv\Lib\site-packages\google\auth\credentials.py:262:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\auth\credentials.py:263:        """Returns a copy of these credentials with a modified token uri.
.venv\Lib\site-packages\google\auth\credentials.py:266:            token_uri (str): The uri to use for fetching/exchanging tokens
.venv\Lib\site-packages\google\auth\credentials.py:271:        raise NotImplementedError("This credential does not use token uri.")
.venv\Lib\site-packages\google\auth\credentials.py:295:    def _refresh_token(self, request):
.venv\Lib\site-packages\google\auth\credentials.py:296:        """Refreshes the access token.
.venv\Lib\site-packages\google\auth\credentials.py:306:        raise NotImplementedError("_refresh_token must be implemented")
.venv\Lib\site-packages\google\auth\credentials.py:354:    def apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\credentials.py:355:        """Apply the token to the authentication header."""
.venv\Lib\site-packages\google\auth\credentials.py:356:        super().apply(headers, token)
.venv\Lib\site-packages\google\auth\credentials.py:360:        """Refreshes the access token and the trust boundary.
.venv\Lib\site-packages\google\auth\credentials.py:362:        This method calls the subclass's token refresh logic and then
.venv\Lib\site-packages\google\auth\credentials.py:365:        self._refresh_token(request)
.venv\Lib\site-packages\google\auth\credentials.py:468:    def apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\credentials.py:471:        The optional ``token`` argument is not supported.
.venv\Lib\site-packages\google\auth\credentials.py:474:            google.auth.exceptions.InvalidValue: If a token was specified.
.venv\Lib\site-packages\google\auth\credentials.py:476:        if token is not None:
.venv\Lib\site-packages\google\auth\credentials.py:477:            raise exceptions.InvalidValue("Anonymous credentials don't support tokens.")
.venv\Lib\site-packages\google\auth\credentials.py:491:    Some credentials require scopes in order to obtain a token. You can check
.venv\Lib\site-packages\google\auth\credentials.py:529:        """True if these credentials require scopes to obtain an access token."""
.venv\Lib\site-packages\google\auth\credentials.py:558:    Some credentials require scopes in order to obtain a token. You can check
.venv\Lib\site-packages\google\auth\credentials.py:655:class TokenState(Enum):
.venv\Lib\site-packages\google\auth\credentials.py:657:    Tracks the state of a token.
.venv\Lib\site-packages\google\auth\credentials.py:658:    FRESH: The token is valid. It is not expired or close to expired, or the token has no expiry.
.venv\Lib\site-packages\google\auth\credentials.py:659:    STALE: The token is close to expired, and should be refreshed. The token can be used normally.
.venv\Lib\site-packages\google\auth\credentials.py:660:    INVALID: The token is expired or invalid. The token cannot be used for a normal operation.
.venv\Lib\site-packages\google\auth\downscoped.py:28:The common pattern of usage is to have a token broker with elevated access
.venv\Lib\site-packages\google\auth\downscoped.py:30:pass the downscoped short-lived access tokens to a token consumer via some
.venv\Lib\site-packages\google\auth\downscoped.py:34:For example, a token broker can be set up on a server in a private network.
.venv\Lib\site-packages\google\auth\downscoped.py:35:Various workloads (token consumers) in the same network will send authenticated
.venv\Lib\site-packages\google\auth\downscoped.py:36:requests to that broker for downscoped tokens to access or modify specific google
.venv\Lib\site-packages\google\auth\downscoped.py:40:generate short lived downscoped access tokens that can be passed to the token
.venv\Lib\site-packages\google\auth\downscoped.py:41:consumer. These downscoped access tokens can be injected by the consumer into
.venv\Lib\site-packages\google\auth\downscoped.py:61:# The token exchange grant_type used for exchanging credentials.
.venv\Lib\site-packages\google\auth\downscoped.py:62:_STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange"
.venv\Lib\site-packages\google\auth\downscoped.py:63:# The token exchange requested_token_type. This is always an access_token.
.venv\Lib\site-packages\google\auth\downscoped.py:64:_STS_REQUESTED_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"
.venv\Lib\site-packages\google\auth\downscoped.py:65:# The STS token URL used to exchanged a short lived access token for a downscoped one.
.venv\Lib\site-packages\google\auth\downscoped.py:66:_STS_TOKEN_URL_PATTERN = "https://sts.{}/v1/token"
.venv\Lib\site-packages\google\auth\downscoped.py:67:# The subject token type to use when exchanging a short lived access token for a
.venv\Lib\site-packages\google\auth\downscoped.py:68:# downscoped token.
.venv\Lib\site-packages\google\auth\downscoped.py:69:_STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"
.venv\Lib\site-packages\google\auth\downscoped.py:157:        This uses the format expected by the Security Token Service API as documented in
.venv\Lib\site-packages\google\auth\downscoped.py:189:                the downscoped token will have on the available permissions for the
.venv\Lib\site-packages\google\auth\downscoped.py:294:        This uses the format expected by the Security Token Service API as documented in
.venv\Lib\site-packages\google\auth\downscoped.py:410:        This uses the format expected by the Security Token Service API as documented in
.venv\Lib\site-packages\google\auth\downscoped.py:432:    The common pattern of usage is to have a token broker with elevated access
.venv\Lib\site-packages\google\auth\downscoped.py:434:    pass the downscoped short-lived access tokens to a token consumer via some
.venv\Lib\site-packages\google\auth\downscoped.py:466:                return an error on token refresh.
.venv\Lib\site-packages\google\auth\downscoped.py:467:            google.auth.exceptions.OAuthError: If the STS token exchange
.venv\Lib\site-packages\google\auth\downscoped.py:468:                endpoint returned an error during downscoped token generation.
.venv\Lib\site-packages\google\auth\downscoped.py:477:            _STS_TOKEN_URL_PATTERN.format(self.universe_domain)
.venv\Lib\site-packages\google\auth\downscoped.py:482:        # Generate an access token from the source credentials.
.venv\Lib\site-packages\google\auth\downscoped.py:485:        # Exchange the access token for a downscoped access token.
.venv\Lib\site-packages\google\auth\downscoped.py:486:        response_data = self._sts_client.exchange_token(
.venv\Lib\site-packages\google\auth\downscoped.py:489:            subject_token=self._source_credentials.token,
.venv\Lib\site-packages\google\auth\downscoped.py:490:            subject_token_type=_STS_SUBJECT_TOKEN_TYPE,
.venv\Lib\site-packages\google\auth\downscoped.py:491:            requested_token_type=_STS_REQUESTED_TOKEN_TYPE,
.venv\Lib\site-packages\google\auth\downscoped.py:494:        self.token = response_data.get("access_token")
.venv\Lib\site-packages\google\auth\downscoped.py:496:        # field for some flows. The generated downscoped token should always have
.venv\Lib\site-packages\google\auth\environment_vars.py:78:# for a Google access tokens via the GCP STS endpoint.
.venv\Lib\site-packages\google\auth\environment_vars.py:82:AWS_SESSION_TOKEN = "AWS_SESSION_TOKEN"
.venv\Lib\site-packages\google\auth\exceptions.py:36:    """Used to indicate that an refreshing the credentials' access token
.venv\Lib\site-packages\google\auth\exceptions.py:40:class UserAccessTokenError(GoogleAuthError):
.venv\Lib\site-packages\google\auth\exceptions.py:41:    """Used to indicate ``gcloud auth print-access-token`` command failed."""
.venv\Lib\site-packages\google\auth\external_account.py:18:credentials for Google access tokens. This facilitates accessing Google Cloud
.venv\Lib\site-packages\google\auth\external_account.py:24:Specifically, this is intended to use access tokens acquired using the GCP STS
.venv\Lib\site-packages\google\auth\external_account.py:25:token exchange endpoint following the `OAuth 2.0 Token Exchange`_ spec.
.venv\Lib\site-packages\google\auth\external_account.py:27:.. _OAuth 2.0 Token Exchange: https://tools.ietf.org/html/rfc8693
.venv\Lib\site-packages\google\auth\external_account.py:49:# The token exchange grant_type used for exchanging credentials.
.venv\Lib\site-packages\google\auth\external_account.py:50:_STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange"
.venv\Lib\site-packages\google\auth\external_account.py:51:# The token exchange requested_token_type. This is always an access_token.
.venv\Lib\site-packages\google\auth\external_account.py:52:_STS_REQUESTED_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"
.venv\Lib\site-packages\google\auth\external_account.py:55:# Default Google sts token url.
.venv\Lib\site-packages\google\auth\external_account.py:56:_DEFAULT_TOKEN_URL = "https://sts.{universe_domain}/v1/token"
.venv\Lib\site-packages\google\auth\external_account.py:62:    to AWS security credential and subject token suppliers.
.venv\Lib\site-packages\google\auth\external_account.py:65:        subject_token_type (str): The requested subject token type based on the Oauth2.0 token exchange spec.
.venv\Lib\site-packages\google\auth\external_account.py:68:                urn:ietf:params:oauth:token-type:jwt
.venv\Lib\site-packages\google\auth\external_account.py:69:                urn:ietf:params:oauth:token-type:id-token
.venv\Lib\site-packages\google\auth\external_account.py:70:                urn:ietf:params:oauth:token-type:saml2
.venv\Lib\site-packages\google\auth\external_account.py:71:                urn:ietf:params:aws:token-type:aws4_request
.venv\Lib\site-packages\google\auth\external_account.py:73:        audience (str): The requested audience for the subject token.
.venv\Lib\site-packages\google\auth\external_account.py:76:    subject_token_type: str
.venv\Lib\site-packages\google\auth\external_account.py:83:    credentials.CredentialsWithTokenUri,
.venv\Lib\site-packages\google\auth\external_account.py:89:    credentials for Google access token and authorizing requests to Google APIs.
.venv\Lib\site-packages\google\auth\external_account.py:91:    credentials for Google access tokens.
.venv\Lib\site-packages\google\auth\external_account.py:104:        subject_token_type,
.venv\Lib\site-packages\google\auth\external_account.py:105:        token_url,
.venv\Lib\site-packages\google\auth\external_account.py:111:        token_info_url=None,
.venv\Lib\site-packages\google\auth\external_account.py:123:            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.
.venv\Lib\site-packages\google\auth\external_account.py:126:                    urn:ietf:params:oauth:token-type:jwt
.venv\Lib\site-packages\google\auth\external_account.py:127:                    urn:ietf:params:oauth:token-type:id-token
.venv\Lib\site-packages\google\auth\external_account.py:128:                    urn:ietf:params:oauth:token-type:saml2
.venv\Lib\site-packages\google\auth\external_account.py:129:                    urn:ietf:params:aws:token-type:aws4_request
.venv\Lib\site-packages\google\auth\external_account.py:131:            token_url (str): The STS endpoint URL.
.venv\Lib\site-packages\google\auth\external_account.py:134:                impersonation generateAccessToken URL.
.venv\Lib\site-packages\google\auth\external_account.py:137:            token_info_url (str): The optional STS endpoint URL for token introspection.
.venv\Lib\site-packages\google\auth\external_account.py:152:            google.auth.exceptions.RefreshError: If the generateAccessToken
.venv\Lib\site-packages\google\auth\external_account.py:157:        self._subject_token_type = subject_token_type
.venv\Lib\site-packages\google\auth\external_account.py:159:        self._token_url = token_url
.venv\Lib\site-packages\google\auth\external_account.py:160:        if self._token_url == _DEFAULT_TOKEN_URL:
.venv\Lib\site-packages\google\auth\external_account.py:161:            self._token_url = self._token_url.replace(
.venv\Lib\site-packages\google\auth\external_account.py:164:        self._token_info_url = token_info_url
.venv\Lib\site-packages\google\auth\external_account.py:187:        self._sts_client = sts.Client(self._token_url, self._client_auth)
.venv\Lib\site-packages\google\auth\external_account.py:194:            self._subject_token_type, self._audience
.venv\Lib\site-packages\google\auth\external_account.py:229:            "subject_token_type": self._subject_token_type,
.venv\Lib\site-packages\google\auth\external_account.py:230:            "token_url": self._token_url,
.venv\Lib\site-packages\google\auth\external_account.py:231:            "token_info_url": self._token_info_url,
.venv\Lib\site-packages\google\auth\external_account.py:260:            # https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken
.venv\Lib\site-packages\google\auth\external_account.py:263:            end_index = url.find(":generateAccessToken")
.venv\Lib\site-packages\google\auth\external_account.py:327:    def token_info_url(self):
.venv\Lib\site-packages\google\auth\external_account.py:328:        """Optional[str]: The STS token introspection endpoint."""
.venv\Lib\site-packages\google\auth\external_account.py:330:        return self._token_info_url
.venv\Lib\site-packages\google\auth\external_account.py:354:    def retrieve_subject_token(self, request):
.venv\Lib\site-packages\google\auth\external_account.py:355:        """Retrieves the subject token using the credential_source object.
.venv\Lib\site-packages\google\auth\external_account.py:361:            str: The retrieved subject token.
.venv\Lib\site-packages\google\auth\external_account.py:365:        raise NotImplementedError("retrieve_subject_token must be implemented")
.venv\Lib\site-packages\google\auth\external_account.py:393:        # Scopes are required in order to retrieve a valid access token.
.venv\Lib\site-packages\google\auth\external_account.py:430:            self.token = self._impersonated_credentials.token
.venv\Lib\site-packages\google\auth\external_account.py:444:            response_data = self._sts_client.exchange_token(
.venv\Lib\site-packages\google\auth\external_account.py:447:                subject_token=self.retrieve_subject_token(request),
.venv\Lib\site-packages\google\auth\external_account.py:448:                subject_token_type=self._subject_token_type,
.venv\Lib\site-packages\google\auth\external_account.py:451:                requested_token_type=_STS_REQUESTED_TOKEN_TYPE,
.venv\Lib\site-packages\google\auth\external_account.py:455:            self.token = response_data.get("access_token")
.venv\Lib\site-packages\google\auth\external_account.py:480:    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
.venv\Lib\site-packages\google\auth\external_account.py:481:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\auth\external_account.py:483:        cred._token_url = token_uri
.venv\Lib\site-packages\google\auth\external_account.py:501:        For more details, see `projects.serviceAccounts.generateAccessToken`_.
.venv\Lib\site-packages\google\auth\external_account.py:503:        .. _projects.serviceAccounts.generateAccessToken: https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateAccessToken
.venv\Lib\site-packages\google\auth\external_account.py:510:            google.auth.exceptions.RefreshError: If the generateAccessToken
.venv\Lib\site-packages\google\auth\external_account.py:538:                "token_lifetime_seconds"
.venv\Lib\site-packages\google\auth\external_account.py:548:        if self._service_account_impersonation_options.get("token_lifetime_seconds"):
.venv\Lib\site-packages\google\auth\external_account.py:608:            subject_token_type=info.get("subject_token_type"),
.venv\Lib\site-packages\google\auth\external_account.py:609:            token_url=info.get("token_url"),
.venv\Lib\site-packages\google\auth\external_account.py:610:            token_info_url=info.get("token_info_url"),
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:16:This module provides credentials based on OAuth 2.0 access and refresh tokens.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:22:Obtaining the initial access and refresh token can be done through the Google Cloud CLI.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:28:  "refresh_token": "refreshToken",
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:29:  "token_url": "https://sts.googleapis.com/v1/oauth/token",
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:30:  "token_info_url": "https://sts.googleapis.com/v1/instrospect",
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:52:    credentials.CredentialsWithTokenUri,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:56:    This is used to instantiate Credentials for exchanging refresh tokens from
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:57:    authorized users for Google access token and authorizing requests to Google
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:61:    quota project, use `with_quota_project` and if you want to modify the token
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:62:    uri, use `with_token_uri`.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:74:        token=None,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:76:        refresh_token=None,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:80:        token_url=None,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:81:        token_info_url=None,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:90:        token (str): The OAuth 2.0 access token. Can be None if refresh information
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:93:            token.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:94:        refresh_token (str): The optional OAuth 2.0 refresh token. If specified,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:99:            None if the token can not be refreshed.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:101:            left as None if the token can not be refreshed.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:102:        token_url (str): The optional STS token exchange endpoint for refresh. Must be specified for
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:103:            refresh, can be left as None if the token can not be refreshed.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:104:        token_info_url (str): The optional STS endpoint URL for token introspection.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:105:        revoke_url (str): The optional STS endpoint URL for revoking tokens.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:118:        self.token = token
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:121:        self._refresh_token = refresh_token
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:122:        self._token_url = token_url
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:123:        self._token_info_url = token_info_url
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:134:                "Token should be created with fields to make it valid (`token` and "
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:135:                "`expiry`), or fields to allow it to refresh (`refresh_token`, "
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:136:                "`token_url`, `client_id`, `client_secret`)."
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:144:        self._sts_client = sts.Client(self._token_url, self._client_auth)
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:167:            "refresh_token": self._refresh_token,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:168:            "token_url": self._token_url,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:169:            "token_info_url": self._token_info_url,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:172:            "token": self.token,
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:188:        the initial token is requested and can not be changed."""
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:208:    def refresh_token(self):
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:209:        """Optional[str]: The OAuth 2.0 refresh token."""
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:210:        return self._refresh_token
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:213:    def token_url(self):
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:214:        """Optional[str]: The STS token exchange endpoint for refresh."""
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:215:        return self._token_url
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:218:    def token_info_url(self):
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:219:        """Optional[str]: The STS endpoint for token info."""
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:220:        return self._token_info_url
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:224:        """Optional[str]: The STS endpoint for token revocation."""
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:235:            (self._refresh_token, self._token_url, self._client_id, self._client_secret)
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:270:        """Refreshes the access token.
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:283:                "refresh the access token. You must specify refresh_token, "
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:284:                "token_url, client_id, and client_secret."
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:290:        self.token = response_data.get("access_token")
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:295:        if "refresh_token" in response_data:
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:296:            self._refresh_token = response_data["refresh_token"]
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:299:        return self._sts_client.refresh_token(request, self._refresh_token)
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:322:    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:323:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:325:        cred._token_url = token_uri
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:365:            refresh_token=info.get("refresh_token"),
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:366:            token_url=info.get("token_url"),
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:367:            token_info_url=info.get("token_info_url"),
.venv\Lib\site-packages\google\auth\external_account_authorized_user.py:370:            token=info.get("token"),
.venv\Lib\site-packages\google\auth\iam.py:43:    + "/serviceAccounts/{}:generateAccessToken"
.venv\Lib\site-packages\google\auth\iam.py:56:_IAM_IDTOKEN_ENDPOINT = (
.venv\Lib\site-packages\google\auth\iam.py:58:    + "projects/-/serviceAccounts/{}:generateIdToken"
.venv\Lib\site-packages\google\auth\identity_pool.py:19:tokens) retrieved from local file locations or local servers. This includes
.venv\Lib\site-packages\google\auth\identity_pool.py:31:This module also provides a definition for an abstract subject token supplier.
.venv\Lib\site-packages\google\auth\identity_pool.py:32:This supplier can be implemented to return a valid OIDC or SAML2.0 subject token
.venv\Lib\site-packages\google\auth\identity_pool.py:55:class SubjectTokenSupplier(metaclass=abc.ABCMeta):
.venv\Lib\site-packages\google\auth\identity_pool.py:56:    """Base class for subject token suppliers. This can be implemented with custom logic to retrieve
.venv\Lib\site-packages\google\auth\identity_pool.py:57:    a subject token to exchange for a Google Cloud access token when using Workload or
.venv\Lib\site-packages\google\auth\identity_pool.py:58:    Workforce Identity Federation. The identity pool credential does not cache the subject token,
.venv\Lib\site-packages\google\auth\identity_pool.py:63:    def get_subject_token(self, context, request):
.venv\Lib\site-packages\google\auth\identity_pool.py:64:        """Returns the requested subject token. The subject token must be valid.
.venv\Lib\site-packages\google\auth\identity_pool.py:70:                containing information about the requested audience and subject token type.
.venv\Lib\site-packages\google\auth\identity_pool.py:76:                subject token retrieval logic.
.venv\Lib\site-packages\google\auth\identity_pool.py:79:            str: The requested subject token string.
.venv\Lib\site-packages\google\auth\identity_pool.py:84:class _TokenContent(NamedTuple):
.venv\Lib\site-packages\google\auth\identity_pool.py:85:    """Models the token content response from file and url internal suppliers.
.venv\Lib\site-packages\google\auth\identity_pool.py:95:class _FileSupplier(SubjectTokenSupplier):
.venv\Lib\site-packages\google\auth\identity_pool.py:96:    """ Internal implementation of subject token supplier which supports reading a subject token from a file."""
.venv\Lib\site-packages\google\auth\identity_pool.py:98:    def __init__(self, path, format_type, subject_token_field_name):
.venv\Lib\site-packages\google\auth\identity_pool.py:101:        self._subject_token_field_name = subject_token_field_name
.venv\Lib\site-packages\google\auth\identity_pool.py:103:    @_helpers.copy_docstring(SubjectTokenSupplier)
.venv\Lib\site-packages\google\auth\identity_pool.py:104:    def get_subject_token(self, context, request):
.venv\Lib\site-packages\google\auth\identity_pool.py:109:            token_content = _TokenContent(file_obj.read(), self._path)
.venv\Lib\site-packages\google\auth\identity_pool.py:111:        return _parse_token_data(
.venv\Lib\site-packages\google\auth\identity_pool.py:112:            token_content, self._format_type, self._subject_token_field_name
.venv\Lib\site-packages\google\auth\identity_pool.py:116:class _UrlSupplier(SubjectTokenSupplier):
.venv\Lib\site-packages\google\auth\identity_pool.py:117:    """ Internal implementation of subject token supplier which supports retrieving a subject token by calling a URL endpoint."""
.venv\Lib\site-packages\google\auth\identity_pool.py:119:    def __init__(self, url, format_type, subject_token_field_name, headers):
.venv\Lib\site-packages\google\auth\identity_pool.py:122:        self._subject_token_field_name = subject_token_field_name
.venv\Lib\site-packages\google\auth\identity_pool.py:125:    @_helpers.copy_docstring(SubjectTokenSupplier)
.venv\Lib\site-packages\google\auth\identity_pool.py:126:    def get_subject_token(self, context, request):
.venv\Lib\site-packages\google\auth\identity_pool.py:138:                "Unable to retrieve Identity Pool subject token", response_body
.venv\Lib\site-packages\google\auth\identity_pool.py:140:        token_content = _TokenContent(response_body, self._url)
.venv\Lib\site-packages\google\auth\identity_pool.py:141:        return _parse_token_data(
.venv\Lib\site-packages\google\auth\identity_pool.py:142:            token_content, self._format_type, self._subject_token_field_name
.venv\Lib\site-packages\google\auth\identity_pool.py:146:class _X509Supplier(SubjectTokenSupplier):
.venv\Lib\site-packages\google\auth\identity_pool.py:147:    """Internal supplier for X509 workload credentials. This class is used internally and always returns an empty string as the subject token."""
.venv\Lib\site-packages\google\auth\identity_pool.py:153:    @_helpers.copy_docstring(SubjectTokenSupplier)
.venv\Lib\site-packages\google\auth\identity_pool.py:154:    def get_subject_token(self, context, request):
.venv\Lib\site-packages\google\auth\identity_pool.py:233:def _parse_token_data(token_content, format_type="text", subject_token_field_name=None):
.venv\Lib\site-packages\google\auth\identity_pool.py:235:        token = token_content.content
.venv\Lib\site-packages\google\auth\identity_pool.py:239:            response_data = json.loads(token_content.content)
.venv\Lib\site-packages\google\auth\identity_pool.py:240:            # Get the subject_token.
.venv\Lib\site-packages\google\auth\identity_pool.py:241:            token = response_data[subject_token_field_name]
.venv\Lib\site-packages\google\auth\identity_pool.py:244:                "Unable to parse subject_token from JSON file '{}' using key '{}'".format(
.venv\Lib\site-packages\google\auth\identity_pool.py:245:                    token_content.location, subject_token_field_name
.venv\Lib\site-packages\google\auth\identity_pool.py:248:    if not token:
.venv\Lib\site-packages\google\auth\identity_pool.py:250:            "Missing subject_token in the credential_source file"
.venv\Lib\site-packages\google\auth\identity_pool.py:252:    return token
.venv\Lib\site-packages\google\auth\identity_pool.py:269:        subject_token_type,
.venv\Lib\site-packages\google\auth\identity_pool.py:270:        token_url=external_account._DEFAULT_TOKEN_URL,
.venv\Lib\site-packages\google\auth\identity_pool.py:272:        subject_token_supplier=None,
.venv\Lib\site-packages\google\auth\identity_pool.py:280:            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.
.venv\Lib\site-packages\google\auth\identity_pool.py:283:                    urn:ietf:params:oauth:token-type:jwt
.venv\Lib\site-packages\google\auth\identity_pool.py:284:                    urn:ietf:params:oauth:token-type:id-token
.venv\Lib\site-packages\google\auth\identity_pool.py:285:                    urn:ietf:params:oauth:token-type:saml2
.venv\Lib\site-packages\google\auth\identity_pool.py:287:            token_url (Optional [str]): The STS endpoint URL. If not provided, will default to "https://sts.googleapis.com/v1/token".
.venv\Lib\site-packages\google\auth\identity_pool.py:290:                exchanged for Google access tokens. Either a credential source or
.venv\Lib\site-packages\google\auth\identity_pool.py:291:                a subject token supplier must be provided.
.venv\Lib\site-packages\google\auth\identity_pool.py:299:                            "subject_token_field_name": "access_token",
.venv\Lib\site-packages\google\auth\identity_pool.py:307:                        "file": "/path/to/token/file.txt"
.venv\Lib\site-packages\google\auth\identity_pool.py:309:            subject_token_supplier (Optional [SubjectTokenSupplier]): Optional subject token supplier.
.venv\Lib\site-packages\google\auth\identity_pool.py:310:                This will be called to supply a valid subject token which will then
.venv\Lib\site-packages\google\auth\identity_pool.py:311:                be exchanged for Google access tokens. Either a subject token  supplier
.venv\Lib\site-packages\google\auth\identity_pool.py:318:                access token retrieval logic.
.venv\Lib\site-packages\google\auth\identity_pool.py:328:            subject_token_type=subject_token_type,
.venv\Lib\site-packages\google\auth\identity_pool.py:329:            token_url=token_url,
.venv\Lib\site-packages\google\auth\identity_pool.py:334:        if credential_source is None and subject_token_supplier is None:
.venv\Lib\site-packages\google\auth\identity_pool.py:336:                "A valid credential source or a subject token supplier must be provided."
.venv\Lib\site-packages\google\auth\identity_pool.py:338:        if credential_source is not None and subject_token_supplier is not None:
.venv\Lib\site-packages\google\auth\identity_pool.py:340:                "Identity pool credential cannot have both a credential source and a subject token supplier."
.venv\Lib\site-packages\google\auth\identity_pool.py:343:        if subject_token_supplier is not None:
.venv\Lib\site-packages\google\auth\identity_pool.py:344:            self._subject_token_supplier = subject_token_supplier
.venv\Lib\site-packages\google\auth\identity_pool.py:374:                self._subject_token_supplier = _FileSupplier(
.venv\Lib\site-packages\google\auth\identity_pool.py:380:                self._subject_token_supplier = _UrlSupplier(
.venv\Lib\site-packages\google\auth\identity_pool.py:387:                self._subject_token_supplier = _X509Supplier(
.venv\Lib\site-packages\google\auth\identity_pool.py:392:    def retrieve_subject_token(self, request):
.venv\Lib\site-packages\google\auth\identity_pool.py:393:        return self._subject_token_supplier.get_subject_token(
.venv\Lib\site-packages\google\auth\identity_pool.py:437:            args.update({"subject_token_supplier": self._subject_token_supplier})
.venv\Lib\site-packages\google\auth\identity_pool.py:473:        # For JSON types, get the required subject_token field name.
.venv\Lib\site-packages\google\auth\identity_pool.py:476:                "subject_token_field_name"
.venv\Lib\site-packages\google\auth\identity_pool.py:480:                    "Missing subject_token_field_name for JSON credential_source format"
.venv\Lib\site-packages\google\auth\identity_pool.py:528:        subject_token_supplier = info.get("subject_token_supplier")
.venv\Lib\site-packages\google\auth\identity_pool.py:529:        kwargs.update({"subject_token_supplier": subject_token_supplier})
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:21:Credential object has the "Service Account Token Creator" role on the target
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:46:_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:48:_GOOGLE_OAUTH2_TOKEN_ENDPOINT = "https://oauth2.googleapis.com/token"
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:60:def _make_iam_token_request(
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:68:    """Makes a request to the Google Cloud IAM service for an access token.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:71:        principal (str): The principal to request an access token for.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:85:            `Service Account Token Creator` is not assigned
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:106:        token_response = json.loads(response_body)
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:107:        token = token_response["accessToken"]
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:108:        expiry = datetime.strptime(token_response["expireTime"], "%Y-%m-%dT%H:%M:%SZ")
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:110:        return token, expiry
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:114:            "{}: No access token or invalid expiration in response.".format(
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:134:    `Service Account Token Creator`_ IAM role:
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:136:    For more information about Token Creator IAM role and
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:140:    .. _Service Account Token Creator:
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:141:        https://cloud.google.com/iam/docs/service-accounts#the_service_account_token_creator_role
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:148:    First grant source_credentials the `Service Account Token Creator`
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:151:    token creator role on
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:204:        lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:217:                to grant the final access_token.  If set, the sequence of
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:218:                identities must have "Service Account Token Creator" capability
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:221:                must have the Token Creator role on serviceAccountB.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:222:                serviceAccountB must have the Token Creator on
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:224:                Finally, C must have Token Creator on target_principal.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:264:        self._lifetime = lifetime or _DEFAULT_TOKEN_LIFETIME_SECS
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:265:        self.token = None
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:275:    def _refresh_token(self, request):
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:276:        """Updates credentials with a new access_token representing
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:286:            self._source_credentials.token_state == credentials.TokenState.STALE
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:287:            or self._source_credentials.token_state == credentials.TokenState.INVALID
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:299:            metrics.API_CLIENT_HEADER: metrics.token_request_access_token_impersonate(),
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:319:                "aud": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:321:                "exp": _helpers.datetime_to_secs(now) + _DEFAULT_TOKEN_LIFETIME_SECS,
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:332:            self.token, self.expiry, _ = _client.jwt_grant(
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:333:                request, _GOOGLE_OAUTH2_TOKEN_ENDPOINT, assertion
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:338:        self.token, self.expiry = _make_iam_token_request(
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:521:        end_index = impersonation_url.find(":generateAccessToken")
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:539:class IDTokenCredentials(credentials.CredentialsWithQuotaProject):
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:540:    """Open ID Connect ID Token-based service account credentials."""
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:552:                credential used as to acquire the id tokens for.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:553:            target_audience (string): Audience to issue the token for.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:554:            include_email (bool): Include email in IdToken
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:558:        super(IDTokenCredentials, self).__init__()
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:606:        iam_sign_endpoint = iam._IAM_IDTOKEN_ENDPOINT.replace(
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:619:            metrics.API_CLIENT_HEADER: metrics.token_request_id_token_impersonate(),
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:637:                "Error getting ID token: {}".format(response.json())
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:640:        id_token = response.json()["token"]
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:641:        self.token = id_token
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:643:            jwt.decode(id_token, verify=False)["exp"]
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:652:        principal (str): The principal to request an access token for.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:657:            to grant the final access_token.  If set, the sequence of
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:658:            identities must have "Service Account Token Creator" capability
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:661:            must have the Token Creator role on serviceAccountB.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:662:            serviceAccountB must have the Token Creator on
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:664:            Finally, C must have Token Creator on target_principal.
.venv\Lib\site-packages\google\auth\impersonated_credentials.py:674:            `Service Account Token Creator` is not assigned
.venv\Lib\site-packages\google\auth\jwt.py:15:"""JSON Web Tokens
.venv\Lib\site-packages\google\auth\jwt.py:66:_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds
.venv\Lib\site-packages\google\auth\jwt.py:130:def _unverified_decode(token):
.venv\Lib\site-packages\google\auth\jwt.py:131:    """Decodes a token and does no verification.
.venv\Lib\site-packages\google\auth\jwt.py:134:        token (Union[str, bytes]): The encoded JWT.
.venv\Lib\site-packages\google\auth\jwt.py:141:        google.auth.exceptions.MalformedError: if there are an incorrect amount of segments in the token or segments of the wrong type.
.venv\Lib\site-packages\google\auth\jwt.py:143:    token = _helpers.to_bytes(token)
.venv\Lib\site-packages\google\auth\jwt.py:145:    if token.count(b".") != 2:
.venv\Lib\site-packages\google\auth\jwt.py:147:            "Wrong number of segments in token: {0}".format(token)
.venv\Lib\site-packages\google\auth\jwt.py:150:    encoded_header, encoded_payload, signature = token.split(b".")
.venv\Lib\site-packages\google\auth\jwt.py:171:def decode_header(token):
.venv\Lib\site-packages\google\auth\jwt.py:172:    """Return the decoded header of a token.
.venv\Lib\site-packages\google\auth\jwt.py:176:    the token.
.venv\Lib\site-packages\google\auth\jwt.py:179:        token (Union[str, bytes]): the encoded JWT.
.venv\Lib\site-packages\google\auth\jwt.py:184:    header, _, _, _ = _unverified_decode(token)
.venv\Lib\site-packages\google\auth\jwt.py:189:    """Verifies the ``iat`` (Issued At) and ``exp`` (Expires) claims in a token
.venv\Lib\site-packages\google\auth\jwt.py:207:                "Token does not contain required claim {}".format(key)
.venv\Lib\site-packages\google\auth\jwt.py:210:    # Make sure the token wasn't issued in the future.
.venv\Lib\site-packages\google\auth\jwt.py:212:    # Err on the side of accepting a token that is slightly early to account
.venv\Lib\site-packages\google\auth\jwt.py:217:            "Token used too early, {} < {}. Check that your computer's clock is set correctly.".format(
.venv\Lib\site-packages\google\auth\jwt.py:222:    # Make sure the token wasn't issued in the past.
.venv\Lib\site-packages\google\auth\jwt.py:224:    # Err on the side of accepting a token that is slightly out of date
.venv\Lib\site-packages\google\auth\jwt.py:228:        raise exceptions.InvalidValue("Token expired, {} < {}".format(latest, now))
.venv\Lib\site-packages\google\auth\jwt.py:231:def decode(token, certs=None, verify=True, audience=None, clock_skew_in_seconds=0):
.venv\Lib\site-packages\google\auth\jwt.py:235:        token (str): The encoded JWT.
.venv\Lib\site-packages\google\auth\jwt.py:241:            in the token's header.
.venv\Lib\site-packages\google\auth\jwt.py:257:    header, payload, signed_section, signature = _unverified_decode(token)
.venv\Lib\site-packages\google\auth\jwt.py:281:    # use the certificate identified by the key ID in the token header.
.venv\Lib\site-packages\google\auth\jwt.py:299:        raise exceptions.MalformedError("Could not verify token signature.")
.venv\Lib\site-packages\google\auth\jwt.py:311:                "Token has wrong audience {}, expected one of {}".format(
.venv\Lib\site-packages\google\auth\jwt.py:322:    """Credentials that use a JWT as the bearer token.
.venv\Lib\site-packages\google\auth\jwt.py:325:    intended recipient of the bearer token.
.venv\Lib\site-packages\google\auth\jwt.py:378:        token_lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,
.venv\Lib\site-packages\google\auth\jwt.py:390:            token_lifetime (int): The amount of time in seconds for
.venv\Lib\site-packages\google\auth\jwt.py:391:                which the token is valid. Defaults to 1 hour.
.venv\Lib\site-packages\google\auth\jwt.py:400:        self._token_lifetime = token_lifetime
.venv\Lib\site-packages\google\auth\jwt.py:544:        lifetime = datetime.timedelta(seconds=self._token_lifetime)
.venv\Lib\site-packages\google\auth\jwt.py:563:        """Refreshes the access token.
.venv\Lib\site-packages\google\auth\jwt.py:570:        self.token, self.expiry = self._make_jwt()
.venv\Lib\site-packages\google\auth\jwt.py:597:    Like :class:`Credentials`, this class uses a JWT as the bearer token for
.venv\Lib\site-packages\google\auth\jwt.py:599:    construction time. Instead, it will generate a new token on-demand for
.venv\Lib\site-packages\google\auth\jwt.py:600:    each request using the request URI as the audience. It caches tokens
.venv\Lib\site-packages\google\auth\jwt.py:602:    of generating a new token every time.
.venv\Lib\site-packages\google\auth\jwt.py:618:        token_lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,
.venv\Lib\site-packages\google\auth\jwt.py:629:            token_lifetime (int): The amount of time in seconds for
.venv\Lib\site-packages\google\auth\jwt.py:630:                which the token is valid. Defaults to 1 hour.
.venv\Lib\site-packages\google\auth\jwt.py:631:            max_cache_size (int): The maximum number of JWT tokens to keep in
.venv\Lib\site-packages\google\auth\jwt.py:632:                cache. Tokens are cached using :class:`cachetools.LRUCache`.
.venv\Lib\site-packages\google\auth\jwt.py:641:        self._token_lifetime = token_lifetime
.venv\Lib\site-packages\google\auth\jwt.py:776:        These credentials are always valid because it generates tokens on
.venv\Lib\site-packages\google\auth\jwt.py:791:        lifetime = datetime.timedelta(seconds=self._token_lifetime)
.venv\Lib\site-packages\google\auth\jwt.py:811:        If there is already an existing, non-expired token in the cache for
.venv\Lib\site-packages\google\auth\jwt.py:812:        the audience, that token is used. Otherwise, a new token will be
.venv\Lib\site-packages\google\auth\jwt.py:821:        token, expiry = self._cache.get(audience, (None, None))
.venv\Lib\site-packages\google\auth\jwt.py:823:        if token is None or expiry < _helpers.utcnow():
.venv\Lib\site-packages\google\auth\jwt.py:824:            token, expiry = self._make_jwt_for_audience(audience)
.venv\Lib\site-packages\google\auth\jwt.py:825:            self._cache[audience] = token, expiry
.venv\Lib\site-packages\google\auth\jwt.py:827:        return token
.venv\Lib\site-packages\google\auth\jwt.py:863:        token = self._get_jwt_for_audience(audience)
.venv\Lib\site-packages\google\auth\jwt.py:864:        self.apply(headers, token=token)
.venv\Lib\site-packages\google\auth\metrics.py:30:REQUEST_TYPE_ACCESS_TOKEN = "auth-request-type/at"
.venv\Lib\site-packages\google\auth\metrics.py:31:REQUEST_TYPE_ID_TOKEN = "auth-request-type/it"
.venv\Lib\site-packages\google\auth\metrics.py:49:# Token request metric header values
.venv\Lib\site-packages\google\auth\metrics.py:51:# x-goog-api-client header value for access token request via metadata server.
.venv\Lib\site-packages\google\auth\metrics.py:53:def token_request_access_token_mds():
.venv\Lib\site-packages\google\auth\metrics.py:55:        python_and_auth_lib_version(), REQUEST_TYPE_ACCESS_TOKEN, CRED_TYPE_SA_MDS
.venv\Lib\site-packages\google\auth\metrics.py:59:# x-goog-api-client header value for ID token request via metadata server.
.venv\Lib\site-packages\google\auth\metrics.py:61:def token_request_id_token_mds():
.venv\Lib\site-packages\google\auth\metrics.py:63:        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_MDS
.venv\Lib\site-packages\google\auth\metrics.py:67:# x-goog-api-client header value for impersonated credentials access token request.
.venv\Lib\site-packages\google\auth\metrics.py:69:def token_request_access_token_impersonate():
.venv\Lib\site-packages\google\auth\metrics.py:72:        REQUEST_TYPE_ACCESS_TOKEN,
.venv\Lib\site-packages\google\auth\metrics.py:77:# x-goog-api-client header value for impersonated credentials ID token request.
.venv\Lib\site-packages\google\auth\metrics.py:79:def token_request_id_token_impersonate():
.venv\Lib\site-packages\google\auth\metrics.py:81:        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_IMPERSONATE
.venv\Lib\site-packages\google\auth\metrics.py:85:# x-goog-api-client header value for service account credentials access token
.venv\Lib\site-packages\google\auth\metrics.py:88:def token_request_access_token_sa_assertion():
.venv\Lib\site-packages\google\auth\metrics.py:90:        python_and_auth_lib_version(), REQUEST_TYPE_ACCESS_TOKEN, CRED_TYPE_SA_ASSERTION
.venv\Lib\site-packages\google\auth\metrics.py:94:# x-goog-api-client header value for service account credentials ID token
.venv\Lib\site-packages\google\auth\metrics.py:97:def token_request_id_token_sa_assertion():
.venv\Lib\site-packages\google\auth\metrics.py:99:        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_ASSERTION
.venv\Lib\site-packages\google\auth\metrics.py:103:# x-goog-api-client header value for user credentials token request.
.venv\Lib\site-packages\google\auth\metrics.py:105:def token_request_user():
.venv\Lib\site-packages\google\auth\metrics.py:129:# x-goog-api-client header value for BYOID calls to the Security Token Service exchange token endpoint.
.venv\Lib\site-packages\google\auth\pluggable.py:21:them for Google access tokens.
.venv\Lib\site-packages\google\auth\pluggable.py:73:        subject_token_type,
.venv\Lib\site-packages\google\auth\pluggable.py:74:        token_url,
.venv\Lib\site-packages\google\auth\pluggable.py:83:            subject_token_type (str): The subject token type.
.venv\Lib\site-packages\google\auth\pluggable.py:84:            token_url (str): The STS endpoint URL.
.venv\Lib\site-packages\google\auth\pluggable.py:87:                exchanged for Google access tokens.
.venv\Lib\site-packages\google\auth\pluggable.py:103:                access token retrieval logic.
.venv\Lib\site-packages\google\auth\pluggable.py:115:            subject_token_type=subject_token_type,
.venv\Lib\site-packages\google\auth\pluggable.py:116:            token_url=token_url,
.venv\Lib\site-packages\google\auth\pluggable.py:145:        self._tokeninfo_username = ""
.venv\Lib\site-packages\google\auth\pluggable.py:175:    def retrieve_subject_token(self, request):
.venv\Lib\site-packages\google\auth\pluggable.py:189:                    # If the cached response is expired, _parse_subject_token will raise an error which will be ignored and we will call the executable again.
.venv\Lib\site-packages\google\auth\pluggable.py:190:                    subject_token = self._parse_subject_token(response)
.venv\Lib\site-packages\google\auth\pluggable.py:200:                    return subject_token
.venv\Lib\site-packages\google\auth\pluggable.py:244:        subject_token = self._parse_subject_token(response)
.venv\Lib\site-packages\google\auth\pluggable.py:245:        return subject_token
.venv\Lib\site-packages\google\auth\pluggable.py:248:        """Revokes the subject token using the credential_source object.
.venv\Lib\site-packages\google\auth\pluggable.py:305:        return self.service_account_email or self._tokeninfo_username
.venv\Lib\site-packages\google\auth\pluggable.py:358:        env["GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE"] = self._subject_token_type
.venv\Lib\site-packages\google\auth\pluggable.py:371:    def _parse_subject_token(self, response):
.venv\Lib\site-packages\google\auth\pluggable.py:385:                "The token returned by the executable is expired."
.venv\Lib\site-packages\google\auth\pluggable.py:387:        if "token_type" not in response:
.venv\Lib\site-packages\google\auth\pluggable.py:389:                "The executable response is missing the token_type field."
.venv\Lib\site-packages\google\auth\pluggable.py:392:            response["token_type"] == "urn:ietf:params:oauth:token-type:jwt"
.venv\Lib\site-packages\google\auth\pluggable.py:393:            or response["token_type"] == "urn:ietf:params:oauth:token-type:id_token"
.venv\Lib\site-packages\google\auth\pluggable.py:395:            return response["id_token"]
.venv\Lib\site-packages\google\auth\pluggable.py:396:        elif response["token_type"] == "urn:ietf:params:oauth:token-type:saml2":  # SAML
.venv\Lib\site-packages\google\auth\pluggable.py:399:            raise exceptions.RefreshError("Executable returned unsupported token type.")
.venv\Lib\site-packages\google\auth\transport\requests.py:553:        # A stored token may expire between the time it is retrieved and
.venv\Lib\site-packages\google\auth\transport\urllib3.py:402:        # A stored token may expire between the time it is retrieved and
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:37:# The command to get google user access token
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:38:_CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND = ("auth", "print-access-token")
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:117:def get_auth_access_token(account=None):
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:118:    """Load user access token with the ``gcloud auth print-access-token`` command.
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:121:        account (Optional[str]): Account to get the access token for. If not
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:125:        str: The user access token.
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:128:        google.auth.exceptions.UserAccessTokenError: if failed to get access
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:129:            token from gcloud.
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:140:                + _CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:144:            command = (command,) + _CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:146:        access_token = subprocess.check_output(command, stderr=subprocess.STDOUT)
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:148:        return access_token.decode("utf-8").strip()
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:150:        new_exc = exceptions.UserAccessTokenError(
.venv\Lib\site-packages\google\auth\_cloud_sdk.py:151:            "Failed to obtain access token", caught_exc
.venv\Lib\site-packages\google\auth\_credentials_async.py:28:    All credentials have a :attr:`token` that is used for authentication and
.venv\Lib\site-packages\google\auth\_credentials_async.py:29:    may also optionally set an :attr:`expiry` to indicate when the token will
.venv\Lib\site-packages\google\auth\_credentials_async.py:36:    Although the token and expiration will change as the credentials are
.venv\Lib\site-packages\google\auth\_credentials_async.py:48:        apply the token to the authentication header.
.venv\Lib\site-packages\google\auth\_credentials_async.py:92:    Some credentials require scopes in order to obtain a token. You can check
.venv\Lib\site-packages\google\auth\_credentials_async.py:122:    Some credentials require scopes in order to obtain a token. You can check
.venv\Lib\site-packages\google\auth\_credentials_base.py:26:    All credentials have a :attr:`token` that is used for authentication and
.venv\Lib\site-packages\google\auth\_credentials_base.py:27:    may also optionally set an :attr:`expiry` to indicate when the token will
.venv\Lib\site-packages\google\auth\_credentials_base.py:34:    Although the token and expiration will change as the credentials are
.venv\Lib\site-packages\google\auth\_credentials_base.py:42:        token (Optional[str]): The bearer token that can be used in HTTP headers to make
.venv\Lib\site-packages\google\auth\_credentials_base.py:47:        self.token = None
.venv\Lib\site-packages\google\auth\_credentials_base.py:51:        """Refreshes the access token.
.venv\Lib\site-packages\google\auth\_credentials_base.py:65:    def _apply(self, headers, token=None):
.venv\Lib\site-packages\google\auth\_credentials_base.py:66:        """Apply the token to the authentication header.
.venv\Lib\site-packages\google\auth\_credentials_base.py:70:            token (Optional[str]): If specified, overrides the current access
.venv\Lib\site-packages\google\auth\_credentials_base.py:71:                token.
.venv\Lib\site-packages\google\auth\_credentials_base.py:74:            _helpers.from_bytes(token or self.token)
.venv\Lib\site-packages\google\auth\_default.py:94:# The subject token type used for AWS external_account credentials.
.venv\Lib\site-packages\google\auth\_default.py:95:_AWS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:aws:token-type:aws4_request"
.venv\Lib\site-packages\google\auth\_default.py:454:    if info.get("subject_token_type") == _AWS_SUBJECT_TOKEN_TYPE:
.venv\Lib\site-packages\google\auth\_default.py:607:       These will then be exchanged for Google access tokens via the Google STS
.venv\Lib\site-packages\google\auth\_helpers.py:40:# The smallest MDS cache used by this library stores tokens until 4 minutes from
.venv\Lib\site-packages\google\auth\_helpers.py:46:    "accessToken",
.venv\Lib\site-packages\google\auth\_helpers.py:47:    "access_token",
.venv\Lib\site-packages\google\auth\_helpers.py:48:    "id_token",
.venv\Lib\site-packages\google\auth\_helpers.py:50:    "refresh_token",
.venv\Lib\site-packages\google\auth\_jwt_async.py:15:"""JSON Web Tokens
.venv\Lib\site-packages\google\auth\_jwt_async.py:67:def decode(token, certs=None, verify=True, audience=None):
.venv\Lib\site-packages\google\auth\_jwt_async.py:71:        token (str): The encoded JWT.
.venv\Lib\site-packages\google\auth\_jwt_async.py:77:            in the token's header.
.venv\Lib\site-packages\google\auth\_jwt_async.py:90:    return jwt.decode(token, certs, verify, audience)
.venv\Lib\site-packages\google\auth\_jwt_async.py:96:    """Credentials that use a JWT as the bearer token.
.venv\Lib\site-packages\google\auth\_jwt_async.py:99:    intended recipient of the bearer token.
.venv\Lib\site-packages\google\auth\_jwt_async.py:151:    Like :class:`Credentials`, this class uses a JWT as the bearer token for
.venv\Lib\site-packages\google\auth\_jwt_async.py:153:    construction time. Instead, it will generate a new token on-demand for
.venv\Lib\site-packages\google\auth\_jwt_async.py:154:    each request using the request URI as the audience. It caches tokens
.venv\Lib\site-packages\google\auth\_jwt_async.py:156:    of generating a new token every time.
.venv\Lib\site-packages\google\auth\_oauth2client.py:60:        token=credentials.access_token,
.venv\Lib\site-packages\google\auth\_oauth2client.py:61:        refresh_token=credentials.refresh_token,
.venv\Lib\site-packages\google\auth\_oauth2client.py:62:        token_uri=credentials.token_uri,
.venv\Lib\site-packages\google\auth\_oauth2client.py:68:    new_credentials._expires = credentials.token_expiry
.venv\Lib\site-packages\google\auth\_oauth2client.py:86:    info["token_uri"] = credentials.token_uri
.venv\Lib\site-packages\google\auth\_refresh_worker.py:26:    Organizes exactly one background job that refresh a token.
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:103:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:104:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:179:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:180:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:259:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:260:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:335:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\services\firestore_admin\pagers.py:336:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:544:        page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:545:            A page token, returned from a previous call to
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:562:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:575:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:576:            A page token that may be used to request
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:590:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:687:        page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:688:            A page token, returned from a previous call to
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:705:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:718:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:719:            A page token that may be used to request
.venv\Lib\site-packages\google\cloud\firestore_admin_v1\types\firestore_admin.py:733:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:188:        If credentials are provided the token is extracted and added to the
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:190:        have been created from a signed custom token.
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:197:        # Default the token to a non-empty string, in this case "owner".
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:198:        token = "owner"
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:201:            and getattr(self._credentials, "id_token", None) is not None
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:203:            token = self._credentials.id_token
.venv\Lib\site-packages\google\cloud\firestore_v1\base_client.py:204:        options = [("Authorization", f"Bearer {token}")]
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:314:            initial_tokens=self._options.initial_ops_per_second,
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:315:            global_max_tokens=self._options.max_ops_per_second,
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:515:        # Set up this boolean to avoid repeatedly taking tokens if we're only
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:517:        have_received_tokens: bool = False
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:525:                self._in_flight_documents <= self._rate_limiter._maximum_tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:527:            # Ask for tokens each pass through this loop until they are granted,
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:529:            have_received_tokens = have_received_tokens or bool(
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:530:                self._rate_limiter.take_tokens(batch_size)
.venv\Lib\site-packages\google\cloud\firestore_v1\bulk_writer.py:532:            if not under_threshold or not have_received_tokens:
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:35:PATH_ELEMENT_TOKENS = [
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:40:TOKENS_PATTERN = "|".join("(?P<{}>{})".format(*pair) for pair in PATH_ELEMENT_TOKENS)
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:41:TOKENS_REGEX = re.compile(TOKENS_PATTERN)
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:44:def _tokenize_field_path(path: str):
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:45:    """Lex a field path into tokens (including dots).
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:50:        List(str): tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:53:    get_token = TOKENS_REGEX.match
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:54:    match = get_token(path)
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:60:        match = get_token(path, pos)
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:71:        List(str): tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\field_path.py:82:    for element in _tokenize_field_path(path):
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:33:default_initial_tokens: int = 500
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:39:    """Implements 5/5/5 ramp-up via Token Bucket algorithm.
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:47:    The Token Bucket algorithm uses the metaphor of a bucket, or pile, or really
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:48:    any container, if we're being honest, of tokens from which a user is able
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:49:    to draw. If there are tokens available, you can do the thing. If there are not,
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:50:    you can not do the thing. Additionally, tokens replenish at a fixed rate.
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:55:        tokens = rate_limiter.take_tokens(20)
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:57:        if not tokens:
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:60:            for _ in range(tokens):
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:64:        initial_tokens (Optional[int]): Starting size of the budget. Defaults
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:73:        initial_tokens: int = default_initial_tokens,
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:74:        global_max_tokens: Optional[int] = None,
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:83:        self._global_max_tokens = global_max_tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:90:        self._available_tokens: int = initial_tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:94:        self._maximum_tokens: int = self._available_tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:96:        if self._global_max_tokens is not None:
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:97:            self._available_tokens = min(
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:98:                self._available_tokens, self._global_max_tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:100:            self._maximum_tokens = min(self._maximum_tokens, self._global_max_tokens)
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:102:        # Number of seconds after which the [_maximum_tokens] can increase by 50%.
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:105:        # Tracks how many times the [_maximum_tokens] has increased by 50%.
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:113:    def take_tokens(self, num: int = 1, allow_less: bool = False) -> int:
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:114:        """Returns the number of available tokens, up to the amount requested."""
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:119:        minimum_tokens = 1 if allow_less else num
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:121:        if self._available_tokens >= minimum_tokens:
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:122:            _num_to_take = min(self._available_tokens, num)
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:123:            self._available_tokens -= _num_to_take
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:160:            self._increase_maximum_tokens()
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:162:    def _increase_maximum_tokens(self) -> None:
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:163:        self._maximum_tokens = round(self._maximum_tokens * 1.5)
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:164:        if self._global_max_tokens is not None:
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:165:            self._maximum_tokens = min(self._maximum_tokens, self._global_max_tokens)
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:168:        """Replenishes any tokens that should have regenerated since the last
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:181:                self._available_tokens = self._maximum_tokens
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:184:            # allocate proportional tokens.
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:189:                new_tokens: int = round(_percent_of_max * self._maximum_tokens)
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:191:                # Add the number of provisioned tokens, capped at the maximum size.
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:192:                self._available_tokens = min(
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:193:                    self._maximum_tokens,
.venv\Lib\site-packages\google\cloud\firestore_v1\rate_limiter.py:194:                    self._available_tokens + new_tokens,
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\async_client.py:1513:                existing one from a token.
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\async_client.py:1516:                response containing only an ID and a token, to use in
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\async_client.py:1520:                responses later than the given token, then a response
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\async_client.py:1521:                containing only an up-to-date token, to use in the next
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\async_client.py:1588:                add_target.resume_token = b'resume_token_blob'
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\client.py:1892:                existing one from a token.
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\client.py:1895:                response containing only an ID and a token, to use in
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\client.py:1899:                responses later than the given token, then a response
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\client.py:1900:                containing only an up-to-date token, to use in the next
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\client.py:1967:                add_target.resume_token = b'resume_token_blob'
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:103:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:104:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:179:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:180:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:259:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:260:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:335:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:336:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:415:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:416:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:491:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\firestore_v1\services\firestore\pagers.py:492:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:162:        page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:163:            Optional. A page token, received from a previous
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:169:            generated the page token.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:228:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:265:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:266:            A token to retrieve the next page of
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:281:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1010:        page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1011:            The ``next_page_token`` value returned from a previous call
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1017:            For example, two subsequent calls using a page_token may
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1033:            partitions and a ``next_page_token`` if more results exist.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1062:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1102:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1103:            A page token that may be used to request an additional set
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1118:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1129:    a token.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1132:    containing only an ID and a token, to use in the next request.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1135:    than the given token, then a response containing only an up-to-date
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1136:    token, to use in the next request.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1154:        stream_token (bytes):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1155:            A stream token that was previously sent by the server.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1157:            The client should set this field to the token from the most
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1160:            responses up to this token. After sending this token,
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1161:            earlier tokens may not be used anymore.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1188:    stream_token: bytes = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1208:        stream_token (bytes):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1209:            A token that represents the position of this
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1229:    stream_token: bytes = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1388:        resume_token (bytes):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1389:            A resume token from a prior
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1393:            Using a resume token with a different target is unsupported
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1430:            resume token or read time.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1499:    resume_token: bytes = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1540:        resume_token (bytes):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1541:            A token that can be used to resume the stream for the given
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1566:                ``resume_token``.
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1609:    resume_token: bytes = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1635:        page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1636:            A page token. Must be a value from
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1657:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1676:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1677:            A page token that may be used to continue the
.venv\Lib\site-packages\google\cloud\firestore_v1\types\firestore.py:1689:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\firestore_v1\types\write.py:494:            existed; that is, re-add the target without a resume token
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:207:        self.resume_token = None
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:245:        # The server assigns and updates the resume token.
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:297:        if self.resume_token is not None:
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:298:            self._targets["resume_token"] = self.resume_token
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:300:            self._targets.pop("resume_token", None)
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:387:            self.push(target_change.read_time, target_change.resume_token)
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:546:    def push(self, read_time, next_resume_token):
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:573:        self.resume_token = next_resume_token
.venv\Lib\site-packages\google\cloud\firestore_v1\watch.py:723:        self.resume_token = None
.venv\Lib\site-packages\google\cloud\location\locations_pb2.py:37:    b'\n%google/cloud/location/locations.proto\x12\x15google.cloud.location\x1a\x1cgoogle/api/annotations.proto\x1a\x19google/protobuf/any.proto\x1a\x17google/api/client.proto"[\n\x14ListLocationsRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\x0e\n\x06\x66ilter\x18\x02 \x01(\t\x12\x11\n\tpage_size\x18\x03 \x01(\x05\x12\x12\n\npage_token\x18\x04 \x01(\t"d\n\x15ListLocationsResponse\x12\x32\n\tlocations\x18\x01 \x03(\x0b\x32\x1f.google.cloud.location.Location\x12\x17\n\x0fnext_page_token\x18\x02 \x01(\t""\n\x12GetLocationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t"\xd7\x01\n\x08Location\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\x13\n\x0blocation_id\x18\x04 \x01(\t\x12\x14\n\x0c\x64isplay_name\x18\x05 \x01(\t\x12;\n\x06labels\x18\x02 \x03(\x0b\x32+.google.cloud.location.Location.LabelsEntry\x12&\n\x08metadata\x18\x03 \x01(\x0b\x32\x14.google.protobuf.Any\x1a-\n\x0bLabelsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x32\xa4\x03\n\tLocations\x12\xab\x01\n\rListLocations\x12+.google.cloud.location.ListLocationsRequest\x1a,.google.cloud.location.ListLocationsResponse"?\x82\xd3\xe4\x93\x02\x39\x12\x14/v1/{name=locations}Z!\x12\x1f/v1/{name=projects/*}/locations\x12\x9e\x01\n\x0bGetLocation\x12).google.cloud.location.GetLocationRequest\x1a\x1f.google.cloud.location.Location"C\x82\xd3\xe4\x93\x02=\x12\x16/v1/{name=locations/*}Z#\x12!/v1/{name=projects/*/locations/*}\x1aH\xca\x41\x14\x63loud.googleapis.com\xd2\x41.https://www.googleapis.com/auth/cloud-platformBo\n\x19\x63om.google.cloud.locationB\x0eLocationsProtoP\x01Z=google.golang.org/genproto/googleapis/cloud/location;location\xf8\x01\x01\x62\x06proto3'
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:102:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:103:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:180:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:181:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:260:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:261:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:340:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1\services\adaptation\pagers.py:341:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:167:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:168:            A page token, received from a previous ``ListPhraseSet``
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:173:            token.
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:184:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:196:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:197:            A token, which can be sent as ``page_token`` to retrieve the
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:211:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:349:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:350:            A page token, received from a previous ``ListCustomClass``
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:355:            page token.
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:366:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:378:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:379:            A token, which can be sent as ``page_token`` to retrieve the
.venv\Lib\site-packages\google\cloud\speech_v1\types\cloud_speech_adaptation.py:393:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:102:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:103:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:180:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:181:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:260:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:261:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:340:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\services\adaptation\pagers.py:341:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:167:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:168:            A page token, received from a previous ``ListPhraseSet``
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:173:            token.
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:184:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:196:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:197:            A token, which can be sent as ``page_token`` to retrieve the
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:211:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:349:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:350:            A page token, received from a previous ``ListCustomClass``
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:355:            page token.
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:366:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:378:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:379:            A token, which can be sent as ``page_token`` to retrieve the
.venv\Lib\site-packages\google\cloud\speech_v1p1beta1\types\cloud_speech_adaptation.py:393:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:102:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:103:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:178:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:179:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:258:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:259:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:334:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:335:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:414:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:415:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:490:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\speech_v2\services\speech\pagers.py:491:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:390:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:391:            A page token, received from a previous
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:397:            must match the call that provided the page token.
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:411:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:429:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:430:            A token, which can be sent as
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:431:            [page_token][google.cloud.speech.v2.ListRecognizersRequest.page_token]
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:433:            are no subsequent pages. This token expires after 72 hours.
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:445:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:2995:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:2996:            A page token, received from a previous
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3002:            must match the call that provided the page token.
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3016:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3034:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3035:            A token, which can be sent as
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3036:            [page_token][google.cloud.speech.v2.ListCustomClassesRequest.page_token]
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3038:            are no subsequent pages. This token expires after 72 hours.
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3050:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3247:        page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3248:            A page token, received from a previous
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3254:            must match the call that provided the page token.
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3268:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3286:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3287:            A token, which can be sent as
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3288:            [page_token][google.cloud.speech.v2.ListPhraseSetsRequest.page_token]
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3290:            are no subsequent pages. This token expires after 72 hours.
.venv\Lib\site-packages\google\cloud\speech_v2\types\cloud_speech.py:3302:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\storage\blob.py:479:        access_token=None,
.venv\Lib\site-packages\google\cloud\storage\blob.py:582:        :type access_token: str
.venv\Lib\site-packages\google\cloud\storage\blob.py:583:        :param access_token: (Optional) Access token for a service account.
.venv\Lib\site-packages\google\cloud\storage\blob.py:685:            access_token=access_token,
.venv\Lib\site-packages\google\cloud\storage\blob.py:3769:        token=None,
.venv\Lib\site-packages\google\cloud\storage\blob.py:3794:        :type token: str
.venv\Lib\site-packages\google\cloud\storage\blob.py:3795:        :param token:
.venv\Lib\site-packages\google\cloud\storage\blob.py:3796:            (Optional) Token returned from an earlier, not-completed call to
.venv\Lib\site-packages\google\cloud\storage\blob.py:3865:        :returns: ``(token, bytes_rewritten, total_bytes)``, where ``token``
.venv\Lib\site-packages\google\cloud\storage\blob.py:3866:                  is a rewrite token (``None`` if the rewrite is complete),
.venv\Lib\site-packages\google\cloud\storage\blob.py:3880:            if token:
.venv\Lib\site-packages\google\cloud\storage\blob.py:3881:                query_params["rewriteToken"] = token
.venv\Lib\site-packages\google\cloud\storage\blob.py:3923:            # completely done. Additionally, there is no rewrite token to return
.venv\Lib\site-packages\google\cloud\storage\blob.py:3929:            return api_response["rewriteToken"], rewritten, size
.venv\Lib\site-packages\google\cloud\storage\blob.py:4036:            token, _, _ = self.rewrite(
.venv\Lib\site-packages\google\cloud\storage\blob.py:4049:            while token is not None:
.venv\Lib\site-packages\google\cloud\storage\blob.py:4050:                token, _, _ = self.rewrite(
.venv\Lib\site-packages\google\cloud\storage\blob.py:4052:                    token=token,
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1410:        page_token=None,
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1435:        :type page_token: str
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1436:        :param page_token:
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1438:            value, which must correspond to the ``nextPageToken`` value
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1441:            token.
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1484:            page token and the name and language of each blob returned:
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1485:            ``'items(name,contentLanguage),nextPageToken'``.
.venv\Lib\site-packages\google\cloud\storage\bucket.py:1533:                page_token=page_token,
.venv\Lib\site-packages\google\cloud\storage\client.py:507:        page_token=None,
.venv\Lib\site-packages\google\cloud\storage\client.py:534:            page_token=page_token,
.venv\Lib\site-packages\google\cloud\storage\client.py:1250:        page_token=None,
.venv\Lib\site-packages\google\cloud\storage\client.py:1285:            page_token (str):
.venv\Lib\site-packages\google\cloud\storage\client.py:1287:                value, which must correspond to the ``nextPageToken`` value
.venv\Lib\site-packages\google\cloud\storage\client.py:1290:                token.
.venv\Lib\site-packages\google\cloud\storage\client.py:1330:                page token and the name and language of each blob returned:
.venv\Lib\site-packages\google\cloud\storage\client.py:1331:                ``'items(name,contentLanguage),nextPageToken'``.
.venv\Lib\site-packages\google\cloud\storage\client.py:1424:                page_token=page_token,
.venv\Lib\site-packages\google\cloud\storage\client.py:1439:        page_token=None,
.venv\Lib\site-packages\google\cloud\storage\client.py:1460:        :type page_token: str
.venv\Lib\site-packages\google\cloud\storage\client.py:1461:        :param page_token:
.venv\Lib\site-packages\google\cloud\storage\client.py:1463:            value, which must correspond to the ``nextPageToken`` value
.venv\Lib\site-packages\google\cloud\storage\client.py:1466:            token.
.venv\Lib\site-packages\google\cloud\storage\client.py:1481:            response with just the next page token and the language of each
.venv\Lib\site-packages\google\cloud\storage\client.py:1482:            bucket returned: 'items/id,nextPageToken'
.venv\Lib\site-packages\google\cloud\storage\client.py:1545:                page_token=page_token,
.venv\Lib\site-packages\google\cloud\storage\client.py:1790:        access_token=None,
.venv\Lib\site-packages\google\cloud\storage\client.py:1847:        :type access_token: str
.venv\Lib\site-packages\google\cloud\storage\client.py:1848:        :param access_token: (Optional) Access token for a service account.
.venv\Lib\site-packages\google\cloud\storage\client.py:1863:        if not access_token or not service_account_email:
.venv\Lib\site-packages\google\cloud\storage\client.py:1914:        if access_token and service_account_email:
.venv\Lib\site-packages\google\cloud\storage\client.py:1915:            signature = _sign_message(str_to_sign, access_token, service_account_email)
.venv\Lib\site-packages\google\cloud\storage\_signing.py:61:            "just contains a token. see {} for more "
.venv\Lib\site-packages\google\cloud\storage\_signing.py:275:    access_token=None,
.venv\Lib\site-packages\google\cloud\storage\_signing.py:354:    :type access_token: str
.venv\Lib\site-packages\google\cloud\storage\_signing.py:355:    :param access_token: (Optional) Access token for a service account.
.venv\Lib\site-packages\google\cloud\storage\_signing.py:389:    if access_token and service_account_email:
.venv\Lib\site-packages\google\cloud\storage\_signing.py:391:            string_to_sign, access_token, service_account_email, universe_domain
.venv\Lib\site-packages\google\cloud\storage\_signing.py:439:    access_token=None,
.venv\Lib\site-packages\google\cloud\storage\_signing.py:464:                        only if service_account_email and access_token are not
.venv\Lib\site-packages\google\cloud\storage\_signing.py:528:    :type access_token: str
.venv\Lib\site-packages\google\cloud\storage\_signing.py:529:    :param access_token: (Optional) Access token for a service account.
.venv\Lib\site-packages\google\cloud\storage\_signing.py:550:    if not access_token or not service_account_email:
.venv\Lib\site-packages\google\cloud\storage\_signing.py:631:    if access_token and service_account_email:
.venv\Lib\site-packages\google\cloud\storage\_signing.py:633:            string_to_sign, access_token, service_account_email, universe_domain
.venv\Lib\site-packages\google\cloud\storage\_signing.py:660:    access_token,
.venv\Lib\site-packages\google\cloud\storage\_signing.py:669:    :type access_token: str
.venv\Lib\site-packages\google\cloud\storage\_signing.py:670:    :param access_token: Access token for a service account.
.venv\Lib\site-packages\google\cloud\storage\_signing.py:676:    :raises: :exc:`TransportError` if an `access_token` is unauthorized.
.venv\Lib\site-packages\google\cloud\storage\_signing.py:687:        "Authorization": "Bearer " + access_token,
.venv\Lib\site-packages\google\cloud\_helpers\__init__.py:510:                        access tokens.
.venv\Lib\site-packages\google\cloud\_helpers\__init__.py:542:                        access tokens.
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\async_client.py:3218:                token for the object whose write status
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\client.py:3611:                token for the object whose write status
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:101:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:102:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:177:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:178:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:257:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:258:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:333:        while self._response.next_page_token:
.venv\Lib\site-packages\google\cloud\_storage_v2\services\storage\pagers.py:334:            self._request.page_token = self._response.next_page_token
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:260:        page_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:261:            Optional. A previously-returned page token
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:285:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:307:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:308:            The continuation token, used to page through
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:323:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:668:        restore_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:669:            Optional. Restore token used to differentiate
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:729:    restore_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:981:        restore_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:982:            Optional. Restore token used to differentiate soft-deleted
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1038:    restore_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1158:        routing_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1159:            The routing token that influences request
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1163:            This field is a member of `oneof`_ ``_routing_token``.
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1215:    routing_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1312:        routing_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1313:            The routing token the client must use when retrying the read
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1315:            ``x-goog-request-params``, with key ``routing_token`` and
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1318:            This field is a member of `oneof`_ ``_routing_token``.
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1326:    routing_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1342:        routing_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1343:            The routing token the client must use when retrying the
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1345:            ``x-goog-request-params``, with key ``routing_token`` and
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1348:            This field is a member of `oneof`_ ``_routing_token``.
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1365:    routing_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1816:        routing_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1817:            An optional routing token that influences
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1821:            This field is a member of `oneof`_ ``_routing_token``.
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:1855:    routing_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2071:        page_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2072:            Optional. A previously-returned page token
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2140:    page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2197:            Required. The name of the resume token for
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2308:        rewrite_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2313:            a rewriteToken can omit all other request
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2385:            ``rewriteToken`` is invalid.
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2439:    rewrite_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2532:        rewrite_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2533:            A token to use in subsequent requests to
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2534:            continue copying data. This token is present in
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2555:    rewrite_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2971:            SPLIT_TOKEN_MAX_VALID_DAYS (14):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2972:                The maximum number of days for which a token
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:2994:        SPLIT_TOKEN_MAX_VALID_DAYS = 14
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4394:        restore_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4395:            Output only. Restore token used to
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4400:            This field is a member of `oneof`_ ``_restore_token``.
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4624:    restore_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4869:        next_page_token (str):
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4870:            The continuation token, used to page through
.venv\Lib\site-packages\google\cloud\_storage_v2\types\storage.py:4889:    next_page_token: str = proto.Field(
.venv\Lib\site-packages\google\cloud\_testing\__init__.py:117:        self.page_token = kwargs.get("page_token")
.venv\Lib\site-packages\google\longrunning\operations_proto_pb2.py:41:    b'\n#google/longrunning/operations.proto\x12\x12google.longrunning\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x19google/protobuf/any.proto\x1a google/protobuf/descriptor.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17google/rpc/status.proto"\xa8\x01\n\tOperation\x12\x0c\n\x04name\x18\x01 \x01(\t\x12&\n\x08metadata\x18\x02 \x01(\x0b\x32\x14.google.protobuf.Any\x12\x0c\n\x04\x64one\x18\x03 \x01(\x08\x12#\n\x05\x65rror\x18\x04 \x01(\x0b\x32\x12.google.rpc.StatusH\x00\x12(\n\x08response\x18\x05 \x01(\x0b\x32\x14.google.protobuf.AnyH\x00\x42\x08\n\x06result"#\n\x13GetOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t"\\\n\x15ListOperationsRequest\x12\x0c\n\x04name\x18\x04 \x01(\t\x12\x0e\n\x06\x66ilter\x18\x01 \x01(\t\x12\x11\n\tpage_size\x18\x02 \x01(\x05\x12\x12\n\npage_token\x18\x03 \x01(\t"d\n\x16ListOperationsResponse\x12\x31\n\noperations\x18\x01 \x03(\x0b\x32\x1d.google.longrunning.Operation\x12\x17\n\x0fnext_page_token\x18\x02 \x01(\t"&\n\x16\x43\x61ncelOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t"&\n\x16\x44\x65leteOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t"P\n\x14WaitOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\x12*\n\x07timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.Duration"=\n\rOperationInfo\x12\x15\n\rresponse_type\x18\x01 \x01(\t\x12\x15\n\rmetadata_type\x18\x02 \x01(\t2\xaa\x05\n\nOperations\x12\x94\x01\n\x0eListOperations\x12).google.longrunning.ListOperationsRequest\x1a*.google.longrunning.ListOperationsResponse"+\xda\x41\x0bname,filter\x82\xd3\xe4\x93\x02\x17\x12\x15/v1/{name=operations}\x12\x7f\n\x0cGetOperation\x12\'.google.longrunning.GetOperationRequest\x1a\x1d.google.longrunning.Operation"\'\xda\x41\x04name\x82\xd3\xe4\x93\x02\x1a\x12\x18/v1/{name=operations/**}\x12~\n\x0f\x44\x65leteOperation\x12*.google.longrunning.DeleteOperationRequest\x1a\x16.google.protobuf.Empty"\'\xda\x41\x04name\x82\xd3\xe4\x93\x02\x1a*\x18/v1/{name=operations/**}\x12\x88\x01\n\x0f\x43\x61ncelOperation\x12*.google.longrunning.CancelOperationRequest\x1a\x16.google.protobuf.Empty"1\xda\x41\x04name\x82\xd3\xe4\x93\x02$"\x1f/v1/{name=operations/**}:cancel:\x01*\x12Z\n\rWaitOperation\x12(.google.longrunning.WaitOperationRequest\x1a\x1d.google.longrunning.Operation"\x00\x1a\x1d\xca\x41\x1alongrunning.googleapis.com:Z\n\x0eoperation_info\x12\x1e.google.protobuf.MethodOptions\x18\x99\x08 \x01(\x0b\x32!.google.longrunning.OperationInfoB\xa5\x01\n\x16\x63om.google.longrunningB\x0fOperationsProtoP\x01ZCcloud.google.com/go/longrunning/autogen/longrunningpb;longrunningpb\xf8\x01\x01\xa2\x02\x05GLRUN\xaa\x02\x12Google.LongRunning\xca\x02\x12Google\\LongRunningb\x06proto3'
.venv\Lib\site-packages\google\oauth2\credentials.py:17:This module provides credentials based on OAuth 2.0 access and refresh tokens.
.venv\Lib\site-packages\google\oauth2\credentials.py:21:Specifically, this is intended to use access tokens acquired using the
.venv\Lib\site-packages\google\oauth2\credentials.py:22:`Authorization Code grant`_ and can refresh those tokens using a
.venv\Lib\site-packages\google\oauth2\credentials.py:23:optional `refresh token`_.
.venv\Lib\site-packages\google\oauth2\credentials.py:25:Obtaining the initial access and refresh token is outside of the scope of this
.venv\Lib\site-packages\google\oauth2\credentials.py:30:.. _refresh token: https://tools.ietf.org/html/rfc6749#section-6
.venv\Lib\site-packages\google\oauth2\credentials.py:50:# The Google OAuth 2.0 token endpoint. Used for authorized user credentials.
.venv\Lib\site-packages\google\oauth2\credentials.py:51:_GOOGLE_OAUTH2_TOKEN_ENDPOINT = "https://oauth2.googleapis.com/token"
.venv\Lib\site-packages\google\oauth2\credentials.py:53:# The Google OAuth 2.0 token info endpoint. Used for getting token info JSON from access tokens.
.venv\Lib\site-packages\google\oauth2\credentials.py:54:_GOOGLE_OAUTH2_TOKEN_INFO_ENDPOINT = "https://oauth2.googleapis.com/tokeninfo"
.venv\Lib\site-packages\google\oauth2\credentials.py:58:    """Credentials using OAuth 2.0 access and refresh tokens.
.venv\Lib\site-packages\google\oauth2\credentials.py:60:    The credentials are considered immutable except the tokens and the token
.venv\Lib\site-packages\google\oauth2\credentials.py:76:        token,
.venv\Lib\site-packages\google\oauth2\credentials.py:77:        refresh_token=None,
.venv\Lib\site-packages\google\oauth2\credentials.py:78:        id_token=None,
.venv\Lib\site-packages\google\oauth2\credentials.py:79:        token_uri=None,
.venv\Lib\site-packages\google\oauth2\credentials.py:86:        rapt_token=None,
.venv\Lib\site-packages\google\oauth2\credentials.py:96:            token (Optional(str)): The OAuth 2.0 access token. Can be None
.venv\Lib\site-packages\google\oauth2\credentials.py:98:            refresh_token (str): The OAuth 2.0 refresh token. If specified,
.venv\Lib\site-packages\google\oauth2\credentials.py:100:            id_token (str): The Open ID Connect ID Token.
.venv\Lib\site-packages\google\oauth2\credentials.py:101:            token_uri (str): The OAuth 2.0 authorization server's token
.venv\Lib\site-packages\google\oauth2\credentials.py:103:                None if the token can not be refreshed.
.venv\Lib\site-packages\google\oauth2\credentials.py:105:                refresh, can be left as None if the token can not be refreshed.
.venv\Lib\site-packages\google\oauth2\credentials.py:107:                for refresh, can be left as None if the token can not be
.venv\Lib\site-packages\google\oauth2\credentials.py:113:                token if refresh information is provided (e.g. The refresh
.venv\Lib\site-packages\google\oauth2\credentials.py:114:                token scopes are a superset of this or contain a wild card
.venv\Lib\site-packages\google\oauth2\credentials.py:121:            rapt_token (Optional[str]): The reauth Proof Token.
.venv\Lib\site-packages\google\oauth2\credentials.py:124:                OAuth scopes and when called returns an access token string for the
.venv\Lib\site-packages\google\oauth2\credentials.py:126:                refresh tokens are provided and tokens are obtained by calling
.venv\Lib\site-packages\google\oauth2\credentials.py:128:                retrieving downscoped tokens from a token broker.
.venv\Lib\site-packages\google\oauth2\credentials.py:140:        self.token = token
.venv\Lib\site-packages\google\oauth2\credentials.py:142:        self._refresh_token = refresh_token
.venv\Lib\site-packages\google\oauth2\credentials.py:143:        self._id_token = id_token
.venv\Lib\site-packages\google\oauth2\credentials.py:147:        self._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\credentials.py:151:        self._rapt_token = rapt_token
.venv\Lib\site-packages\google\oauth2\credentials.py:179:        self.token = d.get("token")
.venv\Lib\site-packages\google\oauth2\credentials.py:181:        self._refresh_token = d.get("_refresh_token")
.venv\Lib\site-packages\google\oauth2\credentials.py:182:        self._id_token = d.get("_id_token")
.venv\Lib\site-packages\google\oauth2\credentials.py:186:        self._token_uri = d.get("_token_uri")
.venv\Lib\site-packages\google\oauth2\credentials.py:190:        self._rapt_token = d.get("_rapt_token")
.venv\Lib\site-packages\google\oauth2\credentials.py:204:    def refresh_token(self):
.venv\Lib\site-packages\google\oauth2\credentials.py:205:        """Optional[str]: The OAuth 2.0 refresh token."""
.venv\Lib\site-packages\google\oauth2\credentials.py:206:        return self._refresh_token
.venv\Lib\site-packages\google\oauth2\credentials.py:219:    def token_uri(self):
.venv\Lib\site-packages\google\oauth2\credentials.py:220:        """Optional[str]: The OAuth 2.0 authorization server's token endpoint
.venv\Lib\site-packages\google\oauth2\credentials.py:222:        return self._token_uri
.venv\Lib\site-packages\google\oauth2\credentials.py:225:    def id_token(self):
.venv\Lib\site-packages\google\oauth2\credentials.py:226:        """Optional[str]: The Open ID Connect ID Token.
.venv\Lib\site-packages\google\oauth2\credentials.py:230:        :meth:`refresh` is called. This token is a JWT. It can be verified
.venv\Lib\site-packages\google\oauth2\credentials.py:231:        and decoded using :func:`google.oauth2.id_token.verify_oauth2_token`.
.venv\Lib\site-packages\google\oauth2\credentials.py:233:        return self._id_token
.venv\Lib\site-packages\google\oauth2\credentials.py:248:        the initial token is requested and can not be changed."""
.venv\Lib\site-packages\google\oauth2\credentials.py:252:    def rapt_token(self):
.venv\Lib\site-packages\google\oauth2\credentials.py:253:        """Optional[str]: The reauth Proof Token."""
.venv\Lib\site-packages\google\oauth2\credentials.py:254:        return self._rapt_token
.venv\Lib\site-packages\google\oauth2\credentials.py:288:            self.token,
.venv\Lib\site-packages\google\oauth2\credentials.py:289:            refresh_token=self.refresh_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:290:            id_token=self.id_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:291:            token_uri=self.token_uri,
.venv\Lib\site-packages\google\oauth2\credentials.py:298:            rapt_token=self.rapt_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:325:    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
.venv\Lib\site-packages\google\oauth2\credentials.py:326:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\oauth2\credentials.py:328:        cred._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\credentials.py:360:                "token, it's likely that the provided token is expired now, "
.venv\Lib\site-packages\google\oauth2\credentials.py:361:                "please update your code with a valid token.".format(
.venv\Lib\site-packages\google\oauth2\credentials.py:367:        # Use refresh handler if available and no refresh token is
.venv\Lib\site-packages\google\oauth2\credentials.py:368:        # available. This is useful in general when tokens are obtained by calling
.venv\Lib\site-packages\google\oauth2\credentials.py:370:        # downscoped tokens from a token broker.
.venv\Lib\site-packages\google\oauth2\credentials.py:371:        if self._refresh_token is None and self.refresh_handler:
.venv\Lib\site-packages\google\oauth2\credentials.py:372:            token, expiry = self.refresh_handler(request, scopes=scopes)
.venv\Lib\site-packages\google\oauth2\credentials.py:374:            if not isinstance(token, str):
.venv\Lib\site-packages\google\oauth2\credentials.py:376:                    "The refresh_handler returned token is not a string."
.venv\Lib\site-packages\google\oauth2\credentials.py:387:            self.token = token
.venv\Lib\site-packages\google\oauth2\credentials.py:392:            self._refresh_token is None
.venv\Lib\site-packages\google\oauth2\credentials.py:393:            or self._token_uri is None
.venv\Lib\site-packages\google\oauth2\credentials.py:399:                "refresh the access token. You must specify refresh_token, "
.venv\Lib\site-packages\google\oauth2\credentials.py:400:                "token_uri, client_id, and client_secret."
.venv\Lib\site-packages\google\oauth2\credentials.py:404:            access_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:405:            refresh_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:408:            rapt_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:411:            self._token_uri,
.venv\Lib\site-packages\google\oauth2\credentials.py:412:            self._refresh_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:416:            rapt_token=self._rapt_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:420:        self.token = access_token
.venv\Lib\site-packages\google\oauth2\credentials.py:422:        self._refresh_token = refresh_token
.venv\Lib\site-packages\google\oauth2\credentials.py:423:        self._id_token = grant_response.get("id_token")
.venv\Lib\site-packages\google\oauth2\credentials.py:424:        self._rapt_token = rapt_token
.venv\Lib\site-packages\google\oauth2\credentials.py:460:        keys_needed = set(("refresh_token", "client_id", "client_secret"))
.venv\Lib\site-packages\google\oauth2\credentials.py:469:        # access token expiry (datetime obj); auto-expire if not saved
.venv\Lib\site-packages\google\oauth2\credentials.py:485:            token=info.get("token"),
.venv\Lib\site-packages\google\oauth2\credentials.py:486:            refresh_token=info.get("refresh_token"),
.venv\Lib\site-packages\google\oauth2\credentials.py:487:            token_uri=_GOOGLE_OAUTH2_TOKEN_ENDPOINT,  # always overrides
.venv\Lib\site-packages\google\oauth2\credentials.py:493:            rapt_token=info.get("rapt_token"),  # may not exist
.venv\Lib\site-packages\google\oauth2\credentials.py:533:            "token": self.token,
.venv\Lib\site-packages\google\oauth2\credentials.py:534:            "refresh_token": self.refresh_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:535:            "token_uri": self.token_uri,
.venv\Lib\site-packages\google\oauth2\credentials.py:539:            "rapt_token": self.rapt_token,
.venv\Lib\site-packages\google\oauth2\credentials.py:556:class UserAccessTokenCredentials(credentials.CredentialsWithQuotaProject):
.venv\Lib\site-packages\google\oauth2\credentials.py:557:    """Access token credentials for user account.
.venv\Lib\site-packages\google\oauth2\credentials.py:559:    Obtain the access token for a given user account or the current active
.venv\Lib\site-packages\google\oauth2\credentials.py:560:    user account with the ``gcloud auth print-access-token`` command.
.venv\Lib\site-packages\google\oauth2\credentials.py:563:        account (Optional[str]): Account to get the access token for. If not
.venv\Lib\site-packages\google\oauth2\credentials.py:571:            "UserAccessTokenCredentials is deprecated, please use "
.venv\Lib\site-packages\google\oauth2\credentials.py:577:        super(UserAccessTokenCredentials, self).__init__()
.venv\Lib\site-packages\google\oauth2\credentials.py:585:            account (str): Account to get the access token for.
.venv\Lib\site-packages\google\oauth2\credentials.py:588:            google.oauth2.credentials.UserAccessTokenCredentials: The created
.venv\Lib\site-packages\google\oauth2\credentials.py:598:        """Refreshes the access token.
.venv\Lib\site-packages\google\oauth2\credentials.py:606:            google.auth.exceptions.UserAccessTokenError: If the access token
.venv\Lib\site-packages\google\oauth2\credentials.py:609:        self.token = _cloud_sdk.get_auth_access_token(self._account)
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:28:TOKEN_EXCHANGE_TYPE = "urn:ietf:params:oauth:token-type:token-exchange"
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:29:ACCESS_TOKEN_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:30:SERVICE_ACCOUNT_TOKEN_TYPE = "urn:k8s:params:oauth:token-type:serviceaccount"
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:53:            "token_uri": "https://service-identity.<Domain>/authenticate"
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:58:    The `ca_cert_path` is used for token server TLS certificate verification.
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:76:    The token is obtained in the following way. This class first creates a
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:78:    the `token_uri` as the `aud` claim, and signs the JWT with the `private_key`.
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:79:    It then sends the JWT to the `token_uri` to exchange a final token for
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:84:        self, signer, service_identity_name, project, audience, token_uri, ca_cert_path
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:92:            audience (str): The audience for the final token.
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:93:            token_uri (str): The token server uri.
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:94:            ca_cert_path (str): The CA cert path for token server side TLS
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:95:                certificate verification. If the token server uses well known
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:103:        self._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:116:            "aud": self._token_uri,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:132:        # Create a self signed JWT, and do token exchange.
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:133:        jwt_token = self._create_jwt()
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:135:            "grant_type": TOKEN_EXCHANGE_TYPE,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:137:            "requested_token_type": ACCESS_TOKEN_TOKEN_TYPE,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:138:            "subject_token": jwt_token,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:139:            "subject_token_type": SERVICE_ACCOUNT_TOKEN_TYPE,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:141:        response_data = _client._token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:143:            self._token_uri,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:145:            access_token=None,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:150:        self.token, _, self.expiry, _ = _client._handle_refresh_grant_response(
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:165:            self._token_uri,
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:193:            info["token_uri"],
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:221:                "token_uri",
.venv\Lib\site-packages\google\oauth2\gdch_credentials.py:247:                "token_uri",
.venv\Lib\site-packages\google\oauth2\id_token.py:15:"""Google ID Token helpers.
.venv\Lib\site-packages\google\oauth2\id_token.py:17:Provides support for verifying `OpenID Connect ID Tokens`_, especially ones
.venv\Lib\site-packages\google\oauth2\id_token.py:20:To parse and verify an ID Token issued by Google's OAuth 2.0 authorization
.venv\Lib\site-packages\google\oauth2\id_token.py:21:server use :func:`verify_oauth2_token`. To verify an ID Token issued by
.venv\Lib\site-packages\google\oauth2\id_token.py:22:Firebase, use :func:`verify_firebase_token`.
.venv\Lib\site-packages\google\oauth2\id_token.py:24:A general purpose ID Token verifier is available as :func:`verify_token`.
.venv\Lib\site-packages\google\oauth2\id_token.py:28:    from google.oauth2 import id_token
.venv\Lib\site-packages\google\oauth2\id_token.py:33:    id_info = id_token.verify_oauth2_token(
.venv\Lib\site-packages\google\oauth2\id_token.py:34:        token, request, 'my-client-id.example.com')
.venv\Lib\site-packages\google\oauth2\id_token.py:53:.. _OpenID Connect ID Tokens:
.venv\Lib\site-packages\google\oauth2\id_token.py:54:    http://openid.net/specs/openid-connect-core-1_0.html#IDToken
.venv\Lib\site-packages\google\oauth2\id_token.py:67:# The URL that provides public certificates for verifying ID tokens issued
.venv\Lib\site-packages\google\oauth2\id_token.py:71:# The URL that provides public certificates for verifying ID tokens issued
.venv\Lib\site-packages\google\oauth2\id_token.py:75:    "/securetoken@system.gserviceaccount.com"
.venv\Lib\site-packages\google\oauth2\id_token.py:107:def verify_token(
.venv\Lib\site-packages\google\oauth2\id_token.py:108:    id_token,
.venv\Lib\site-packages\google\oauth2\id_token.py:114:    """Verifies an ID token and returns the decoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:117:        id_token (Union[str, bytes]): The encoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:120:        audience (str or list): The audience or audiences that this token is
.venv\Lib\site-packages\google\oauth2\id_token.py:123:            verify the token. This URL should return JSON in the format of
.venv\Lib\site-packages\google\oauth2\id_token.py:130:        Mapping[str, Any]: The decoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:142:        signing_key = jwks_client.get_signing_key_from_jwt(id_token)
.venv\Lib\site-packages\google\oauth2\id_token.py:144:            id_token,
.venv\Lib\site-packages\google\oauth2\id_token.py:151:            id_token,
.venv\Lib\site-packages\google\oauth2\id_token.py:158:def verify_oauth2_token(id_token, request, audience=None, clock_skew_in_seconds=0):
.venv\Lib\site-packages\google\oauth2\id_token.py:159:    """Verifies an ID Token issued by Google's OAuth 2.0 authorization server.
.venv\Lib\site-packages\google\oauth2\id_token.py:162:        id_token (Union[str, bytes]): The encoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:165:        audience (str): The audience that this token is intended for. This is
.venv\Lib\site-packages\google\oauth2\id_token.py:172:        Mapping[str, Any]: The decoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:176:        ValueError: If token verification fails
.venv\Lib\site-packages\google\oauth2\id_token.py:178:    idinfo = verify_token(
.venv\Lib\site-packages\google\oauth2\id_token.py:179:        id_token,
.venv\Lib\site-packages\google\oauth2\id_token.py:196:def verify_firebase_token(id_token, request, audience=None, clock_skew_in_seconds=0):
.venv\Lib\site-packages\google\oauth2\id_token.py:197:    """Verifies an ID Token issued by Firebase Authentication.
.venv\Lib\site-packages\google\oauth2\id_token.py:200:        id_token (Union[str, bytes]): The encoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:203:        audience (str): The audience that this token is intended for. This is
.venv\Lib\site-packages\google\oauth2\id_token.py:210:        Mapping[str, Any]: The decoded token.
.venv\Lib\site-packages\google\oauth2\id_token.py:212:    return verify_token(
.venv\Lib\site-packages\google\oauth2\id_token.py:213:        id_token,
.venv\Lib\site-packages\google\oauth2\id_token.py:221:def fetch_id_token_credentials(audience, request=None):
.venv\Lib\site-packages\google\oauth2\id_token.py:222:    """Create the ID Token credentials from the current environment.
.venv\Lib\site-packages\google\oauth2\id_token.py:224:    This function acquires ID token from the environment in the following order.
.venv\Lib\site-packages\google\oauth2\id_token.py:228:       to the path of a valid service account JSON file, then ID token is
.venv\Lib\site-packages\google\oauth2\id_token.py:231:       then the ID token are obtained from the metadata server.
.venv\Lib\site-packages\google\oauth2\id_token.py:238:        import google.oauth2.id_token
.venv\Lib\site-packages\google\oauth2\id_token.py:244:        # Create ID token credentials.
.venv\Lib\site-packages\google\oauth2\id_token.py:245:        credentials = google.oauth2.id_token.fetch_id_token_credentials(target_audience, request=request)
.venv\Lib\site-packages\google\oauth2\id_token.py:247:        # Refresh the credential to obtain an ID token.
.venv\Lib\site-packages\google\oauth2\id_token.py:250:        id_token = credentials.token
.venv\Lib\site-packages\google\oauth2\id_token.py:251:        id_token_expiry = credentials.expiry
.venv\Lib\site-packages\google\oauth2\id_token.py:254:        audience (str): The audience that this ID token is intended for.
.venv\Lib\site-packages\google\oauth2\id_token.py:259:        google.auth.credentials.Credentials: The ID token credentials.
.venv\Lib\site-packages\google\oauth2\id_token.py:284:                    return service_account.IDTokenCredentials.from_service_account_info(
.venv\Lib\site-packages\google\oauth2\id_token.py:294:                    return impersonated_credentials.IDTokenCredentials(
.venv\Lib\site-packages\google\oauth2\id_token.py:306:    # 2. Try to fetch ID token from metada server if it exists. The code
.venv\Lib\site-packages\google\oauth2\id_token.py:319:            return compute_engine.IDTokenCredentials(
.venv\Lib\site-packages\google\oauth2\id_token.py:330:def fetch_id_token(request, audience):
.venv\Lib\site-packages\google\oauth2\id_token.py:331:    """Fetch the ID Token from the current environment.
.venv\Lib\site-packages\google\oauth2\id_token.py:333:    This function acquires ID token from the environment in the following order.
.venv\Lib\site-packages\google\oauth2\id_token.py:337:       to the path of a valid service account JSON file, then ID token is
.venv\Lib\site-packages\google\oauth2\id_token.py:340:       then the ID token are obtained from the metadata server.
.venv\Lib\site-packages\google\oauth2\id_token.py:347:        import google.oauth2.id_token
.venv\Lib\site-packages\google\oauth2\id_token.py:353:        id_token = google.oauth2.id_token.fetch_id_token(request, target_audience)
.venv\Lib\site-packages\google\oauth2\id_token.py:358:        audience (str): The audience that this ID token is intended for.
.venv\Lib\site-packages\google\oauth2\id_token.py:361:        str: The ID token.
.venv\Lib\site-packages\google\oauth2\id_token.py:368:    id_token_credentials = fetch_id_token_credentials(audience, request=request)
.venv\Lib\site-packages\google\oauth2\id_token.py:369:    id_token_credentials.refresh(request)
.venv\Lib\site-packages\google\oauth2\id_token.py:370:    return id_token_credentials.token
.venv\Lib\site-packages\google\oauth2\reauth.py:18:security token, etc.) while refreshing OAuth 2.0 credentials for a user.
.venv\Lib\site-packages\google\oauth2\reauth.py:32:3. Refreshing the access token using the returned rapt token.
.venv\Lib\site-packages\google\oauth2\reauth.py:66:    If the rapt token needs refreshing, the user needs to answer the challenges.
.venv\Lib\site-packages\google\oauth2\reauth.py:78:    request, supported_challenge_types, access_token, requested_scopes=None
.venv\Lib\site-packages\google\oauth2\reauth.py:87:        access_token (str): Access token with reauth scopes.
.venv\Lib\site-packages\google\oauth2\reauth.py:98:    return _client._token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\reauth.py:102:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:109:    request, session_id, challenge_id, client_input, access_token
.venv\Lib\site-packages\google\oauth2\reauth.py:111:    """Attempt to refresh access token by sending next challenge result.
.venv\Lib\site-packages\google\oauth2\reauth.py:120:        access_token (str): Access token with reauth scopes.
.venv\Lib\site-packages\google\oauth2\reauth.py:133:    return _client._token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\reauth.py:137:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:143:def _run_next_challenge(msg, request, access_token):
.venv\Lib\site-packages\google\oauth2\reauth.py:153:        access_token (str): reauth access token
.venv\Lib\site-packages\google\oauth2\reauth.py:187:            access_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:192:def _obtain_rapt(request, access_token, requested_scopes):
.venv\Lib\site-packages\google\oauth2\reauth.py:193:    """Given an http request method and reauth access token, get rapt token.
.venv\Lib\site-packages\google\oauth2\reauth.py:198:        access_token (str): reauth access token
.venv\Lib\site-packages\google\oauth2\reauth.py:202:        str: The rapt token.
.venv\Lib\site-packages\google\oauth2\reauth.py:210:        access_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:215:        return msg["encodedProofOfReauthToken"]
.venv\Lib\site-packages\google\oauth2\reauth.py:233:        msg = _run_next_challenge(msg, request, access_token)
.venv\Lib\site-packages\google\oauth2\reauth.py:236:            raise exceptions.ReauthFailError("Failed to obtain rapt token.")
.venv\Lib\site-packages\google\oauth2\reauth.py:238:            return msg["encodedProofOfReauthToken"]
.venv\Lib\site-packages\google\oauth2\reauth.py:241:    raise exceptions.ReauthFailError("Failed to obtain rapt token.")
.venv\Lib\site-packages\google\oauth2\reauth.py:244:def get_rapt_token(
.venv\Lib\site-packages\google\oauth2\reauth.py:245:    request, client_id, client_secret, refresh_token, token_uri, scopes=None
.venv\Lib\site-packages\google\oauth2\reauth.py:247:    """Given an http request method and refresh_token, get rapt token.
.venv\Lib\site-packages\google\oauth2\reauth.py:252:        client_id (str): client id to get access token for reauth scope.
.venv\Lib\site-packages\google\oauth2\reauth.py:254:        refresh_token (str): refresh token to refresh access token
.venv\Lib\site-packages\google\oauth2\reauth.py:255:        token_uri (str): uri to refresh access token
.venv\Lib\site-packages\google\oauth2\reauth.py:259:        str: The rapt token.
.venv\Lib\site-packages\google\oauth2\reauth.py:265:    # Get access token for reauth.
.venv\Lib\site-packages\google\oauth2\reauth.py:266:    access_token, _, _, _ = _client.refresh_grant(
.venv\Lib\site-packages\google\oauth2\reauth.py:270:        refresh_token=refresh_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:271:        token_uri=token_uri,
.venv\Lib\site-packages\google\oauth2\reauth.py:275:    # Get rapt token from reauth API.
.venv\Lib\site-packages\google\oauth2\reauth.py:276:    rapt_token = _obtain_rapt(request, access_token, requested_scopes=scopes)
.venv\Lib\site-packages\google\oauth2\reauth.py:279:    return rapt_token
.venv\Lib\site-packages\google\oauth2\reauth.py:284:    token_uri,
.venv\Lib\site-packages\google\oauth2\reauth.py:285:    refresh_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:289:    rapt_token=None,
.venv\Lib\site-packages\google\oauth2\reauth.py:297:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\reauth.py:299:        refresh_token (str): The refresh token to use to get a new access
.venv\Lib\site-packages\google\oauth2\reauth.py:300:            token.
.venv\Lib\site-packages\google\oauth2\reauth.py:304:            scopes must be authorized for the refresh token. Useful if refresh
.venv\Lib\site-packages\google\oauth2\reauth.py:305:            token has a wild card scope (e.g.
.venv\Lib\site-packages\google\oauth2\reauth.py:307:        rapt_token (Optional(str)): The rapt token for reauth.
.venv\Lib\site-packages\google\oauth2\reauth.py:314:            access token, new refresh token, expiration, the additional data
.venv\Lib\site-packages\google\oauth2\reauth.py:315:            returned by the token endpoint, and the rapt token.
.venv\Lib\site-packages\google\oauth2\reauth.py:318:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\reauth.py:325:        "refresh_token": refresh_token,
.venv\Lib\site-packages\google\oauth2\reauth.py:329:    if rapt_token:
.venv\Lib\site-packages\google\oauth2\reauth.py:330:        body["rapt"] = rapt_token
.venv\Lib\site-packages\google\oauth2\reauth.py:331:    metrics_header = {metrics.API_CLIENT_HEADER: metrics.token_request_user()}
.venv\Lib\site-packages\google\oauth2\reauth.py:333:    response_status_ok, response_data, retryable_error = _client._token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\reauth.py:334:        request, token_uri, body, headers=metrics_header
.venv\Lib\site-packages\google\oauth2\reauth.py:353:        rapt_token = get_rapt_token(
.venv\Lib\site-packages\google\oauth2\reauth.py:354:            request, client_id, client_secret, refresh_token, token_uri, scopes=scopes
.venv\Lib\site-packages\google\oauth2\reauth.py:356:        body["rapt"] = rapt_token
.venv\Lib\site-packages\google\oauth2\reauth.py:361:        ) = _client._token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\reauth.py:362:            request, token_uri, body, headers=metrics_header
.venv\Lib\site-packages\google\oauth2\reauth.py:367:    return _client._handle_refresh_grant_response(response_data, refresh_token) + (
.venv\Lib\site-packages\google\oauth2\reauth.py:368:        rapt_token,
.venv\Lib\site-packages\google\oauth2\service_account.py:15:"""Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0
.venv\Lib\site-packages\google\oauth2\service_account.py:39:This profile uses a JWT to acquire an OAuth 2.0 access token. The JWT is used
.venv\Lib\site-packages\google\oauth2\service_account.py:40:in place of the usual authorization token returned during the standard
.venv\Lib\site-packages\google\oauth2\service_account.py:42:the acquired access token is used as the bearer token when making requests
.venv\Lib\site-packages\google\oauth2\service_account.py:50:because the JWT credentials use the JWT directly as the bearer token. This
.venv\Lib\site-packages\google\oauth2\service_account.py:51:profile instead only uses the JWT to obtain an OAuth 2.0 access token. The
.venv\Lib\site-packages\google\oauth2\service_account.py:52:obtained OAuth 2.0 access token is used as the bearer token.
.venv\Lib\site-packages\google\oauth2\service_account.py:85:_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds
.venv\Lib\site-packages\google\oauth2\service_account.py:86:_GOOGLE_OAUTH2_TOKEN_ENDPOINT = "https://oauth2.googleapis.com/token"
.venv\Lib\site-packages\google\oauth2\service_account.py:96:    credentials.CredentialsWithTokenUri,
.venv\Lib\site-packages\google\oauth2\service_account.py:138:        token_uri,
.venv\Lib\site-packages\google\oauth2\service_account.py:157:            token_uri (str): The OAuth 2.0 Token URI.
.venv\Lib\site-packages\google\oauth2\service_account.py:170:                signed jwt is used for token refresh.
.venv\Lib\site-packages\google\oauth2\service_account.py:188:        self._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\service_account.py:222:            token_uri=info["token_uri"],
.venv\Lib\site-packages\google\oauth2\service_account.py:248:            info, require=["client_email", "token_uri"]
.venv\Lib\site-packages\google\oauth2\service_account.py:265:            filename, require=["client_email", "token_uri"]
.venv\Lib\site-packages\google\oauth2\service_account.py:294:            token_uri=self._token_uri,
.venv\Lib\site-packages\google\oauth2\service_account.py:383:    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
.venv\Lib\site-packages\google\oauth2\service_account.py:384:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\oauth2\service_account.py:386:        cred._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\service_account.py:399:        access token.
.venv\Lib\site-packages\google\oauth2\service_account.py:405:        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
.venv\Lib\site-packages\google\oauth2\service_account.py:413:            # The audience must be the auth token endpoint's URI
.venv\Lib\site-packages\google\oauth2\service_account.py:414:            "aud": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,
.venv\Lib\site-packages\google\oauth2\service_account.py:424:        token = jwt.encode(self._signer, payload)
.venv\Lib\site-packages\google\oauth2\service_account.py:426:        return token
.venv\Lib\site-packages\google\oauth2\service_account.py:439:    def _refresh_token(self, request):
.venv\Lib\site-packages\google\oauth2\service_account.py:455:            self.token = self._jwt_credentials.token.decode()
.venv\Lib\site-packages\google\oauth2\service_account.py:459:            access_token, expiry, _ = _client.jwt_grant(
.venv\Lib\site-packages\google\oauth2\service_account.py:460:                request, self._token_uri, assertion
.venv\Lib\site-packages\google\oauth2\service_account.py:462:            self.token = access_token
.venv\Lib\site-packages\google\oauth2\service_account.py:552:class IDTokenCredentials(
.venv\Lib\site-packages\google\oauth2\service_account.py:555:    credentials.CredentialsWithTokenUri,
.venv\Lib\site-packages\google\oauth2\service_account.py:557:    """Open ID Connect ID Token-based service account credentials.
.venv\Lib\site-packages\google\oauth2\service_account.py:560:    of using an OAuth 2.0 Access Token as the bearer token, they use an Open
.venv\Lib\site-packages\google\oauth2\service_account.py:561:    ID Connect ID Token as the bearer token. These credentials are useful when
.venv\Lib\site-packages\google\oauth2\service_account.py:562:    communicating to services that require ID Tokens and can not accept access
.venv\Lib\site-packages\google\oauth2\service_account.py:563:    tokens.
.venv\Lib\site-packages\google\oauth2\service_account.py:570:            service_account.IDTokenCredentials.from_service_account_file(
.venv\Lib\site-packages\google\oauth2\service_account.py:578:            service_account.IDTokenCredentials.from_service_account_info(
.venv\Lib\site-packages\google\oauth2\service_account.py:586:            service_account.IDTokenCredentials.from_service_account_file(
.venv\Lib\site-packages\google\oauth2\service_account.py:605:        token_uri,
.venv\Lib\site-packages\google\oauth2\service_account.py:615:            token_uri (str): The OAuth 2.0 Token URI.
.venv\Lib\site-packages\google\oauth2\service_account.py:617:                used when requesting the ID Token. The ID Token's ``aud`` claim
.venv\Lib\site-packages\google\oauth2\service_account.py:624:                token endponint is used for token refresh. Note that
.venv\Lib\site-packages\google\oauth2\service_account.py:625:                iam.serviceAccountTokenCreator role is required to use the IAM
.venv\Lib\site-packages\google\oauth2\service_account.py:633:        super(IDTokenCredentials, self).__init__()
.venv\Lib\site-packages\google\oauth2\service_account.py:636:        self._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\service_account.py:645:        self._iam_id_token_endpoint = iam._IAM_IDTOKEN_ENDPOINT.replace(
.venv\Lib\site-packages\google\oauth2\service_account.py:668:            google.auth.jwt.IDTokenCredentials: The constructed credentials.
.venv\Lib\site-packages\google\oauth2\service_account.py:674:        kwargs.setdefault("token_uri", info["token_uri"])
.venv\Lib\site-packages\google\oauth2\service_account.py:689:            google.auth.service_account.IDTokenCredentials: The constructed
.venv\Lib\site-packages\google\oauth2\service_account.py:696:            info, require=["client_email", "token_uri"]
.venv\Lib\site-packages\google\oauth2\service_account.py:709:            google.auth.service_account.IDTokenCredentials: The constructed
.venv\Lib\site-packages\google\oauth2\service_account.py:713:            filename, require=["client_email", "token_uri"]
.venv\Lib\site-packages\google\oauth2\service_account.py:721:            token_uri=self._token_uri,
.venv\Lib\site-packages\google\oauth2\service_account.py:737:            used when requesting the ID Token.
.venv\Lib\site-packages\google\oauth2\service_account.py:740:            google.auth.service_account.IDTokenCredentials: A new credentials
.venv\Lib\site-packages\google\oauth2\service_account.py:751:            use_iam_endpoint (bool): If True, IAM generateIdToken endpoint will
.venv\Lib\site-packages\google\oauth2\service_account.py:752:                be used instead of the token_uri. Note that
.venv\Lib\site-packages\google\oauth2\service_account.py:753:                iam.serviceAccountTokenCreator role is required to use the IAM
.venv\Lib\site-packages\google\oauth2\service_account.py:758:            google.auth.service_account.IDTokenCredentials: A new credentials
.venv\Lib\site-packages\google\oauth2\service_account.py:781:    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
.venv\Lib\site-packages\google\oauth2\service_account.py:782:    def with_token_uri(self, token_uri):
.venv\Lib\site-packages\google\oauth2\service_account.py:784:        cred._token_uri = token_uri
.venv\Lib\site-packages\google\oauth2\service_account.py:791:        ID token.
.venv\Lib\site-packages\google\oauth2\service_account.py:797:        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
.venv\Lib\site-packages\google\oauth2\service_account.py:805:            # The audience must be the auth token endpoint's URI
.venv\Lib\site-packages\google\oauth2\service_account.py:806:            "aud": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,
.venv\Lib\site-packages\google\oauth2\service_account.py:807:            # The target audience specifies which service the ID token is
.venv\Lib\site-packages\google\oauth2\service_account.py:814:        token = jwt.encode(self._signer, payload)
.venv\Lib\site-packages\google\oauth2\service_account.py:816:        return token
.venv\Lib\site-packages\google\oauth2\service_account.py:819:        """Use IAM generateIdToken endpoint to obtain an ID token.
.venv\Lib\site-packages\google\oauth2\service_account.py:826:        2. Next we use the self signed jwt as the access token, and make a POST
.venv\Lib\site-packages\google\oauth2\service_account.py:827:        request to IAM generateIdToken endpoint. The request body is:
.venv\Lib\site-packages\google\oauth2\service_account.py:834:        If the request is succesfully, it will return {"token":"the ID token"},
.venv\Lib\site-packages\google\oauth2\service_account.py:835:        and we can extract the ID token and compute its expiry.
.venv\Lib\site-packages\google\oauth2\service_account.py:844:        self.token, self.expiry = _client.call_iam_generate_id_token_endpoint(
.venv\Lib\site-packages\google\oauth2\service_account.py:846:            self._iam_id_token_endpoint,
.venv\Lib\site-packages\google\oauth2\service_account.py:849:            jwt_credentials.token.decode(),
.venv\Lib\site-packages\google\oauth2\service_account.py:859:            access_token, expiry, _ = _client.id_token_jwt_grant(
.venv\Lib\site-packages\google\oauth2\service_account.py:860:                request, self._token_uri, assertion
.venv\Lib\site-packages\google\oauth2\service_account.py:862:            self.token = access_token
.venv\Lib\site-packages\google\oauth2\sts.py:15:"""OAuth 2.0 Token Exchange Spec.
.venv\Lib\site-packages\google\oauth2\sts.py:17:This module defines a token exchange utility based on the `OAuth 2.0 Token
.venv\Lib\site-packages\google\oauth2\sts.py:19:for GCP access tokens in workload identity pools to access Google APIs.
.venv\Lib\site-packages\google\oauth2\sts.py:30:.. _OAuth 2.0 Token Exchange: https://tools.ietf.org/html/rfc8693
.venv\Lib\site-packages\google\oauth2\sts.py:45:    """Implements the OAuth 2.0 token exchange spec based on
.venv\Lib\site-packages\google\oauth2\sts.py:49:    def __init__(self, token_exchange_endpoint, client_authentication=None):
.venv\Lib\site-packages\google\oauth2\sts.py:53:            token_exchange_endpoint (str): The token exchange endpoint.
.venv\Lib\site-packages\google\oauth2\sts.py:58:        self._token_exchange_endpoint = token_exchange_endpoint
.venv\Lib\site-packages\google\oauth2\sts.py:74:            url=self._token_exchange_endpoint,
.venv\Lib\site-packages\google\oauth2\sts.py:95:    def exchange_token(
.venv\Lib\site-packages\google\oauth2\sts.py:99:        subject_token,
.venv\Lib\site-packages\google\oauth2\sts.py:100:        subject_token_type,
.venv\Lib\site-packages\google\oauth2\sts.py:104:        requested_token_type=None,
.venv\Lib\site-packages\google\oauth2\sts.py:105:        actor_token=None,
.venv\Lib\site-packages\google\oauth2\sts.py:106:        actor_token_type=None,
.venv\Lib\site-packages\google\oauth2\sts.py:110:        """Exchanges the provided token for another type of token based on the
.venv\Lib\site-packages\google\oauth2\sts.py:116:            grant_type (str): The OAuth 2.0 token exchange grant type.
.venv\Lib\site-packages\google\oauth2\sts.py:117:            subject_token (str): The OAuth 2.0 token exchange subject token.
.venv\Lib\site-packages\google\oauth2\sts.py:118:            subject_token_type (str): The OAuth 2.0 token exchange subject token type.
.venv\Lib\site-packages\google\oauth2\sts.py:119:            resource (Optional[str]): The optional OAuth 2.0 token exchange resource field.
.venv\Lib\site-packages\google\oauth2\sts.py:120:            audience (Optional[str]): The optional OAuth 2.0 token exchange audience field.
.venv\Lib\site-packages\google\oauth2\sts.py:122:            requested_token_type (Optional[str]): The optional OAuth 2.0 token exchange requested
.venv\Lib\site-packages\google\oauth2\sts.py:123:                token type.
.venv\Lib\site-packages\google\oauth2\sts.py:124:            actor_token (Optional[str]): The optional OAuth 2.0 token exchange actor token.
.venv\Lib\site-packages\google\oauth2\sts.py:125:            actor_token_type (Optional[str]): The optional OAuth 2.0 token exchange actor token type.
.venv\Lib\site-packages\google\oauth2\sts.py:129:                headers to pass to the token exchange endpoint.
.venv\Lib\site-packages\google\oauth2\sts.py:132:            Mapping[str, str]: The token exchange JSON-decoded response data containing
.venv\Lib\site-packages\google\oauth2\sts.py:133:                the requested token and its expiration time.
.venv\Lib\site-packages\google\oauth2\sts.py:136:            google.auth.exceptions.OAuthError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\sts.py:145:            "requested_token_type": requested_token_type,
.venv\Lib\site-packages\google\oauth2\sts.py:146:            "subject_token": subject_token,
.venv\Lib\site-packages\google\oauth2\sts.py:147:            "subject_token_type": subject_token_type,
.venv\Lib\site-packages\google\oauth2\sts.py:148:            "actor_token": actor_token,
.venv\Lib\site-packages\google\oauth2\sts.py:149:            "actor_token_type": actor_token_type,
.venv\Lib\site-packages\google\oauth2\sts.py:162:    def refresh_token(self, request, refresh_token):
.venv\Lib\site-packages\google\oauth2\sts.py:163:        """Exchanges a refresh token for an access token based on the
.venv\Lib\site-packages\google\oauth2\sts.py:169:            subject_token (str): The OAuth 2.0 refresh token.
.venv\Lib\site-packages\google\oauth2\sts.py:175:            {"grant_type": "refresh_token", "refresh_token": refresh_token},
.venv\Lib\site-packages\google\oauth2\utils.py:36:    * Ability to support bearer token authentication via request header.
.venv\Lib\site-packages\google\oauth2\utils.py:94:        self, headers, request_body=None, bearer_token=None
.venv\Lib\site-packages\google\oauth2\utils.py:104:            bearer_token (Optional[str]): The optional bearer token.
.venv\Lib\site-packages\google\oauth2\utils.py:107:        self._inject_authenticated_headers(headers, bearer_token)
.venv\Lib\site-packages\google\oauth2\utils.py:109:        if bearer_token is None:
.venv\Lib\site-packages\google\oauth2\utils.py:112:    def _inject_authenticated_headers(self, headers, bearer_token=None):
.venv\Lib\site-packages\google\oauth2\utils.py:113:        if bearer_token is not None:
.venv\Lib\site-packages\google\oauth2\utils.py:114:            headers["Authorization"] = "Bearer %s" % bearer_token
.venv\Lib\site-packages\google\oauth2\_client.py:18:token endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:20:For more information about the token endpoint, see
.venv\Lib\site-packages\google\oauth2\_client.py:42:_REFRESH_GRANT_TYPE = "refresh_token"
.venv\Lib\site-packages\google\oauth2\_client.py:136:def _token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\_client.py:138:    token_uri,
.venv\Lib\site-packages\google\oauth2\_client.py:140:    access_token=None,
.venv\Lib\site-packages\google\oauth2\_client.py:146:    """Makes a request to the OAuth 2.0 authorization server's token endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:152:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client.py:155:        access_token (Optional(str)): The access token needed to make the request.
.venv\Lib\site-packages\google\oauth2\_client.py:181:    if access_token:
.venv\Lib\site-packages\google\oauth2\_client.py:182:        headers_to_use["Authorization"] = "Bearer {}".format(access_token)
.venv\Lib\site-packages\google\oauth2\_client.py:193:            method="POST", url=token_uri, headers=headers_to_use, body=body, **kwargs
.venv\Lib\site-packages\google\oauth2\_client.py:220:def _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client.py:222:    token_uri,
.venv\Lib\site-packages\google\oauth2\_client.py:224:    access_token=None,
.venv\Lib\site-packages\google\oauth2\_client.py:230:    """Makes a request to the OAuth 2.0 authorization server's token endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:235:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client.py:238:        access_token (Optional(str)): The access token needed to make the request.
.venv\Lib\site-packages\google\oauth2\_client.py:255:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client.py:259:    response_status_ok, response_data, retryable_error = _token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\_client.py:261:        token_uri,
.venv\Lib\site-packages\google\oauth2\_client.py:263:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\_client.py:274:def jwt_grant(request, token_uri, assertion, can_retry=True):
.venv\Lib\site-packages\google\oauth2\_client.py:282:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client.py:288:        Tuple[str, Optional[datetime], Mapping[str, str]]: The access token,
.venv\Lib\site-packages\google\oauth2\_client.py:289:            expiration, and additional data returned by the token endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:292:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client.py:299:    response_data = _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client.py:301:        token_uri,
.venv\Lib\site-packages\google\oauth2\_client.py:305:            metrics.API_CLIENT_HEADER: metrics.token_request_access_token_sa_assertion()
.venv\Lib\site-packages\google\oauth2\_client.py:310:        access_token = response_data["access_token"]
.venv\Lib\site-packages\google\oauth2\_client.py:313:            "No access token in response.", response_data, retryable=False
.venv\Lib\site-packages\google\oauth2\_client.py:319:    return access_token, expiry, response_data
.venv\Lib\site-packages\google\oauth2\_client.py:322:def call_iam_generate_id_token_endpoint(
.venv\Lib\site-packages\google\oauth2\_client.py:324:    iam_id_token_endpoint,
.venv\Lib\site-packages\google\oauth2\_client.py:327:    access_token,
.venv\Lib\site-packages\google\oauth2\_client.py:330:    """Call iam.generateIdToken endpoint to get ID token.
.venv\Lib\site-packages\google\oauth2\_client.py:335:        iam_id_token_endpoint (str): The IAM ID token endpoint to use.
.venv\Lib\site-packages\google\oauth2\_client.py:337:            generateIdToken endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:338:        audience (str): The audience for the ID token.
.venv\Lib\site-packages\google\oauth2\_client.py:339:        access_token (str): The access token used to call the IAM endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:344:        Tuple[str, datetime]: The ID token and expiration.
.venv\Lib\site-packages\google\oauth2\_client.py:348:    response_data = _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client.py:350:        iam_id_token_endpoint.replace(
.venv\Lib\site-packages\google\oauth2\_client.py:354:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\_client.py:359:        id_token = response_data["token"]
.venv\Lib\site-packages\google\oauth2\_client.py:362:            "No ID token in response.", response_data, retryable=False
.venv\Lib\site-packages\google\oauth2\_client.py:366:    payload = jwt.decode(id_token, verify=False)
.venv\Lib\site-packages\google\oauth2\_client.py:369:    return id_token, expiry
.venv\Lib\site-packages\google\oauth2\_client.py:372:def id_token_jwt_grant(request, token_uri, assertion, can_retry=True):
.venv\Lib\site-packages\google\oauth2\_client.py:374:    requests an OpenID Connect ID Token instead of an access token.
.venv\Lib\site-packages\google\oauth2\_client.py:378:    that require ID Tokens instead of access tokens or JWT bearer tokens.
.venv\Lib\site-packages\google\oauth2\_client.py:383:        token_uri (str): The OAuth 2.0 authorization server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client.py:385:        assertion (str): JWT token signed by a service account. The token's
.venv\Lib\site-packages\google\oauth2\_client.py:391:            The (encoded) Open ID Connect ID Token, expiration, and additional
.venv\Lib\site-packages\google\oauth2\_client.py:395:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client.py:400:    response_data = _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client.py:402:        token_uri,
.venv\Lib\site-packages\google\oauth2\_client.py:406:            metrics.API_CLIENT_HEADER: metrics.token_request_id_token_sa_assertion()
.venv\Lib\site-packages\google\oauth2\_client.py:411:        id_token = response_data["id_token"]
.venv\Lib\site-packages\google\oauth2\_client.py:414:            "No ID token in response.", response_data, retryable=False
.venv\Lib\site-packages\google\oauth2\_client.py:418:    payload = jwt.decode(id_token, verify=False)
.venv\Lib\site-packages\google\oauth2\_client.py:421:    return id_token, expiry, response_data
.venv\Lib\site-packages\google\oauth2\_client.py:424:def _handle_refresh_grant_response(response_data, refresh_token):
.venv\Lib\site-packages\google\oauth2\_client.py:425:    """Extract tokens from refresh grant response.
.venv\Lib\site-packages\google\oauth2\_client.py:429:        refresh_token (str): Current refresh token.
.venv\Lib\site-packages\google\oauth2\_client.py:432:        Tuple[str, str, Optional[datetime], Mapping[str, str]]: The access token,
.venv\Lib\site-packages\google\oauth2\_client.py:433:            refresh token, expiration, and additional data returned by the token
.venv\Lib\site-packages\google\oauth2\_client.py:434:            endpoint. If response_data doesn't have refresh token, then the current
.venv\Lib\site-packages\google\oauth2\_client.py:435:            refresh token will be returned.
.venv\Lib\site-packages\google\oauth2\_client.py:438:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client.py:442:        access_token = response_data["access_token"]
.venv\Lib\site-packages\google\oauth2\_client.py:445:            "No access token in response.", response_data, retryable=False
.venv\Lib\site-packages\google\oauth2\_client.py:449:    refresh_token = response_data.get("refresh_token", refresh_token)
.venv\Lib\site-packages\google\oauth2\_client.py:452:    return access_token, refresh_token, expiry, response_data
.venv\Lib\site-packages\google\oauth2\_client.py:457:    token_uri,
.venv\Lib\site-packages\google\oauth2\_client.py:458:    refresh_token,
.venv\Lib\site-packages\google\oauth2\_client.py:462:    rapt_token=None,
.venv\Lib\site-packages\google\oauth2\_client.py:465:    """Implements the OAuth 2.0 refresh token grant.
.venv\Lib\site-packages\google\oauth2\_client.py:472:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client.py:474:        refresh_token (str): The refresh token to use to get a new access
.venv\Lib\site-packages\google\oauth2\_client.py:475:            token.
.venv\Lib\site-packages\google\oauth2\_client.py:479:            scopes must be authorized for the refresh token. Useful if refresh
.venv\Lib\site-packages\google\oauth2\_client.py:480:            token has a wild card scope (e.g.
.venv\Lib\site-packages\google\oauth2\_client.py:482:        rapt_token (Optional(str)): The reauth Proof Token.
.venv\Lib\site-packages\google\oauth2\_client.py:487:            token, new or current refresh token, expiration, and additional data
.venv\Lib\site-packages\google\oauth2\_client.py:488:            returned by the token endpoint.
.venv\Lib\site-packages\google\oauth2\_client.py:491:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client.py:500:        "refresh_token": refresh_token,
.venv\Lib\site-packages\google\oauth2\_client.py:504:    if rapt_token:
.venv\Lib\site-packages\google\oauth2\_client.py:505:        body["rapt"] = rapt_token
.venv\Lib\site-packages\google\oauth2\_client.py:507:    response_data = _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client.py:508:        request, token_uri, body, can_retry=can_retry
.venv\Lib\site-packages\google\oauth2\_client.py:510:    return _handle_refresh_grant_response(response_data, refresh_token)
.venv\Lib\site-packages\google\oauth2\_client.py:568:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client_async.py:18:token endpoint.
.venv\Lib\site-packages\google\oauth2\_client_async.py:20:For more information about the token endpoint, see
.venv\Lib\site-packages\google\oauth2\_client_async.py:37:async def _token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\_client_async.py:38:    request, token_uri, body, access_token=None, use_json=False, can_retry=True
.venv\Lib\site-packages\google\oauth2\_client_async.py:40:    """Makes a request to the OAuth 2.0 authorization server's token endpoint.
.venv\Lib\site-packages\google\oauth2\_client_async.py:46:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client_async.py:49:        access_token (Optional(str)): The access token needed to make the request.
.venv\Lib\site-packages\google\oauth2\_client_async.py:67:    if access_token:
.venv\Lib\site-packages\google\oauth2\_client_async.py:68:        headers["Authorization"] = "Bearer {}".format(access_token)
.venv\Lib\site-packages\google\oauth2\_client_async.py:76:            method="POST", url=token_uri, headers=headers, body=body
.venv\Lib\site-packages\google\oauth2\_client_async.py:106:async def _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client_async.py:107:    request, token_uri, body, access_token=None, use_json=False, can_retry=True
.venv\Lib\site-packages\google\oauth2\_client_async.py:109:    """Makes a request to the OAuth 2.0 authorization server's token endpoint.
.venv\Lib\site-packages\google\oauth2\_client_async.py:114:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client_async.py:117:        access_token (Optional(str)): The access token needed to make the request.
.venv\Lib\site-packages\google\oauth2\_client_async.py:126:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client_async.py:130:    response_status_ok, response_data, retryable_error = await _token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\_client_async.py:132:        token_uri,
.venv\Lib\site-packages\google\oauth2\_client_async.py:134:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\_client_async.py:143:async def jwt_grant(request, token_uri, assertion, can_retry=True):
.venv\Lib\site-packages\google\oauth2\_client_async.py:151:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client_async.py:157:        Tuple[str, Optional[datetime], Mapping[str, str]]: The access token,
.venv\Lib\site-packages\google\oauth2\_client_async.py:158:            expiration, and additional data returned by the token endpoint.
.venv\Lib\site-packages\google\oauth2\_client_async.py:161:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client_async.py:168:    response_data = await _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client_async.py:169:        request, token_uri, body, can_retry=can_retry
.venv\Lib\site-packages\google\oauth2\_client_async.py:173:        access_token = response_data["access_token"]
.venv\Lib\site-packages\google\oauth2\_client_async.py:176:            "No access token in response.", response_data, retryable=False
.venv\Lib\site-packages\google\oauth2\_client_async.py:182:    return access_token, expiry, response_data
.venv\Lib\site-packages\google\oauth2\_client_async.py:185:async def id_token_jwt_grant(request, token_uri, assertion, can_retry=True):
.venv\Lib\site-packages\google\oauth2\_client_async.py:187:    requests an OpenID Connect ID Token instead of an access token.
.venv\Lib\site-packages\google\oauth2\_client_async.py:191:    that require ID Tokens instead of access tokens or JWT bearer tokens.
.venv\Lib\site-packages\google\oauth2\_client_async.py:196:        token_uri (str): The OAuth 2.0 authorization server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client_async.py:198:        assertion (str): JWT token signed by a service account. The token's
.venv\Lib\site-packages\google\oauth2\_client_async.py:204:            The (encoded) Open ID Connect ID Token, expiration, and additional
.venv\Lib\site-packages\google\oauth2\_client_async.py:208:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client_async.py:213:    response_data = await _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client_async.py:214:        request, token_uri, body, can_retry=can_retry
.venv\Lib\site-packages\google\oauth2\_client_async.py:218:        id_token = response_data["id_token"]
.venv\Lib\site-packages\google\oauth2\_client_async.py:221:            "No ID token in response.", response_data, retryable=False
.venv\Lib\site-packages\google\oauth2\_client_async.py:225:    payload = jwt.decode(id_token, verify=False)
.venv\Lib\site-packages\google\oauth2\_client_async.py:228:    return id_token, expiry, response_data
.venv\Lib\site-packages\google\oauth2\_client_async.py:233:    token_uri,
.venv\Lib\site-packages\google\oauth2\_client_async.py:234:    refresh_token,
.venv\Lib\site-packages\google\oauth2\_client_async.py:238:    rapt_token=None,
.venv\Lib\site-packages\google\oauth2\_client_async.py:241:    """Implements the OAuth 2.0 refresh token grant.
.venv\Lib\site-packages\google\oauth2\_client_async.py:248:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_client_async.py:250:        refresh_token (str): The refresh token to use to get a new access
.venv\Lib\site-packages\google\oauth2\_client_async.py:251:            token.
.venv\Lib\site-packages\google\oauth2\_client_async.py:255:            scopes must be authorized for the refresh token. Useful if refresh
.venv\Lib\site-packages\google\oauth2\_client_async.py:256:            token has a wild card scope (e.g.
.venv\Lib\site-packages\google\oauth2\_client_async.py:258:        rapt_token (Optional(str)): The reauth Proof Token.
.venv\Lib\site-packages\google\oauth2\_client_async.py:263:            access token, new or current refresh token, expiration, and additional data
.venv\Lib\site-packages\google\oauth2\_client_async.py:264:            returned by the token endpoint.
.venv\Lib\site-packages\google\oauth2\_client_async.py:267:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_client_async.py:276:        "refresh_token": refresh_token,
.venv\Lib\site-packages\google\oauth2\_client_async.py:280:    if rapt_token:
.venv\Lib\site-packages\google\oauth2\_client_async.py:281:        body["rapt"] = rapt_token
.venv\Lib\site-packages\google\oauth2\_client_async.py:283:    response_data = await _token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_client_async.py:284:        request, token_uri, body, can_retry=can_retry
.venv\Lib\site-packages\google\oauth2\_client_async.py:286:    return client._handle_refresh_grant_response(response_data, refresh_token)
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:17:This module provides credentials based on OAuth 2.0 access and refresh tokens.
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:21:Specifically, this is intended to use access tokens acquired using the
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:22:`Authorization Code grant`_ and can refresh those tokens using a
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:23:optional `refresh token`_.
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:25:Obtaining the initial access and refresh token is outside of the scope of this
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:30:.. _refresh token: https://tools.ietf.org/html/rfc6749#section-6
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:42:    """Credentials using OAuth 2.0 access and refresh tokens.
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:53:            self._refresh_token is None
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:54:            or self._token_uri is None
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:60:                "refresh the access token. You must specify refresh_token, "
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:61:                "token_uri, client_id, and client_secret."
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:65:            access_token,
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:66:            refresh_token,
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:69:            rapt_token,
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:72:            self._token_uri,
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:73:            self._refresh_token,
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:77:            rapt_token=self._rapt_token,
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:81:        self.token = access_token
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:83:        self._refresh_token = refresh_token
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:84:        self._id_token = grant_response.get("id_token")
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:85:        self._rapt_token = rapt_token
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:106:class UserAccessTokenCredentials(oauth2_credentials.UserAccessTokenCredentials):
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:107:    """Access token credentials for user account.
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:109:    Obtain the access token for a given user account or the current active
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:110:    user account with the ``gcloud auth print-access-token`` command.
.venv\Lib\site-packages\google\oauth2\_credentials_async.py:113:        account (Optional[str]): Account to get the access token for. If not
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:15:"""Google ID Token helpers.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:17:Provides support for verifying `OpenID Connect ID Tokens`_, especially ones
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:20:To parse and verify an ID Token issued by Google's OAuth 2.0 authorization
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:21:server use :func:`verify_oauth2_token`. To verify an ID Token issued by
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:22:Firebase, use :func:`verify_firebase_token`.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:24:A general purpose ID Token verifier is available as :func:`verify_token`.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:28:    from google.oauth2 import _id_token_async
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:33:    id_info = await _id_token_async.verify_oauth2_token(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:34:        token, request, 'my-client-id.example.com')
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:56:.. _OpenID Connect ID Token:
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:57:    http://openid.net/specs/openid-connect-core-1_0.html#IDToken
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:69:from google.oauth2 import id_token as sync_id_token
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:99:async def verify_token(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:100:    id_token,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:103:    certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:106:    """Verifies an ID token and returns the decoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:109:        id_token (Union[str, bytes]): The encoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:112:        audience (str): The audience that this token is intended for. If None
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:115:            verify the token. This URL should return JSON in the format of
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:121:        Mapping[str, Any]: The decoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:126:        id_token,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:133:async def verify_oauth2_token(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:134:    id_token, request, audience=None, clock_skew_in_seconds=0
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:136:    """Verifies an ID Token issued by Google's OAuth 2.0 authorization server.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:139:        id_token (Union[str, bytes]): The encoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:142:        audience (str): The audience that this token is intended for. This is
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:149:        Mapping[str, Any]: The decoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:154:    idinfo = await verify_token(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:155:        id_token,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:158:        certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:162:    if idinfo["iss"] not in sync_id_token._GOOGLE_ISSUERS:
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:165:                sync_id_token._GOOGLE_ISSUERS
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:172:async def verify_firebase_token(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:173:    id_token, request, audience=None, clock_skew_in_seconds=0
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:175:    """Verifies an ID Token issued by Firebase Authentication.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:178:        id_token (Union[str, bytes]): The encoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:181:        audience (str): The audience that this token is intended for. This is
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:188:        Mapping[str, Any]: The decoded token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:190:    return await verify_token(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:191:        id_token,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:194:        certs_url=sync_id_token._GOOGLE_APIS_CERTS_URL,
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:199:async def fetch_id_token(request, audience):
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:200:    """Fetch the ID Token from the current environment.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:202:    This function acquires ID token from the environment in the following order.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:206:       to the path of a valid service account JSON file, then ID token is
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:209:       then the ID token are obtained from the metadata server.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:216:        import google.oauth2._id_token_async
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:222:        id_token = await google.oauth2._id_token_async.fetch_id_token(request, target_audience)
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:227:        audience (str): The audience that this ID token is intended for.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:230:        str: The ID token.
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:255:                    credentials = service_account.IDTokenCredentials.from_service_account_info(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:259:                    return credentials.token
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:267:    # 2. Try to fetch ID token from metada server if it exists. The code works
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:275:            credentials = compute_engine.IDTokenCredentials(
.venv\Lib\site-packages\google\oauth2\_id_token_async.py:279:            return credentials.token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:18:security token, etc.) while refreshing OAuth 2.0 credentials for a user.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:32:3. Refreshing the access token using the returned rapt token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:45:    request, supported_challenge_types, access_token, requested_scopes=None
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:54:        access_token (str): Access token with reauth scopes.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:64:    return await _client_async._token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:68:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:74:    request, session_id, challenge_id, client_input, access_token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:76:    """Attempt to refresh access token by sending next challenge result.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:85:        access_token (str): Access token with reauth scopes.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:97:    return await _client_async._token_endpoint_request(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:101:        access_token=access_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:106:async def _run_next_challenge(msg, request, access_token):
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:116:        access_token (str): reauth access token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:150:            access_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:155:async def _obtain_rapt(request, access_token, requested_scopes):
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:156:    """Given an http request method and reauth access token, get rapt token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:161:        access_token (str): reauth access token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:165:        str: The rapt token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:173:        access_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:178:        return msg["encodedProofOfReauthToken"]
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:197:        msg = await _run_next_challenge(msg, request, access_token)
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:200:            return msg["encodedProofOfReauthToken"]
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:203:    raise exceptions.ReauthFailError("Failed to obtain rapt token.")
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:206:async def get_rapt_token(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:207:    request, client_id, client_secret, refresh_token, token_uri, scopes=None
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:209:    """Given an http request method and refresh_token, get rapt token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:214:        client_id (str): client id to get access token for reauth scope.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:216:        refresh_token (str): refresh token to refresh access token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:217:        token_uri (str): uri to refresh access token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:221:        str: The rapt token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:227:    # Get access token for reauth.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:228:    access_token, _, _, _ = await _client_async.refresh_grant(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:232:        refresh_token=refresh_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:233:        token_uri=token_uri,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:237:    # Get rapt token from reauth API.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:238:    rapt_token = await _obtain_rapt(request, access_token, requested_scopes=scopes)
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:240:    return rapt_token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:245:    token_uri,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:246:    refresh_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:250:    rapt_token=None,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:258:        token_uri (str): The OAuth 2.0 authorizations server's token endpoint
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:260:        refresh_token (str): The refresh token to use to get a new access
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:261:            token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:265:            scopes must be authorized for the refresh token. Useful if refresh
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:266:            token has a wild card scope (e.g.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:268:        rapt_token (Optional(str)): The rapt token for reauth.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:275:            access token, new refresh token, expiration, the additional data
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:276:            returned by the token endpoint, and the rapt token.
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:279:        google.auth.exceptions.RefreshError: If the token endpoint returned
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:286:        "refresh_token": refresh_token,
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:290:    if rapt_token:
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:291:        body["rapt"] = rapt_token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:293:    response_status_ok, response_data, retryable_error = await _client_async._token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:294:        request, token_uri, body
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:311:        rapt_token = await get_rapt_token(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:312:            request, client_id, client_secret, refresh_token, token_uri, scopes=scopes
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:314:        body["rapt"] = rapt_token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:319:        ) = await _client_async._token_endpoint_request_no_throw(
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:320:            request, token_uri, body
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:326:        response_data, refresh_token
.venv\Lib\site-packages\google\oauth2\_reauth_async.py:328:    return refresh_response + (rapt_token,)
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:15:"""Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:72:        access_token, expiry, _ = await _client_async.jwt_grant(
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:73:            request, self._token_uri, assertion
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:75:        self.token = access_token
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:79:class IDTokenCredentials(
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:80:    service_account.IDTokenCredentials,
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:84:    """Open ID Connect ID Token-based service account credentials.
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:87:    of using an OAuth 2.0 Access Token as the bearer token, they use an Open
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:88:    ID Connect ID Token as the bearer token. These credentials are useful when
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:89:    communicating to services that require ID Tokens and can not accept access
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:90:    tokens.
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:97:            _service_account_async.IDTokenCredentials.from_service_account_file(
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:104:            _service_account_async.IDTokenCredentials.from_service_account_info(
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:111:            _service_account_async.IDTokenCredentials.from_service_account_file(
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:128:        access_token, expiry, _ = await _client_async.id_token_jwt_grant(
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:129:            request, self._token_uri, assertion
.venv\Lib\site-packages\google\oauth2\_service_account_async.py:131:        self.token = access_token
.venv\Lib\site-packages\google\protobuf\text_format.py:59:  """Thrown in case of text parsing or tokenizing error."""
.venv\Lib\site-packages\google\protobuf\text_format.py:877:    # Tokenize expects native str lines.
.venv\Lib\site-packages\google\protobuf\text_format.py:882:      tokenizer = Tokenizer(str_lines)
.venv\Lib\site-packages\google\protobuf\text_format.py:887:    while not tokenizer.AtEnd():
.venv\Lib\site-packages\google\protobuf\text_format.py:888:      self._MergeField(tokenizer, message)
.venv\Lib\site-packages\google\protobuf\text_format.py:890:  def _MergeField(self, tokenizer, message):
.venv\Lib\site-packages\google\protobuf\text_format.py:894:      tokenizer: A tokenizer to parse the field name and values.
.venv\Lib\site-packages\google\protobuf\text_format.py:902:        tokenizer.TryConsume('[')):
.venv\Lib\site-packages\google\protobuf\text_format.py:903:      type_url_prefix, packed_type_name = self._ConsumeAnyTypeUrl(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:904:      tokenizer.Consume(']')
.venv\Lib\site-packages\google\protobuf\text_format.py:905:      tokenizer.TryConsume(':')
.venv\Lib\site-packages\google\protobuf\text_format.py:906:      self._DetectSilentMarker(tokenizer, message_descriptor.full_name,
.venv\Lib\site-packages\google\protobuf\text_format.py:908:      if tokenizer.TryConsume('<'):
.venv\Lib\site-packages\google\protobuf\text_format.py:909:        expanded_any_end_token = '>'
.venv\Lib\site-packages\google\protobuf\text_format.py:911:        tokenizer.Consume('{')
.venv\Lib\site-packages\google\protobuf\text_format.py:912:        expanded_any_end_token = '}'
.venv\Lib\site-packages\google\protobuf\text_format.py:921:      while not tokenizer.TryConsume(expanded_any_end_token):
.venv\Lib\site-packages\google\protobuf\text_format.py:922:        if tokenizer.AtEnd():
.venv\Lib\site-packages\google\protobuf\text_format.py:923:          raise tokenizer.ParseErrorPreviousToken('Expected "%s".' %
.venv\Lib\site-packages\google\protobuf\text_format.py:924:                                                  (expanded_any_end_token,))
.venv\Lib\site-packages\google\protobuf\text_format.py:925:        self._MergeField(tokenizer, expanded_any_sub_message)
.venv\Lib\site-packages\google\protobuf\text_format.py:933:    if tokenizer.TryConsume('['):
.venv\Lib\site-packages\google\protobuf\text_format.py:934:      name = [tokenizer.ConsumeIdentifier()]
.venv\Lib\site-packages\google\protobuf\text_format.py:935:      while tokenizer.TryConsume('.'):
.venv\Lib\site-packages\google\protobuf\text_format.py:936:        name.append(tokenizer.ConsumeIdentifier())
.venv\Lib\site-packages\google\protobuf\text_format.py:940:        raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:950:          raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:957:        raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:961:      tokenizer.Consume(']')
.venv\Lib\site-packages\google\protobuf\text_format.py:964:      name = tokenizer.ConsumeIdentifierOrNumber()
.venv\Lib\site-packages\google\protobuf\text_format.py:984:        raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:995:          raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:1002:        tokenizer.TryConsume(':')
.venv\Lib\site-packages\google\protobuf\text_format.py:1003:        self._DetectSilentMarker(tokenizer, message_descriptor.full_name,
.venv\Lib\site-packages\google\protobuf\text_format.py:1007:        tokenizer.Consume(':')
.venv\Lib\site-packages\google\protobuf\text_format.py:1008:        self._DetectSilentMarker(tokenizer, message_descriptor.full_name,
.venv\Lib\site-packages\google\protobuf\text_format.py:1013:          tokenizer.TryConsume('[')):
.venv\Lib\site-packages\google\protobuf\text_format.py:1015:        if not tokenizer.TryConsume(']'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1017:            merger(tokenizer, message, field)
.venv\Lib\site-packages\google\protobuf\text_format.py:1018:            if tokenizer.TryConsume(']'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1020:            tokenizer.Consume(',')
.venv\Lib\site-packages\google\protobuf\text_format.py:1023:        merger(tokenizer, message, field)
.venv\Lib\site-packages\google\protobuf\text_format.py:1027:      self._SkipFieldContents(tokenizer, name, message_descriptor.full_name)
.venv\Lib\site-packages\google\protobuf\text_format.py:1031:    if not tokenizer.TryConsume(','):
.venv\Lib\site-packages\google\protobuf\text_format.py:1032:      tokenizer.TryConsume(';')
.venv\Lib\site-packages\google\protobuf\text_format.py:1037:  def _DetectSilentMarker(self, tokenizer, immediate_message_type, field_name):
.venv\Lib\site-packages\google\protobuf\text_format.py:1038:    if tokenizer.contains_silent_marker_before_current_token:
.venv\Lib\site-packages\google\protobuf\text_format.py:1041:  def _ConsumeAnyTypeUrl(self, tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1044:    prefix = [tokenizer.ConsumeIdentifier()]
.venv\Lib\site-packages\google\protobuf\text_format.py:1045:    tokenizer.Consume('.')
.venv\Lib\site-packages\google\protobuf\text_format.py:1046:    prefix.append(tokenizer.ConsumeIdentifier())
.venv\Lib\site-packages\google\protobuf\text_format.py:1047:    tokenizer.Consume('.')
.venv\Lib\site-packages\google\protobuf\text_format.py:1048:    prefix.append(tokenizer.ConsumeIdentifier())
.venv\Lib\site-packages\google\protobuf\text_format.py:1049:    tokenizer.Consume('/')
.venv\Lib\site-packages\google\protobuf\text_format.py:1051:    name = [tokenizer.ConsumeIdentifier()]
.venv\Lib\site-packages\google\protobuf\text_format.py:1052:    while tokenizer.TryConsume('.'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1053:      name.append(tokenizer.ConsumeIdentifier())
.venv\Lib\site-packages\google\protobuf\text_format.py:1056:  def _MergeMessageField(self, tokenizer, message, field):
.venv\Lib\site-packages\google\protobuf\text_format.py:1060:      tokenizer: A tokenizer to parse the field value.
.venv\Lib\site-packages\google\protobuf\text_format.py:1069:    if tokenizer.TryConsume('<'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1070:      end_token = '>'
.venv\Lib\site-packages\google\protobuf\text_format.py:1072:      tokenizer.Consume('{')
.venv\Lib\site-packages\google\protobuf\text_format.py:1073:      end_token = '}'
.venv\Lib\site-packages\google\protobuf\text_format.py:1086:          raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:1095:          raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:1101:    while not tokenizer.TryConsume(end_token):
.venv\Lib\site-packages\google\protobuf\text_format.py:1102:      if tokenizer.AtEnd():
.venv\Lib\site-packages\google\protobuf\text_format.py:1103:        raise tokenizer.ParseErrorPreviousToken('Expected "%s".' % (end_token,))
.venv\Lib\site-packages\google\protobuf\text_format.py:1104:      self._MergeField(tokenizer, sub_message)
.venv\Lib\site-packages\google\protobuf\text_format.py:1114:  def _MergeScalarField(self, tokenizer, message, field):
.venv\Lib\site-packages\google\protobuf\text_format.py:1118:      tokenizer: A tokenizer to parse the field value.
.venv\Lib\site-packages\google\protobuf\text_format.py:1132:      value = _ConsumeInt32(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1136:      value = _ConsumeInt64(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1139:      value = _ConsumeUint32(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1142:      value = _ConsumeUint64(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1145:      value = tokenizer.ConsumeFloat()
.venv\Lib\site-packages\google\protobuf\text_format.py:1147:      value = tokenizer.ConsumeBool()
.venv\Lib\site-packages\google\protobuf\text_format.py:1149:      value = tokenizer.ConsumeString()
.venv\Lib\site-packages\google\protobuf\text_format.py:1151:      value = tokenizer.ConsumeByteString()
.venv\Lib\site-packages\google\protobuf\text_format.py:1153:      value = tokenizer.ConsumeEnum(field)
.venv\Lib\site-packages\google\protobuf\text_format.py:1167:          raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:1185:          raise tokenizer.ParseErrorPreviousToken(
.venv\Lib\site-packages\google\protobuf\text_format.py:1191:  def _SkipFieldContents(self, tokenizer, field_name, immediate_message_type):
.venv\Lib\site-packages\google\protobuf\text_format.py:1195:      tokenizer: A tokenizer to parse the field name and values.
.venv\Lib\site-packages\google\protobuf\text_format.py:1206:    if tokenizer.TryConsume(
.venv\Lib\site-packages\google\protobuf\text_format.py:1207:        ':') and not tokenizer.LookingAt('{') and not tokenizer.LookingAt('<'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1208:      self._DetectSilentMarker(tokenizer, immediate_message_type, field_name)
.venv\Lib\site-packages\google\protobuf\text_format.py:1209:      if tokenizer.LookingAt('['):
.venv\Lib\site-packages\google\protobuf\text_format.py:1210:        self._SkipRepeatedFieldValue(tokenizer, immediate_message_type)
.venv\Lib\site-packages\google\protobuf\text_format.py:1212:        self._SkipFieldValue(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1214:      self._DetectSilentMarker(tokenizer, immediate_message_type, field_name)
.venv\Lib\site-packages\google\protobuf\text_format.py:1215:      self._SkipFieldMessage(tokenizer, immediate_message_type)
.venv\Lib\site-packages\google\protobuf\text_format.py:1217:  def _SkipField(self, tokenizer, immediate_message_type):
.venv\Lib\site-packages\google\protobuf\text_format.py:1221:      tokenizer: A tokenizer to parse the field name and values.
.venv\Lib\site-packages\google\protobuf\text_format.py:1226:    if tokenizer.TryConsume('['):
.venv\Lib\site-packages\google\protobuf\text_format.py:1228:      field_name += '[' + tokenizer.ConsumeIdentifier()
.venv\Lib\site-packages\google\protobuf\text_format.py:1230:      while tokenizer.TryConsume('.'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1231:        field_name += '.' + tokenizer.ConsumeIdentifier()
.venv\Lib\site-packages\google\protobuf\text_format.py:1234:      if num_identifiers == 3 and tokenizer.TryConsume('/'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1235:        field_name += '/' + tokenizer.ConsumeIdentifier()
.venv\Lib\site-packages\google\protobuf\text_format.py:1236:        while tokenizer.TryConsume('.'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1237:          field_name += '.' + tokenizer.ConsumeIdentifier()
.venv\Lib\site-packages\google\protobuf\text_format.py:1238:      tokenizer.Consume(']')
.venv\Lib\site-packages\google\protobuf\text_format.py:1241:      field_name += tokenizer.ConsumeIdentifierOrNumber()
.venv\Lib\site-packages\google\protobuf\text_format.py:1243:    self._SkipFieldContents(tokenizer, field_name, immediate_message_type)
.venv\Lib\site-packages\google\protobuf\text_format.py:1247:    if not tokenizer.TryConsume(','):
.venv\Lib\site-packages\google\protobuf\text_format.py:1248:      tokenizer.TryConsume(';')
.venv\Lib\site-packages\google\protobuf\text_format.py:1250:  def _SkipFieldMessage(self, tokenizer, immediate_message_type):
.venv\Lib\site-packages\google\protobuf\text_format.py:1254:      tokenizer: A tokenizer to parse the field name and values.
.venv\Lib\site-packages\google\protobuf\text_format.py:1258:    if tokenizer.TryConsume('<'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1261:      tokenizer.Consume('{')
.venv\Lib\site-packages\google\protobuf\text_format.py:1264:    while not tokenizer.LookingAt('>') and not tokenizer.LookingAt('}'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1265:      self._SkipField(tokenizer, immediate_message_type)
.venv\Lib\site-packages\google\protobuf\text_format.py:1267:    tokenizer.Consume(delimiter)
.venv\Lib\site-packages\google\protobuf\text_format.py:1269:  def _SkipFieldValue(self, tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1273:      tokenizer: A tokenizer to parse the field name and values.
.venv\Lib\site-packages\google\protobuf\text_format.py:1278:    if (not tokenizer.TryConsumeByteString()and
.venv\Lib\site-packages\google\protobuf\text_format.py:1279:        not tokenizer.TryConsumeIdentifier() and
.venv\Lib\site-packages\google\protobuf\text_format.py:1280:        not _TryConsumeInt64(tokenizer) and
.venv\Lib\site-packages\google\protobuf\text_format.py:1281:        not _TryConsumeUint64(tokenizer) and
.venv\Lib\site-packages\google\protobuf\text_format.py:1282:        not tokenizer.TryConsumeFloat()):
.venv\Lib\site-packages\google\protobuf\text_format.py:1283:      raise ParseError('Invalid field value: ' + tokenizer.token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1285:  def _SkipRepeatedFieldValue(self, tokenizer, immediate_message_type):
.venv\Lib\site-packages\google\protobuf\text_format.py:1289:      tokenizer: A tokenizer to parse the field value.
.venv\Lib\site-packages\google\protobuf\text_format.py:1291:    tokenizer.Consume('[')
.venv\Lib\site-packages\google\protobuf\text_format.py:1292:    if not tokenizer.TryConsume(']'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1294:        if tokenizer.LookingAt('<') or tokenizer.LookingAt('{'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1295:          self._SkipFieldMessage(tokenizer, immediate_message_type)
.venv\Lib\site-packages\google\protobuf\text_format.py:1297:          self._SkipFieldValue(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1298:        if tokenizer.TryConsume(']'):
.venv\Lib\site-packages\google\protobuf\text_format.py:1300:        tokenizer.Consume(',')
.venv\Lib\site-packages\google\protobuf\text_format.py:1303:class Tokenizer(object):
.venv\Lib\site-packages\google\protobuf\text_format.py:1304:  """Protocol buffer text representation tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1307:  meaningful tokens.
.venv\Lib\site-packages\google\protobuf\text_format.py:1315:  _TOKEN = re.compile('|'.join([
.venv\Lib\site-packages\google\protobuf\text_format.py:1331:    self._token_start = None
.venv\Lib\site-packages\google\protobuf\text_format.py:1332:    self.token = ''
.venv\Lib\site-packages\google\protobuf\text_format.py:1341:    self.contains_silent_marker_before_current_token = False
.venv\Lib\site-packages\google\protobuf\text_format.py:1344:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1346:  def LookingAt(self, token):
.venv\Lib\site-packages\google\protobuf\text_format.py:1347:    return self.token == token
.venv\Lib\site-packages\google\protobuf\text_format.py:1355:    return not self.token
.venv\Lib\site-packages\google\protobuf\text_format.py:1375:      self.contains_silent_marker_before_current_token = match.group(0) == (
.venv\Lib\site-packages\google\protobuf\text_format.py:1380:  def TryConsume(self, token):
.venv\Lib\site-packages\google\protobuf\text_format.py:1384:      token: Text to consume.
.venv\Lib\site-packages\google\protobuf\text_format.py:1389:    if self.token == token:
.venv\Lib\site-packages\google\protobuf\text_format.py:1390:      self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1394:  def Consume(self, token):
.venv\Lib\site-packages\google\protobuf\text_format.py:1398:      token: Text to consume.
.venv\Lib\site-packages\google\protobuf\text_format.py:1403:    if not self.TryConsume(token):
.venv\Lib\site-packages\google\protobuf\text_format.py:1404:      raise self.ParseError('Expected "%s".' % token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1407:    result = self.token
.venv\Lib\site-packages\google\protobuf\text_format.py:1410:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1416:    # Tokenizer initializes _previous_line and _previous_column to 0. As the
.venv\Lib\site-packages\google\protobuf\text_format.py:1417:    # tokenizer starts, it looks like there is a previous token on the line.
.venv\Lib\site-packages\google\protobuf\text_format.py:1423:    # A trailing comment is a comment on the same line than the previous token.
.venv\Lib\site-packages\google\protobuf\text_format.py:1445:    result = self.token
.venv\Lib\site-packages\google\protobuf\text_format.py:1448:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1467:    result = self.token
.venv\Lib\site-packages\google\protobuf\text_format.py:1470:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1490:      result = _ParseAbstractInteger(self.token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1493:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1513:      result = ParseFloat(self.token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1516:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1529:      result = ParseBool(self.token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1532:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1567:    while self.token and self.token[0] in _QUOTES:
.venv\Lib\site-packages\google\protobuf\text_format.py:1572:    """Consume one token of a string literal.
.venv\Lib\site-packages\google\protobuf\text_format.py:1575:    tokens which are automatically concatenated, like in C or Python.  This
.venv\Lib\site-packages\google\protobuf\text_format.py:1576:    method only consumes one token.
.venv\Lib\site-packages\google\protobuf\text_format.py:1579:      The token parsed.
.venv\Lib\site-packages\google\protobuf\text_format.py:1583:    text = self.token
.venv\Lib\site-packages\google\protobuf\text_format.py:1594:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1599:      result = ParseEnum(field, self.token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1602:    self.NextToken()
.venv\Lib\site-packages\google\protobuf\text_format.py:1605:  def ParseErrorPreviousToken(self, message):
.venv\Lib\site-packages\google\protobuf\text_format.py:1606:    """Creates and *returns* a ParseError for the previously read token.
.venv\Lib\site-packages\google\protobuf\text_format.py:1618:    """Creates and *returns* a ParseError for the current token."""
.venv\Lib\site-packages\google\protobuf\text_format.py:1625:  def NextToken(self):
.venv\Lib\site-packages\google\protobuf\text_format.py:1626:    """Reads the next meaningful token."""
.venv\Lib\site-packages\google\protobuf\text_format.py:1629:    self.contains_silent_marker_before_current_token = False
.venv\Lib\site-packages\google\protobuf\text_format.py:1631:    self._column += len(self.token)
.venv\Lib\site-packages\google\protobuf\text_format.py:1635:      self.token = ''
.venv\Lib\site-packages\google\protobuf\text_format.py:1638:    match = self._TOKEN.match(self._current_line, self._column)
.venv\Lib\site-packages\google\protobuf\text_format.py:1642:      token = match.group(0)
.venv\Lib\site-packages\google\protobuf\text_format.py:1643:      self.token = token
.venv\Lib\site-packages\google\protobuf\text_format.py:1645:      self.token = self._current_line[self._column]
.venv\Lib\site-packages\google\protobuf\text_format.py:1648:# TODO: Migrate violators to textformat_tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1649:_Tokenizer = Tokenizer  # pylint: disable=invalid-name
.venv\Lib\site-packages\google\protobuf\text_format.py:1652:def _ConsumeInt32(tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1653:  """Consumes a signed 32bit integer number from tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1656:    tokenizer: A tokenizer used to parse the number.
.venv\Lib\site-packages\google\protobuf\text_format.py:1664:  return _ConsumeInteger(tokenizer, is_signed=True, is_long=False)
.venv\Lib\site-packages\google\protobuf\text_format.py:1667:def _ConsumeUint32(tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1668:  """Consumes an unsigned 32bit integer number from tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1671:    tokenizer: A tokenizer used to parse the number.
.venv\Lib\site-packages\google\protobuf\text_format.py:1679:  return _ConsumeInteger(tokenizer, is_signed=False, is_long=False)
.venv\Lib\site-packages\google\protobuf\text_format.py:1682:def _TryConsumeInt64(tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1684:    _ConsumeInt64(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1690:def _ConsumeInt64(tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1691:  """Consumes a signed 32bit integer number from tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1694:    tokenizer: A tokenizer used to parse the number.
.venv\Lib\site-packages\google\protobuf\text_format.py:1702:  return _ConsumeInteger(tokenizer, is_signed=True, is_long=True)
.venv\Lib\site-packages\google\protobuf\text_format.py:1705:def _TryConsumeUint64(tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1707:    _ConsumeUint64(tokenizer)
.venv\Lib\site-packages\google\protobuf\text_format.py:1713:def _ConsumeUint64(tokenizer):
.venv\Lib\site-packages\google\protobuf\text_format.py:1714:  """Consumes an unsigned 64bit integer number from tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1717:    tokenizer: A tokenizer used to parse the number.
.venv\Lib\site-packages\google\protobuf\text_format.py:1725:  return _ConsumeInteger(tokenizer, is_signed=False, is_long=True)
.venv\Lib\site-packages\google\protobuf\text_format.py:1728:def _ConsumeInteger(tokenizer, is_signed=False, is_long=False):
.venv\Lib\site-packages\google\protobuf\text_format.py:1729:  """Consumes an integer number from tokenizer.
.venv\Lib\site-packages\google\protobuf\text_format.py:1732:    tokenizer: A tokenizer used to parse the number.
.venv\Lib\site-packages\google\protobuf\text_format.py:1743:    result = ParseInteger(tokenizer.token, is_signed=is_signed, is_long=is_long)
.venv\Lib\site-packages\google\protobuf\text_format.py:1745:    raise tokenizer.ParseError(str(e))
.venv\Lib\site-packages\google\protobuf\text_format.py:1746:  tokenizer.NextToken()
.venv\Lib\site-packages\google\type\phone_number_pb2.py:18:# source: google/type/phone_number.proto
.venv\Lib\site-packages\google\type\phone_number_pb2.py:32:    b'\n\x1egoogle/type/phone_number.proto\x12\x0bgoogle.type"\xab\x01\n\x0bPhoneNumber\x12\x15\n\x0b\x65\x31\x36\x34_number\x18\x01 \x01(\tH\x00\x12\x38\n\nshort_code\x18\x02 \x01(\x0b\x32".google.type.PhoneNumber.ShortCodeH\x00\x12\x11\n\textension\x18\x03 \x01(\t\x1a\x30\n\tShortCode\x12\x13\n\x0bregion_code\x18\x01 \x01(\t\x12\x0e\n\x06number\x18\x02 \x01(\tB\x06\n\x04kindBt\n\x0f\x63om.google.typeB\x10PhoneNumberProtoP\x01ZDgoogle.golang.org/genproto/googleapis/type/phone_number;phone_number\xf8\x01\x01\xa2\x02\x03GTPb\x06proto3'
.venv\Lib\site-packages\google\type\phone_number_pb2.py:38:    DESCRIPTOR, "google.type.phone_number_pb2", _globals
.venv\Lib\site-packages\google\type\phone_number_pb2.py:44:    ]._serialized_options = b"\n\017com.google.typeB\020PhoneNumberProtoP\001ZDgoogle.golang.org/genproto/googleapis/type/phone_number;phone_number\370\001\001\242\002\003GTP"
.venv\Lib\site-packages\grpc\beta\implementations.py:59:access_token_call_credentials = grpc.access_token_call_credentials
.venv\Lib\site-packages\grpc\_auth.py:24:    token: Optional[str],
.venv\Lib\site-packages\grpc\_auth.py:27:    metadata = (("authorization", "Bearer {}".format(token)),)
.venv\Lib\site-packages\grpc\_auth.py:41:        # additional_claims when getting a token
.venv\Lib\site-packages\grpc\_auth.py:44:            in inspect.getfullargspec(credentials.get_access_token).args
.venv\Lib\site-packages\grpc\_auth.py:54:                access_token = self._credentials.get_access_token(
.venv\Lib\site-packages\grpc\_auth.py:58:                ).access_token
.venv\Lib\site-packages\grpc\_auth.py:60:                access_token = self._credentials.get_access_token().access_token
.venv\Lib\site-packages\grpc\_auth.py:64:            _sign_request(callback, access_token, None)
.venv\Lib\site-packages\grpc\_auth.py:67:class AccessTokenAuthMetadataPlugin(grpc.AuthMetadataPlugin):
.venv\Lib\site-packages\grpc\_auth.py:68:    """Metadata wrapper for raw access token credentials."""
.venv\Lib\site-packages\grpc\_auth.py:70:    _access_token: str
.venv\Lib\site-packages\grpc\_auth.py:72:    def __init__(self, access_token: str):
.venv\Lib\site-packages\grpc\_auth.py:73:        self._access_token = access_token
.venv\Lib\site-packages\grpc\_auth.py:80:        _sign_request(callback, self._access_token, None)
.venv\Lib\site-packages\grpc\_server.py:64:_RECEIVE_CLOSE_ON_SERVER_TOKEN = "receive_close_on_server"
.venv\Lib\site-packages\grpc\_server.py:65:_SEND_INITIAL_METADATA_TOKEN = "send_initial_metadata"
.venv\Lib\site-packages\grpc\_server.py:66:_RECEIVE_MESSAGE_TOKEN = "receive_message"
.venv\Lib\site-packages\grpc\_server.py:67:_SEND_MESSAGE_TOKEN = "send_message"
.venv\Lib\site-packages\grpc\_server.py:68:_SEND_INITIAL_METADATA_AND_SEND_MESSAGE_TOKEN = (
.venv\Lib\site-packages\grpc\_server.py:71:_SEND_STATUS_FROM_SERVER_TOKEN = "send_status_from_server"
.venv\Lib\site-packages\grpc\_server.py:72:_SEND_INITIAL_METADATA_AND_SEND_STATUS_FROM_SERVER_TOKEN = (
.venv\Lib\site-packages\grpc\_server.py:226:    state: _RPCState, token: str
.venv\Lib\site-packages\grpc\_server.py:228:    state.due.remove(token)
.venv\Lib\site-packages\grpc\_server.py:237:def _send_status_from_server(state: _RPCState, token: str) -> ServerCallbackTag:
.venv\Lib\site-packages\grpc\_server.py:240:            return _possibly_finish_call(state, token)
.venv\Lib\site-packages\grpc\_server.py:288:            token = _SEND_INITIAL_METADATA_AND_SEND_STATUS_FROM_SERVER_TOKEN
.venv\Lib\site-packages\grpc\_server.py:298:            token = _SEND_STATUS_FROM_SERVER_TOKEN
.venv\Lib\site-packages\grpc\_server.py:300:            operations, _send_status_from_server(state, token)
.venv\Lib\site-packages\grpc\_server.py:303:        state.due.add(token)
.venv\Lib\site-packages\grpc\_server.py:314:            return _possibly_finish_call(state, _RECEIVE_CLOSE_ON_SERVER_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:331:                return _possibly_finish_call(state, _RECEIVE_MESSAGE_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:347:                return _possibly_finish_call(state, _RECEIVE_MESSAGE_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:355:            return _possibly_finish_call(state, _SEND_INITIAL_METADATA_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:360:def _send_message(state: _RPCState, token: str) -> ServerCallbackTag:
.venv\Lib\site-packages\grpc\_server.py:364:            return _possibly_finish_call(state, token)
.venv\Lib\site-packages\grpc\_server.py:444:                    self._state.due.add(_SEND_INITIAL_METADATA_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:519:            self._state.due.add(_RECEIVE_MESSAGE_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:526:            and _RECEIVE_MESSAGE_TOKEN not in self._state.due
.venv\Lib\site-packages\grpc\_server.py:571:                state.due.add(_RECEIVE_MESSAGE_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:734:                token = _SEND_INITIAL_METADATA_AND_SEND_MESSAGE_TOKEN
.venv\Lib\site-packages\grpc\_server.py:742:                token = _SEND_MESSAGE_TOKEN
.venv\Lib\site-packages\grpc\_server.py:744:                operations, _send_message(state, token)
.venv\Lib\site-packages\grpc\_server.py:746:            state.due.add(token)
.venv\Lib\site-packages\grpc\_server.py:750:                if token not in state.due:
.venv\Lib\site-packages\grpc\_server.py:779:                _send_status_from_server(state, _SEND_STATUS_FROM_SERVER_TOKEN),
.venv\Lib\site-packages\grpc\_server.py:783:            state.due.add(_SEND_STATUS_FROM_SERVER_TOKEN)
.venv\Lib\site-packages\grpc\_server.py:1054:        state.due.add(_RECEIVE_CLOSE_ON_SERVER_TOKEN)
.venv\Lib\site-packages\grpc\_simple_stubs.py:278:        grpc.access_token_call_credentials().
.venv\Lib\site-packages\grpc\_simple_stubs.py:369:        grpc.access_token_call_credentials().
.venv\Lib\site-packages\grpc\_simple_stubs.py:457:        grpc.access_token_call_credentials().
.venv\Lib\site-packages\grpc\_simple_stubs.py:548:        grpc.access_token_call_credentials().
.venv\Lib\site-packages\grpc\__init__.py:1761:def access_token_call_credentials(access_token):
.venv\Lib\site-packages\grpc\__init__.py:1762:    """Construct CallCredentials from an access token.
.venv\Lib\site-packages\grpc\__init__.py:1765:      access_token: A string to place directly in the http request
.venv\Lib\site-packages\grpc\__init__.py:1767:        "authorization: Bearer <access_token>".
.venv\Lib\site-packages\grpc\__init__.py:1776:        _auth.AccessTokenAuthMetadataPlugin(access_token), None
.venv\Lib\site-packages\grpc\__init__.py:2301:    "access_token_call_credentials",
.venv\Lib\site-packages\gunicorn\debug.py:15:_token_spliter = re.compile(r'\W+')
.venv\Lib\site-packages\gunicorn\debug.py:47:                tokens = _token_spliter.split(line)
.venv\Lib\site-packages\gunicorn\debug.py:48:                for tok in tokens:
.venv\Lib\site-packages\gunicorn\http\message.py:25:RFC9110_5_6_2_TOKEN_SPECIALS = r"!#$%&'*+-.^_`|~"
.venv\Lib\site-packages\gunicorn\http\message.py:26:TOKEN_RE = re.compile(r"[%s0-9a-zA-Z]+" % (re.escape(RFC9110_5_6_2_TOKEN_SPECIALS)))
.venv\Lib\site-packages\gunicorn\http\message.py:105:            if not TOKEN_RE.fullmatch(name):
.venv\Lib\site-packages\gunicorn\http\message.py:420:        # standard restriction: RFC9110 token
.venv\Lib\site-packages\gunicorn\http\message.py:421:        if not TOKEN_RE.fullmatch(self.method):
.venv\Lib\site-packages\gunicorn\http\wsgi.py:11:from gunicorn.http.message import TOKEN_RE
.venv\Lib\site-packages\gunicorn\http\wsgi.py:259:            if not TOKEN_RE.fullmatch(name):
.venv\Lib\site-packages\h11\_abnf.py:10:# https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#rule.token.separators
.venv\Lib\site-packages\h11\_abnf.py:11:#   token          = 1*tchar
.venv\Lib\site-packages\h11\_abnf.py:17:token = r"[-!#$%&'*+.^_`|~0-9a-zA-Z]+"
.venv\Lib\site-packages\h11\_abnf.py:20:#  field-name     = token
.venv\Lib\site-packages\h11\_abnf.py:21:field_name = token
.venv\Lib\site-packages\h11\_abnf.py:75:#   method         = token
.venv\Lib\site-packages\h11\_abnf.py:82:method = token
.venv\Lib\site-packages\h11\_receivebuffer.py:16:# - store bytearray, offset, how far we've searched for a separator token
.venv\Lib\site-packages\httpx\_auth.py:141:        token = b64encode(userpass).decode()
.venv\Lib\site-packages\httpx\_auth.py:142:        return f"Basic {token}"
.venv\Lib\site-packages\httpx\_auth.py:171:        token = b64encode(userpass).decode()
.venv\Lib\site-packages\httpx\_auth.py:172:        return f"Basic {token}"
.venv\Lib\site-packages\jinja2\environment.py:43:from .lexer import TokenStream
.venv\Lib\site-packages\jinja2\environment.py:631:        tokens as tuples in the form ``(lineno, token_type, value)``.
.venv\Lib\site-packages\jinja2\environment.py:641:            return self.lexer.tokeniter(source, name, filename)
.venv\Lib\site-packages\jinja2\environment.py:653:        because there you usually only want the actual source tokenized.
.venv\Lib\site-packages\jinja2\environment.py:661:    def _tokenize(
.venv\Lib\site-packages\jinja2\environment.py:667:    ) -> TokenStream:
.venv\Lib\site-packages\jinja2\environment.py:669:        for all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.
.venv\Lib\site-packages\jinja2\environment.py:672:        stream = self.lexer.tokenize(source, name, filename, state)
.venv\Lib\site-packages\jinja2\environment.py:677:            if not isinstance(stream, TokenStream):
.venv\Lib\site-packages\jinja2\environment.py:678:                stream = TokenStream(stream, name, filename)
.venv\Lib\site-packages\jinja2\ext.py:23:    from .lexer import Token
.venv\Lib\site-packages\jinja2\ext.py:24:    from .lexer import TokenStream
.venv\Lib\site-packages\jinja2\ext.py:109:        self, stream: "TokenStream"
.venv\Lib\site-packages\jinja2\ext.py:110:    ) -> t.Union["TokenStream", t.Iterable["Token"]]:
.venv\Lib\site-packages\jinja2\ext.py:111:        """It's passed a :class:`~jinja2.lexer.TokenStream` that can be used
.venv\Lib\site-packages\jinja2\ext.py:112:        to filter tokens returned.  This method has to return an iterable of
.venv\Lib\site-packages\jinja2\ext.py:113:        :class:`~jinja2.lexer.Token`\\s, but it doesn't have to return a
.venv\Lib\site-packages\jinja2\ext.py:114:        :class:`~jinja2.lexer.TokenStream`.
.venv\Lib\site-packages\jinja2\ext.py:120:        parser as first argument.  The token the parser stream is pointing at
.venv\Lib\site-packages\jinja2\ext.py:121:        is the name token that matched.  This method has to return one or a
.venv\Lib\site-packages\jinja2\ext.py:360:        context_token = parser.stream.next_if("string")
.venv\Lib\site-packages\jinja2\ext.py:362:        if context_token is not None:
.venv\Lib\site-packages\jinja2\ext.py:363:            context = context_token.value
.venv\Lib\site-packages\jinja2\ext.py:381:            token = parser.stream.expect("name")
.venv\Lib\site-packages\jinja2\ext.py:382:            if token.value in variables:
.venv\Lib\site-packages\jinja2\ext.py:384:                    f"translatable variable {token.value!r} defined twice.",
.venv\Lib\site-packages\jinja2\ext.py:385:                    token.lineno,
.venv\Lib\site-packages\jinja2\ext.py:392:                variables[token.value] = var = parser.parse_expression()
.venv\Lib\site-packages\jinja2\ext.py:393:            elif trimmed is None and token.value in ("trimmed", "notrimmed"):
.venv\Lib\site-packages\jinja2\ext.py:394:                trimmed = token.value == "trimmed"
.venv\Lib\site-packages\jinja2\ext.py:397:                variables[token.value] = var = nodes.Name(token.value, "load")
.venv\Lib\site-packages\jinja2\ext.py:402:                    variables[token.value] = plural_expr
.venv\Lib\site-packages\jinja2\ext.py:408:                num_called_num = token.value == "num"
.venv\Lib\site-packages\jinja2\ext.py:429:                token = parser.stream.expect("name")
.venv\Lib\site-packages\jinja2\ext.py:430:                if token.value not in variables:
.venv\Lib\site-packages\jinja2\ext.py:432:                        f"unknown variable {token.value!r} for pluralization",
.venv\Lib\site-packages\jinja2\ext.py:433:                        token.lineno,
.venv\Lib\site-packages\jinja2\ext.py:436:                plural_expr = variables[token.value]
.venv\Lib\site-packages\jinja2\ext.py:437:                num_called_num = token.value == "num"
.venv\Lib\site-packages\jinja2\ext.py:609:        token = next(parser.stream)
.venv\Lib\site-packages\jinja2\ext.py:610:        if token.value == "break":
.venv\Lib\site-packages\jinja2\ext.py:611:            return nodes.Break(lineno=token.lineno)
.venv\Lib\site-packages\jinja2\ext.py:612:        return nodes.Continue(lineno=token.lineno)
.venv\Lib\site-packages\jinja2\ext.py:735:    """Helper class to find comments in a token stream.  Can only
.venv\Lib\site-packages\jinja2\ext.py:742:        self, tokens: t.Sequence[t.Tuple[int, str, str]], comment_tags: t.Sequence[str]
.venv\Lib\site-packages\jinja2\ext.py:744:        self.tokens = tokens
.venv\Lib\site-packages\jinja2\ext.py:751:            for _, token_type, token_value in reversed(
.venv\Lib\site-packages\jinja2\ext.py:752:                self.tokens[self.offset : offset]
.venv\Lib\site-packages\jinja2\ext.py:754:                if token_type in ("comment", "linecomment"):
.venv\Lib\site-packages\jinja2\ext.py:756:                        prefix, comment = token_value.split(None, 1)
.venv\Lib\site-packages\jinja2\ext.py:768:        for idx, (token_lineno, _, _) in enumerate(self.tokens[self.offset :]):
.venv\Lib\site-packages\jinja2\ext.py:769:            if token_lineno > lineno:
.venv\Lib\site-packages\jinja2\ext.py:771:        return self.find_backwards(len(self.tokens))
.venv\Lib\site-packages\jinja2\ext.py:854:        tokens = list(environment.lex(environment.preprocess(source)))
.venv\Lib\site-packages\jinja2\ext.py:861:    finder = _CommentFinder(tokens, comment_tags)
.venv\Lib\site-packages\jinja2\lexer.py:62:# internal the tokens and keep references to them
.venv\Lib\site-packages\jinja2\lexer.py:63:TOKEN_ADD = intern("add")
.venv\Lib\site-packages\jinja2\lexer.py:64:TOKEN_ASSIGN = intern("assign")
.venv\Lib\site-packages\jinja2\lexer.py:65:TOKEN_COLON = intern("colon")
.venv\Lib\site-packages\jinja2\lexer.py:66:TOKEN_COMMA = intern("comma")
.venv\Lib\site-packages\jinja2\lexer.py:67:TOKEN_DIV = intern("div")
.venv\Lib\site-packages\jinja2\lexer.py:68:TOKEN_DOT = intern("dot")
.venv\Lib\site-packages\jinja2\lexer.py:69:TOKEN_EQ = intern("eq")
.venv\Lib\site-packages\jinja2\lexer.py:70:TOKEN_FLOORDIV = intern("floordiv")
.venv\Lib\site-packages\jinja2\lexer.py:71:TOKEN_GT = intern("gt")
.venv\Lib\site-packages\jinja2\lexer.py:72:TOKEN_GTEQ = intern("gteq")
.venv\Lib\site-packages\jinja2\lexer.py:73:TOKEN_LBRACE = intern("lbrace")
.venv\Lib\site-packages\jinja2\lexer.py:74:TOKEN_LBRACKET = intern("lbracket")
.venv\Lib\site-packages\jinja2\lexer.py:75:TOKEN_LPAREN = intern("lparen")
.venv\Lib\site-packages\jinja2\lexer.py:76:TOKEN_LT = intern("lt")
.venv\Lib\site-packages\jinja2\lexer.py:77:TOKEN_LTEQ = intern("lteq")
.venv\Lib\site-packages\jinja2\lexer.py:78:TOKEN_MOD = intern("mod")
.venv\Lib\site-packages\jinja2\lexer.py:79:TOKEN_MUL = intern("mul")
.venv\Lib\site-packages\jinja2\lexer.py:80:TOKEN_NE = intern("ne")
.venv\Lib\site-packages\jinja2\lexer.py:81:TOKEN_PIPE = intern("pipe")
.venv\Lib\site-packages\jinja2\lexer.py:82:TOKEN_POW = intern("pow")
.venv\Lib\site-packages\jinja2\lexer.py:83:TOKEN_RBRACE = intern("rbrace")
.venv\Lib\site-packages\jinja2\lexer.py:84:TOKEN_RBRACKET = intern("rbracket")
.venv\Lib\site-packages\jinja2\lexer.py:85:TOKEN_RPAREN = intern("rparen")
.venv\Lib\site-packages\jinja2\lexer.py:86:TOKEN_SEMICOLON = intern("semicolon")
.venv\Lib\site-packages\jinja2\lexer.py:87:TOKEN_SUB = intern("sub")
.venv\Lib\site-packages\jinja2\lexer.py:88:TOKEN_TILDE = intern("tilde")
.venv\Lib\site-packages\jinja2\lexer.py:89:TOKEN_WHITESPACE = intern("whitespace")
.venv\Lib\site-packages\jinja2\lexer.py:90:TOKEN_FLOAT = intern("float")
.venv\Lib\site-packages\jinja2\lexer.py:91:TOKEN_INTEGER = intern("integer")
.venv\Lib\site-packages\jinja2\lexer.py:92:TOKEN_NAME = intern("name")
.venv\Lib\site-packages\jinja2\lexer.py:93:TOKEN_STRING = intern("string")
.venv\Lib\site-packages\jinja2\lexer.py:94:TOKEN_OPERATOR = intern("operator")
.venv\Lib\site-packages\jinja2\lexer.py:95:TOKEN_BLOCK_BEGIN = intern("block_begin")
.venv\Lib\site-packages\jinja2\lexer.py:96:TOKEN_BLOCK_END = intern("block_end")
.venv\Lib\site-packages\jinja2\lexer.py:97:TOKEN_VARIABLE_BEGIN = intern("variable_begin")
.venv\Lib\site-packages\jinja2\lexer.py:98:TOKEN_VARIABLE_END = intern("variable_end")
.venv\Lib\site-packages\jinja2\lexer.py:99:TOKEN_RAW_BEGIN = intern("raw_begin")
.venv\Lib\site-packages\jinja2\lexer.py:100:TOKEN_RAW_END = intern("raw_end")
.venv\Lib\site-packages\jinja2\lexer.py:101:TOKEN_COMMENT_BEGIN = intern("comment_begin")
.venv\Lib\site-packages\jinja2\lexer.py:102:TOKEN_COMMENT_END = intern("comment_end")
.venv\Lib\site-packages\jinja2\lexer.py:103:TOKEN_COMMENT = intern("comment")
.venv\Lib\site-packages\jinja2\lexer.py:104:TOKEN_LINESTATEMENT_BEGIN = intern("linestatement_begin")
.venv\Lib\site-packages\jinja2\lexer.py:105:TOKEN_LINESTATEMENT_END = intern("linestatement_end")
.venv\Lib\site-packages\jinja2\lexer.py:106:TOKEN_LINECOMMENT_BEGIN = intern("linecomment_begin")
.venv\Lib\site-packages\jinja2\lexer.py:107:TOKEN_LINECOMMENT_END = intern("linecomment_end")
.venv\Lib\site-packages\jinja2\lexer.py:108:TOKEN_LINECOMMENT = intern("linecomment")
.venv\Lib\site-packages\jinja2\lexer.py:109:TOKEN_DATA = intern("data")
.venv\Lib\site-packages\jinja2\lexer.py:110:TOKEN_INITIAL = intern("initial")
.venv\Lib\site-packages\jinja2\lexer.py:111:TOKEN_EOF = intern("eof")
.venv\Lib\site-packages\jinja2\lexer.py:113:# bind operators to token types
.venv\Lib\site-packages\jinja2\lexer.py:115:    "+": TOKEN_ADD,
.venv\Lib\site-packages\jinja2\lexer.py:116:    "-": TOKEN_SUB,
.venv\Lib\site-packages\jinja2\lexer.py:117:    "/": TOKEN_DIV,
.venv\Lib\site-packages\jinja2\lexer.py:118:    "//": TOKEN_FLOORDIV,
.venv\Lib\site-packages\jinja2\lexer.py:119:    "*": TOKEN_MUL,
.venv\Lib\site-packages\jinja2\lexer.py:120:    "%": TOKEN_MOD,
.venv\Lib\site-packages\jinja2\lexer.py:121:    "**": TOKEN_POW,
.venv\Lib\site-packages\jinja2\lexer.py:122:    "~": TOKEN_TILDE,
.venv\Lib\site-packages\jinja2\lexer.py:123:    "[": TOKEN_LBRACKET,
.venv\Lib\site-packages\jinja2\lexer.py:124:    "]": TOKEN_RBRACKET,
.venv\Lib\site-packages\jinja2\lexer.py:125:    "(": TOKEN_LPAREN,
.venv\Lib\site-packages\jinja2\lexer.py:126:    ")": TOKEN_RPAREN,
.venv\Lib\site-packages\jinja2\lexer.py:127:    "{": TOKEN_LBRACE,
.venv\Lib\site-packages\jinja2\lexer.py:128:    "}": TOKEN_RBRACE,
.venv\Lib\site-packages\jinja2\lexer.py:129:    "==": TOKEN_EQ,
.venv\Lib\site-packages\jinja2\lexer.py:130:    "!=": TOKEN_NE,
.venv\Lib\site-packages\jinja2\lexer.py:131:    ">": TOKEN_GT,
.venv\Lib\site-packages\jinja2\lexer.py:132:    ">=": TOKEN_GTEQ,
.venv\Lib\site-packages\jinja2\lexer.py:133:    "<": TOKEN_LT,
.venv\Lib\site-packages\jinja2\lexer.py:134:    "<=": TOKEN_LTEQ,
.venv\Lib\site-packages\jinja2\lexer.py:135:    "=": TOKEN_ASSIGN,
.venv\Lib\site-packages\jinja2\lexer.py:136:    ".": TOKEN_DOT,
.venv\Lib\site-packages\jinja2\lexer.py:137:    ":": TOKEN_COLON,
.venv\Lib\site-packages\jinja2\lexer.py:138:    "|": TOKEN_PIPE,
.venv\Lib\site-packages\jinja2\lexer.py:139:    ",": TOKEN_COMMA,
.venv\Lib\site-packages\jinja2\lexer.py:140:    ";": TOKEN_SEMICOLON,
.venv\Lib\site-packages\jinja2\lexer.py:149:ignored_tokens = frozenset(
.venv\Lib\site-packages\jinja2\lexer.py:151:        TOKEN_COMMENT_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:152:        TOKEN_COMMENT,
.venv\Lib\site-packages\jinja2\lexer.py:153:        TOKEN_COMMENT_END,
.venv\Lib\site-packages\jinja2\lexer.py:154:        TOKEN_WHITESPACE,
.venv\Lib\site-packages\jinja2\lexer.py:155:        TOKEN_LINECOMMENT_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:156:        TOKEN_LINECOMMENT_END,
.venv\Lib\site-packages\jinja2\lexer.py:157:        TOKEN_LINECOMMENT,
.venv\Lib\site-packages\jinja2\lexer.py:161:    [TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT, TOKEN_LINECOMMENT]
.venv\Lib\site-packages\jinja2\lexer.py:165:def _describe_token_type(token_type: str) -> str:
.venv\Lib\site-packages\jinja2\lexer.py:166:    if token_type in reverse_operators:
.venv\Lib\site-packages\jinja2\lexer.py:167:        return reverse_operators[token_type]
.venv\Lib\site-packages\jinja2\lexer.py:170:        TOKEN_COMMENT_BEGIN: "begin of comment",
.venv\Lib\site-packages\jinja2\lexer.py:171:        TOKEN_COMMENT_END: "end of comment",
.venv\Lib\site-packages\jinja2\lexer.py:172:        TOKEN_COMMENT: "comment",
.venv\Lib\site-packages\jinja2\lexer.py:173:        TOKEN_LINECOMMENT: "comment",
.venv\Lib\site-packages\jinja2\lexer.py:174:        TOKEN_BLOCK_BEGIN: "begin of statement block",
.venv\Lib\site-packages\jinja2\lexer.py:175:        TOKEN_BLOCK_END: "end of statement block",
.venv\Lib\site-packages\jinja2\lexer.py:176:        TOKEN_VARIABLE_BEGIN: "begin of print statement",
.venv\Lib\site-packages\jinja2\lexer.py:177:        TOKEN_VARIABLE_END: "end of print statement",
.venv\Lib\site-packages\jinja2\lexer.py:178:        TOKEN_LINESTATEMENT_BEGIN: "begin of line statement",
.venv\Lib\site-packages\jinja2\lexer.py:179:        TOKEN_LINESTATEMENT_END: "end of line statement",
.venv\Lib\site-packages\jinja2\lexer.py:180:        TOKEN_DATA: "template data / text",
.venv\Lib\site-packages\jinja2\lexer.py:181:        TOKEN_EOF: "end of template",
.venv\Lib\site-packages\jinja2\lexer.py:182:    }.get(token_type, token_type)
.venv\Lib\site-packages\jinja2\lexer.py:185:def describe_token(token: "Token") -> str:
.venv\Lib\site-packages\jinja2\lexer.py:186:    """Returns a description of the token."""
.venv\Lib\site-packages\jinja2\lexer.py:187:    if token.type == TOKEN_NAME:
.venv\Lib\site-packages\jinja2\lexer.py:188:        return token.value
.venv\Lib\site-packages\jinja2\lexer.py:190:    return _describe_token_type(token.type)
.venv\Lib\site-packages\jinja2\lexer.py:193:def describe_token_expr(expr: str) -> str:
.venv\Lib\site-packages\jinja2\lexer.py:194:    """Like `describe_token` but for token expressions."""
.venv\Lib\site-packages\jinja2\lexer.py:198:        if type == TOKEN_NAME:
.venv\Lib\site-packages\jinja2\lexer.py:203:    return _describe_token_type(type)
.venv\Lib\site-packages\jinja2\lexer.py:219:            TOKEN_COMMENT_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:224:            TOKEN_BLOCK_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:229:            TOKEN_VARIABLE_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:238:                TOKEN_LINESTATEMENT_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:246:                TOKEN_LINECOMMENT_BEGIN,
.venv\Lib\site-packages\jinja2\lexer.py:269:class Token(t.NamedTuple):
.venv\Lib\site-packages\jinja2\lexer.py:275:        return describe_token(self)
.venv\Lib\site-packages\jinja2\lexer.py:278:        """Test a token against a token expression.  This can either be a
.venv\Lib\site-packages\jinja2\lexer.py:279:        token type or ``'token_type:token_value'``.  This can only test
.venv\Lib\site-packages\jinja2\lexer.py:293:        """Test against multiple token expressions."""
.venv\Lib\site-packages\jinja2\lexer.py:297:class TokenStreamIterator:
.venv\Lib\site-packages\jinja2\lexer.py:298:    """The iterator for tokenstreams.  Iterate over the stream
.venv\Lib\site-packages\jinja2\lexer.py:299:    until the eof token is reached.
.venv\Lib\site-packages\jinja2\lexer.py:302:    def __init__(self, stream: "TokenStream") -> None:
.venv\Lib\site-packages\jinja2\lexer.py:305:    def __iter__(self) -> "TokenStreamIterator":
.venv\Lib\site-packages\jinja2\lexer.py:308:    def __next__(self) -> Token:
.venv\Lib\site-packages\jinja2\lexer.py:309:        token = self.stream.current
.venv\Lib\site-packages\jinja2\lexer.py:311:        if token.type is TOKEN_EOF:
.venv\Lib\site-packages\jinja2\lexer.py:316:        return token
.venv\Lib\site-packages\jinja2\lexer.py:319:class TokenStream:
.venv\Lib\site-packages\jinja2\lexer.py:320:    """A token stream is an iterable that yields :class:`Token`\\s.  The
.venv\Lib\site-packages\jinja2\lexer.py:322:    one token ahead.  The current active token is stored as :attr:`current`.
.venv\Lib\site-packages\jinja2\lexer.py:327:        generator: t.Iterable[Token],
.venv\Lib\site-packages\jinja2\lexer.py:332:        self._pushed: te.Deque[Token] = deque()
.venv\Lib\site-packages\jinja2\lexer.py:336:        self.current = Token(1, TOKEN_INITIAL, "")
.venv\Lib\site-packages\jinja2\lexer.py:339:    def __iter__(self) -> TokenStreamIterator:
.venv\Lib\site-packages\jinja2\lexer.py:340:        return TokenStreamIterator(self)
.venv\Lib\site-packages\jinja2\lexer.py:343:        return bool(self._pushed) or self.current.type is not TOKEN_EOF
.venv\Lib\site-packages\jinja2\lexer.py:350:    def push(self, token: Token) -> None:
.venv\Lib\site-packages\jinja2\lexer.py:351:        """Push a token back to the stream."""
.venv\Lib\site-packages\jinja2\lexer.py:352:        self._pushed.append(token)
.venv\Lib\site-packages\jinja2\lexer.py:354:    def look(self) -> Token:
.venv\Lib\site-packages\jinja2\lexer.py:355:        """Look at the next token."""
.venv\Lib\site-packages\jinja2\lexer.py:356:        old_token = next(self)
.venv\Lib\site-packages\jinja2\lexer.py:359:        self.current = old_token
.venv\Lib\site-packages\jinja2\lexer.py:363:        """Got n tokens ahead."""
.venv\Lib\site-packages\jinja2\lexer.py:367:    def next_if(self, expr: str) -> t.Optional[Token]:
.venv\Lib\site-packages\jinja2\lexer.py:368:        """Perform the token test and return the token if it matched.
.venv\Lib\site-packages\jinja2\lexer.py:380:    def __next__(self) -> Token:
.venv\Lib\site-packages\jinja2\lexer.py:381:        """Go one token ahead and return the old one.
.venv\Lib\site-packages\jinja2\lexer.py:389:        elif self.current.type is not TOKEN_EOF:
.venv\Lib\site-packages\jinja2\lexer.py:399:        self.current = Token(self.current.lineno, TOKEN_EOF, "")
.venv\Lib\site-packages\jinja2\lexer.py:403:    def expect(self, expr: str) -> Token:
.venv\Lib\site-packages\jinja2\lexer.py:404:        """Expect a given token type and return it.  This accepts the same
.venv\Lib\site-packages\jinja2\lexer.py:405:        argument as :meth:`jinja2.lexer.Token.test`.
.venv\Lib\site-packages\jinja2\lexer.py:408:            expr = describe_token_expr(expr)
.venv\Lib\site-packages\jinja2\lexer.py:410:            if self.current.type is TOKEN_EOF:
.venv\Lib\site-packages\jinja2\lexer.py:419:                f"expected token {expr!r}, got {describe_token(self.current)!r}",
.venv\Lib\site-packages\jinja2\lexer.py:467:    tokens: t.Union[str, t.Tuple[str, ...], t.Tuple[Failure]]
.venv\Lib\site-packages\jinja2\lexer.py:488:            _Rule(whitespace_re, TOKEN_WHITESPACE, None),
.venv\Lib\site-packages\jinja2\lexer.py:489:            _Rule(float_re, TOKEN_FLOAT, None),
.venv\Lib\site-packages\jinja2\lexer.py:490:            _Rule(integer_re, TOKEN_INTEGER, None),
.venv\Lib\site-packages\jinja2\lexer.py:491:            _Rule(name_re, TOKEN_NAME, None),
.venv\Lib\site-packages\jinja2\lexer.py:492:            _Rule(string_re, TOKEN_STRING, None),
.venv\Lib\site-packages\jinja2\lexer.py:493:            _Rule(operator_re, TOKEN_OPERATOR, None),
.venv\Lib\site-packages\jinja2\lexer.py:531:                    OptionalLStrip(TOKEN_DATA, "#bygroup"),  # type: ignore
.venv\Lib\site-packages\jinja2\lexer.py:535:                _Rule(c(".+"), TOKEN_DATA, None),
.venv\Lib\site-packages\jinja2\lexer.py:538:            TOKEN_COMMENT_BEGIN: [
.venv\Lib\site-packages\jinja2\lexer.py:544:                    (TOKEN_COMMENT, TOKEN_COMMENT_END),
.venv\Lib\site-packages\jinja2\lexer.py:550:            TOKEN_BLOCK_BEGIN: [
.venv\Lib\site-packages\jinja2\lexer.py:556:                    TOKEN_BLOCK_END,
.venv\Lib\site-packages\jinja2\lexer.py:562:            TOKEN_VARIABLE_BEGIN: [
.venv\Lib\site-packages\jinja2\lexer.py:565:                    TOKEN_VARIABLE_END,
.venv\Lib\site-packages\jinja2\lexer.py:571:            TOKEN_RAW_BEGIN: [
.venv\Lib\site-packages\jinja2\lexer.py:578:                    OptionalLStrip(TOKEN_DATA, TOKEN_RAW_END),  # type: ignore
.venv\Lib\site-packages\jinja2\lexer.py:584:            TOKEN_LINESTATEMENT_BEGIN: [
.venv\Lib\site-packages\jinja2\lexer.py:585:                _Rule(c(r"\s*(\n|$)"), TOKEN_LINESTATEMENT_END, "#pop")
.venv\Lib\site-packages\jinja2\lexer.py:589:            TOKEN_LINECOMMENT_BEGIN: [
.venv\Lib\site-packages\jinja2\lexer.py:592:                    (TOKEN_LINECOMMENT, TOKEN_LINECOMMENT_END),
.venv\Lib\site-packages\jinja2\lexer.py:604:    def tokenize(
.venv\Lib\site-packages\jinja2\lexer.py:610:    ) -> TokenStream:
.venv\Lib\site-packages\jinja2\lexer.py:611:        """Calls tokeniter + tokenize and wraps it in a token stream."""
.venv\Lib\site-packages\jinja2\lexer.py:612:        stream = self.tokeniter(source, name, filename, state)
.venv\Lib\site-packages\jinja2\lexer.py:613:        return TokenStream(self.wrap(stream, name, filename), name, filename)
.venv\Lib\site-packages\jinja2\lexer.py:620:    ) -> t.Iterator[Token]:
.venv\Lib\site-packages\jinja2\lexer.py:621:        """This is called with the stream as returned by `tokenize` and wraps
.venv\Lib\site-packages\jinja2\lexer.py:622:        every token in a :class:`Token` and converts the value.
.venv\Lib\site-packages\jinja2\lexer.py:624:        for lineno, token, value_str in stream:
.venv\Lib\site-packages\jinja2\lexer.py:625:            if token in ignored_tokens:
.venv\Lib\site-packages\jinja2\lexer.py:630:            if token == TOKEN_LINESTATEMENT_BEGIN:
.venv\Lib\site-packages\jinja2\lexer.py:631:                token = TOKEN_BLOCK_BEGIN
.venv\Lib\site-packages\jinja2\lexer.py:632:            elif token == TOKEN_LINESTATEMENT_END:
.venv\Lib\site-packages\jinja2\lexer.py:633:                token = TOKEN_BLOCK_END
.venv\Lib\site-packages\jinja2\lexer.py:634:            # we are not interested in those tokens in the parser
.venv\Lib\site-packages\jinja2\lexer.py:635:            elif token in (TOKEN_RAW_BEGIN, TOKEN_RAW_END):
.venv\Lib\site-packages\jinja2\lexer.py:637:            elif token == TOKEN_DATA:
.venv\Lib\site-packages\jinja2\lexer.py:639:            elif token == "keyword":
.venv\Lib\site-packages\jinja2\lexer.py:640:                token = value_str
.venv\Lib\site-packages\jinja2\lexer.py:641:            elif token == TOKEN_NAME:
.venv\Lib\site-packages\jinja2\lexer.py:648:            elif token == TOKEN_STRING:
.venv\Lib\site-packages\jinja2\lexer.py:659:            elif token == TOKEN_INTEGER:
.venv\Lib\site-packages\jinja2\lexer.py:661:            elif token == TOKEN_FLOAT:
.venv\Lib\site-packages\jinja2\lexer.py:664:            elif token == TOKEN_OPERATOR:
.venv\Lib\site-packages\jinja2\lexer.py:665:                token = operators[value_str]
.venv\Lib\site-packages\jinja2\lexer.py:667:            yield Token(lineno, token, value)
.venv\Lib\site-packages\jinja2\lexer.py:669:    def tokeniter(
.venv\Lib\site-packages\jinja2\lexer.py:676:        """This method tokenizes the text and returns the tokens in a
.venv\Lib\site-packages\jinja2\lexer.py:677:        generator. Use this method if you just want to tokenize a template.
.venv\Lib\site-packages\jinja2\lexer.py:697:        statetokens = self.rules[stack[-1]]
.venv\Lib\site-packages\jinja2\lexer.py:704:            # tokenizer loop
.venv\Lib\site-packages\jinja2\lexer.py:705:            for regex, tokens, new_state in statetokens:
.venv\Lib\site-packages\jinja2\lexer.py:716:                if balancing_stack and tokens in (
.venv\Lib\site-packages\jinja2\lexer.py:717:                    TOKEN_VARIABLE_END,
.venv\Lib\site-packages\jinja2\lexer.py:718:                    TOKEN_BLOCK_END,
.venv\Lib\site-packages\jinja2\lexer.py:719:                    TOKEN_LINESTATEMENT_END,
.venv\Lib\site-packages\jinja2\lexer.py:724:                if isinstance(tokens, tuple):
.venv\Lib\site-packages\jinja2\lexer.py:727:                    if isinstance(tokens, OptionalLStrip):
.venv\Lib\site-packages\jinja2\lexer.py:747:                            and not m.groupdict().get(TOKEN_VARIABLE_BEGIN)
.venv\Lib\site-packages\jinja2\lexer.py:758:                    for idx, token in enumerate(tokens):
.venv\Lib\site-packages\jinja2\lexer.py:760:                        if isinstance(token, Failure):
.venv\Lib\site-packages\jinja2\lexer.py:761:                            raise token(lineno, filename)
.venv\Lib\site-packages\jinja2\lexer.py:763:                        # yield for the current token the first named
.venv\Lib\site-packages\jinja2\lexer.py:765:                        elif token == "#bygroup":
.venv\Lib\site-packages\jinja2\lexer.py:773:                                    f"{regex!r} wanted to resolve the token dynamically"
.venv\Lib\site-packages\jinja2\lexer.py:780:                            if data or token not in ignore_if_empty:
.venv\Lib\site-packages\jinja2\lexer.py:781:                                yield lineno, token, data  # type: ignore[misc]
.venv\Lib\site-packages\jinja2\lexer.py:786:                # strings as token just are yielded as it.
.venv\Lib\site-packages\jinja2\lexer.py:791:                    if tokens == TOKEN_OPERATOR:
.venv\Lib\site-packages\jinja2\lexer.py:815:                    if data or tokens not in ignore_if_empty:
.venv\Lib\site-packages\jinja2\lexer.py:816:                        yield lineno, tokens, data
.venv\Lib\site-packages\jinja2\lexer.py:846:                    statetokens = self.rules[stack[-1]]
.venv\Lib\site-packages\jinja2\parser.py:1:"""Parse tokens from the lexer into nodes for the compiler."""
.venv\Lib\site-packages\jinja2\parser.py:9:from .lexer import describe_token
.venv\Lib\site-packages\jinja2\parser.py:10:from .lexer import describe_token_expr
.venv\Lib\site-packages\jinja2\parser.py:62:        self.stream = environment._tokenize(source, name, filename, state)
.venv\Lib\site-packages\jinja2\parser.py:74:        self._end_token_stack: t.List[t.Tuple[str, ...]] = []
.venv\Lib\site-packages\jinja2\parser.py:93:        end_token_stack: t.List[t.Tuple[str, ...]],
.venv\Lib\site-packages\jinja2\parser.py:97:        for exprs in end_token_stack:
.venv\Lib\site-packages\jinja2\parser.py:98:            expected.update(map(describe_token_expr, exprs))
.venv\Lib\site-packages\jinja2\parser.py:99:        if end_token_stack:
.venv\Lib\site-packages\jinja2\parser.py:101:                map(repr, map(describe_token_expr, end_token_stack[-1]))
.venv\Lib\site-packages\jinja2\parser.py:137:        self._fail_ut_eof(name, self._end_token_stack, lineno)
.venv\Lib\site-packages\jinja2\parser.py:141:        end_tokens: t.Optional[t.Tuple[str, ...]] = None,
.venv\Lib\site-packages\jinja2\parser.py:145:        stack = list(self._end_token_stack)
.venv\Lib\site-packages\jinja2\parser.py:146:        if end_tokens is not None:
.venv\Lib\site-packages\jinja2\parser.py:147:            stack.append(end_tokens)
.venv\Lib\site-packages\jinja2\parser.py:169:        token = self.stream.current
.venv\Lib\site-packages\jinja2\parser.py:170:        if token.type != "name":
.venv\Lib\site-packages\jinja2\parser.py:171:            self.fail("tag name expected", token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:172:        self._tag_stack.append(token.value)
.venv\Lib\site-packages\jinja2\parser.py:175:            if token.value in _statement_keywords:
.venv\Lib\site-packages\jinja2\parser.py:178:            if token.value == "call":
.venv\Lib\site-packages\jinja2\parser.py:180:            if token.value == "filter":
.venv\Lib\site-packages\jinja2\parser.py:182:            ext = self.extensions.get(token.value)
.venv\Lib\site-packages\jinja2\parser.py:186:            # did not work out, remove the token we pushed by accident
.venv\Lib\site-packages\jinja2\parser.py:191:            self.fail_unknown_tag(token.value, token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:197:        self, end_tokens: t.Tuple[str, ...], drop_needle: bool = False
.venv\Lib\site-packages\jinja2\parser.py:199:        """Parse multiple statements into a list until one of the end tokens
.venv\Lib\site-packages\jinja2\parser.py:202:        current token is a colon and skips it if there is one.  Then it checks
.venv\Lib\site-packages\jinja2\parser.py:203:        for the block end and parses until if one of the `end_tokens` is
.venv\Lib\site-packages\jinja2\parser.py:204:        reached.  Per default the active token in the stream at the end of
.venv\Lib\site-packages\jinja2\parser.py:205:        the call is the matched end token.  If this is not wanted `drop_needle`
.venv\Lib\site-packages\jinja2\parser.py:206:        can be set to `True` and the end token is removed.
.venv\Lib\site-packages\jinja2\parser.py:208:        # the first token may be a colon for python compatibility
.venv\Lib\site-packages\jinja2\parser.py:212:        # by adding some sort of end of statement token and parsing those here.
.venv\Lib\site-packages\jinja2\parser.py:214:        result = self.subparse(end_tokens)
.venv\Lib\site-packages\jinja2\parser.py:219:            self.fail_eof(end_tokens)
.venv\Lib\site-packages\jinja2\parser.py:263:            token = next(self.stream)
.venv\Lib\site-packages\jinja2\parser.py:264:            if token.test("name:elif"):
.venv\Lib\site-packages\jinja2\parser.py:268:            elif token.test("name:else"):
.venv\Lib\site-packages\jinja2\parser.py:491:            token = self.stream.expect("name")
.venv\Lib\site-packages\jinja2\parser.py:492:            target = nodes.Name(token.value, "store", lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:565:            token_type = self.stream.current.type
.venv\Lib\site-packages\jinja2\parser.py:566:            if token_type in _compare_operators:
.venv\Lib\site-packages\jinja2\parser.py:568:                ops.append(nodes.Operand(token_type, self.parse_math1()))
.venv\Lib\site-packages\jinja2\parser.py:626:        token_type = self.stream.current.type
.venv\Lib\site-packages\jinja2\parser.py:630:        if token_type == "sub":
.venv\Lib\site-packages\jinja2\parser.py:633:        elif token_type == "add":
.venv\Lib\site-packages\jinja2\parser.py:646:        token = self.stream.current
.venv\Lib\site-packages\jinja2\parser.py:648:        if token.type == "name":
.venv\Lib\site-packages\jinja2\parser.py:650:            if token.value in ("true", "false", "True", "False"):
.venv\Lib\site-packages\jinja2\parser.py:651:                node = nodes.Const(token.value in ("true", "True"), lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:652:            elif token.value in ("none", "None"):
.venv\Lib\site-packages\jinja2\parser.py:653:                node = nodes.Const(None, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:656:                # token is a dot, produce a namespace reference.
.venv\Lib\site-packages\jinja2\parser.py:659:                node = nodes.NSRef(token.value, attr.value, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:661:                node = nodes.Name(token.value, "load", lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:662:        elif token.type == "string":
.venv\Lib\site-packages\jinja2\parser.py:664:            buf = [token.value]
.venv\Lib\site-packages\jinja2\parser.py:665:            lineno = token.lineno
.venv\Lib\site-packages\jinja2\parser.py:670:        elif token.type in ("integer", "float"):
.venv\Lib\site-packages\jinja2\parser.py:672:            node = nodes.Const(token.value, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:673:        elif token.type == "lparen":
.venv\Lib\site-packages\jinja2\parser.py:677:        elif token.type == "lbracket":
.venv\Lib\site-packages\jinja2\parser.py:679:        elif token.type == "lbrace":
.venv\Lib\site-packages\jinja2\parser.py:682:            self.fail(f"unexpected {describe_token(token)!r}", token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:749:                    f" got {describe_token(self.stream.current)!r}"
.venv\Lib\site-packages\jinja2\parser.py:755:        token = self.stream.expect("lbracket")
.venv\Lib\site-packages\jinja2\parser.py:764:        return nodes.List(items, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:767:        token = self.stream.expect("lbrace")
.venv\Lib\site-packages\jinja2\parser.py:779:        return nodes.Dict(items, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:783:            token_type = self.stream.current.type
.venv\Lib\site-packages\jinja2\parser.py:784:            if token_type == "dot" or token_type == "lbracket":
.venv\Lib\site-packages\jinja2\parser.py:788:            elif token_type == "lparen":
.venv\Lib\site-packages\jinja2\parser.py:796:            token_type = self.stream.current.type
.venv\Lib\site-packages\jinja2\parser.py:797:            if token_type == "pipe":
.venv\Lib\site-packages\jinja2\parser.py:799:            elif token_type == "name" and self.stream.current.value == "is":
.venv\Lib\site-packages\jinja2\parser.py:803:            elif token_type == "lparen":
.venv\Lib\site-packages\jinja2\parser.py:812:        token = next(self.stream)
.venv\Lib\site-packages\jinja2\parser.py:815:        if token.type == "dot":
.venv\Lib\site-packages\jinja2\parser.py:816:            attr_token = self.stream.current
.venv\Lib\site-packages\jinja2\parser.py:818:            if attr_token.type == "name":
.venv\Lib\site-packages\jinja2\parser.py:820:                    node, attr_token.value, "load", lineno=token.lineno
.venv\Lib\site-packages\jinja2\parser.py:822:            elif attr_token.type != "integer":
.venv\Lib\site-packages\jinja2\parser.py:823:                self.fail("expected name or number", attr_token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:824:            arg = nodes.Const(attr_token.value, lineno=attr_token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:825:            return nodes.Getitem(node, arg, "load", lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:826:        if token.type == "lbracket":
.venv\Lib\site-packages\jinja2\parser.py:836:                arg = nodes.Tuple(args, "load", lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:837:            return nodes.Getitem(node, arg, "load", lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:838:        self.fail("expected subscript expression", token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:880:        token = self.stream.expect("lparen")
.venv\Lib\site-packages\jinja2\parser.py:889:                self.fail("invalid syntax for function call expression", token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:931:        token = self.stream.current
.venv\Lib\site-packages\jinja2\parser.py:933:        return nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:941:            token = self.stream.expect("name")
.venv\Lib\site-packages\jinja2\parser.py:942:            name = token.value
.venv\Lib\site-packages\jinja2\parser.py:953:                node, name, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno
.venv\Lib\site-packages\jinja2\parser.py:959:        token = next(self.stream)
.venv\Lib\site-packages\jinja2\parser.py:990:            node, name, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno
.venv\Lib\site-packages\jinja2\parser.py:993:            node = nodes.Not(node, lineno=token.lineno)
.venv\Lib\site-packages\jinja2\parser.py:997:        self, end_tokens: t.Optional[t.Tuple[str, ...]] = None
.venv\Lib\site-packages\jinja2\parser.py:1003:        if end_tokens is not None:
.venv\Lib\site-packages\jinja2\parser.py:1004:            self._end_token_stack.append(end_tokens)
.venv\Lib\site-packages\jinja2\parser.py:1014:                token = self.stream.current
.venv\Lib\site-packages\jinja2\parser.py:1015:                if token.type == "data":
.venv\Lib\site-packages\jinja2\parser.py:1016:                    if token.value:
.venv\Lib\site-packages\jinja2\parser.py:1017:                        add_data(nodes.TemplateData(token.value, lineno=token.lineno))
.venv\Lib\site-packages\jinja2\parser.py:1019:                elif token.type == "variable_begin":
.venv\Lib\site-packages\jinja2\parser.py:1023:                elif token.type == "block_begin":
.venv\Lib\site-packages\jinja2\parser.py:1026:                    if end_tokens is not None and self.stream.current.test_any(
.venv\Lib\site-packages\jinja2\parser.py:1027:                        *end_tokens
.venv\Lib\site-packages\jinja2\parser.py:1041:            if end_tokens is not None:
.venv\Lib\site-packages\jinja2\parser.py:1042:                self._end_token_stack.pop()
.venv\Lib\site-packages\jwt\algorithms.py:141:    The interface for an algorithm used to sign and verify tokens.
.venv\Lib\site-packages\jwt\api_jws.py:20:    InvalidTokenError,
.venv\Lib\site-packages\jwt\api_jws.py:57:        Registers a new Algorithm for use when creating and verifying tokens.
.venv\Lib\site-packages\jwt\api_jws.py:70:        Unregisters an Algorithm for use when creating and verifying tokens
.venv\Lib\site-packages\jwt\api_jws.py:175:        # Don't put the payload content inside the encoded token when detached
.venv\Lib\site-packages\jwt\api_jws.py:266:            raise DecodeError(f"Invalid token type. Token must be a {bytes}")
.venv\Lib\site-packages\jwt\api_jws.py:336:            raise InvalidTokenError("Key ID header parameter must be a string")
.venv\Lib\site-packages\jwt\api_jwt.py:293:        :param subject(str): The subject of the token
.venv\Lib\site-packages\jwt\api_jwt.py:333:            raise ImmatureSignatureError("The token is not yet valid (iat)")
.venv\Lib\site-packages\jwt\api_jwt.py:347:            raise ImmatureSignatureError("The token is not yet valid (nbf)")
.venv\Lib\site-packages\jwt\api_jwt.py:376:            # the token has the 'aud' claim
.venv\Lib\site-packages\jwt\api_jwt.py:381:            # verified since the token does not contain a claim.
.venv\Lib\site-packages\jwt\api_jwt.py:395:                raise InvalidAudienceError("Invalid claim format in token (strict)")
.venv\Lib\site-packages\jwt\api_jwt.py:405:            raise InvalidAudienceError("Invalid claim format in token")
.venv\Lib\site-packages\jwt\api_jwt.py:407:            raise InvalidAudienceError("Invalid claim format in token")
.venv\Lib\site-packages\jwt\exceptions.py:9:class InvalidTokenError(PyJWTError):
.venv\Lib\site-packages\jwt\exceptions.py:13:class DecodeError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:21:class ExpiredSignatureError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:25:class InvalidAudienceError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:29:class InvalidIssuerError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:33:class InvalidIssuedAtError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:37:class ImmatureSignatureError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:45:class InvalidAlgorithmError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:49:class MissingRequiredClaimError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:54:        return f'Token is missing the "{self.claim}" claim'
.venv\Lib\site-packages\jwt\exceptions.py:77:class InvalidSubjectError(InvalidTokenError):
.venv\Lib\site-packages\jwt\exceptions.py:81:class InvalidJTIError(InvalidTokenError):
.venv\Lib\site-packages\jwt\jwks_client.py:9:from .api_jwt import decode_complete as decode_token
.venv\Lib\site-packages\jwt\jwks_client.py:112:    def get_signing_key_from_jwt(self, token: str) -> PyJWK:
.venv\Lib\site-packages\jwt\jwks_client.py:113:        unverified = decode_token(token, options={"verify_signature": False})
.venv\Lib\site-packages\jwt\__init__.py:20:    InvalidTokenError,
.venv\Lib\site-packages\jwt\__init__.py:33:__description__ = "JSON Web Token implementation in Python"
.venv\Lib\site-packages\jwt\__init__.py:68:    "InvalidTokenError",
.venv\Lib\site-packages\lxml\html\diff.py:95:    # logical tokens (which are words with attached markup).  We then
.venv\Lib\site-packages\lxml\html\diff.py:96:    # do diffs of each of the versions to track when a token first
.venv\Lib\site-packages\lxml\html\diff.py:97:    # appeared in the document; the annotation attached to the token
.venv\Lib\site-packages\lxml\html\diff.py:99:    tokenlist = [tokenize_annotated(doc, version)
.venv\Lib\site-packages\lxml\html\diff.py:101:    cur_tokens = tokenlist[0]
.venv\Lib\site-packages\lxml\html\diff.py:102:    for tokens in tokenlist[1:]:
.venv\Lib\site-packages\lxml\html\diff.py:103:        html_annotate_merge_annotations(cur_tokens, tokens)
.venv\Lib\site-packages\lxml\html\diff.py:104:        cur_tokens = tokens
.venv\Lib\site-packages\lxml\html\diff.py:106:    # After we've tracked all the tokens, we can combine spans of text
.venv\Lib\site-packages\lxml\html\diff.py:108:    cur_tokens = compress_tokens(cur_tokens)
.venv\Lib\site-packages\lxml\html\diff.py:110:    result = markup_serialize_tokens(cur_tokens, markup)
.venv\Lib\site-packages\lxml\html\diff.py:113:def tokenize_annotated(doc, annotation):
.venv\Lib\site-packages\lxml\html\diff.py:114:    """Tokenize a document and add an annotation attribute to each token
.venv\Lib\site-packages\lxml\html\diff.py:116:    tokens = tokenize(doc, include_hrefs=False)
.venv\Lib\site-packages\lxml\html\diff.py:117:    for tok in tokens:
.venv\Lib\site-packages\lxml\html\diff.py:119:    return tokens
.venv\Lib\site-packages\lxml\html\diff.py:121:def html_annotate_merge_annotations(tokens_old, tokens_new):
.venv\Lib\site-packages\lxml\html\diff.py:122:    """Merge the annotations from tokens_old into tokens_new, when the
.venv\Lib\site-packages\lxml\html\diff.py:123:    tokens in the new document already existed in the old document.
.venv\Lib\site-packages\lxml\html\diff.py:125:    s = InsensitiveSequenceMatcher(a=tokens_old, b=tokens_new)
.venv\Lib\site-packages\lxml\html\diff.py:130:            eq_old = tokens_old[i1:i2]
.venv\Lib\site-packages\lxml\html\diff.py:131:            eq_new = tokens_new[j1:j2]
.venv\Lib\site-packages\lxml\html\diff.py:136:    Copy annotations from the tokens listed in src to the tokens in dest
.venv\Lib\site-packages\lxml\html\diff.py:142:def compress_tokens(tokens):
.venv\Lib\site-packages\lxml\html\diff.py:144:    Combine adjacent tokens when there is no HTML between the tokens,
.venv\Lib\site-packages\lxml\html\diff.py:147:    result = [tokens[0]]
.venv\Lib\site-packages\lxml\html\diff.py:148:    for tok in tokens[1:]:
.venv\Lib\site-packages\lxml\html\diff.py:158:def compress_merge_back(tokens: list, tok):
.venv\Lib\site-packages\lxml\html\diff.py:159:    """ Merge tok into the last element of tokens (modifying the list of
.venv\Lib\site-packages\lxml\html\diff.py:160:    tokens in-place).  """
.venv\Lib\site-packages\lxml\html\diff.py:161:    last = tokens[-1]
.venv\Lib\site-packages\lxml\html\diff.py:162:    if type(last) is not token or type(tok) is not token:
.venv\Lib\site-packages\lxml\html\diff.py:163:        tokens.append(tok)
.venv\Lib\site-packages\lxml\html\diff.py:166:        merged = token(text,
.venv\Lib\site-packages\lxml\html\diff.py:171:        tokens[-1] = merged
.venv\Lib\site-packages\lxml\html\diff.py:173:def markup_serialize_tokens(tokens, markup_func):
.venv\Lib\site-packages\lxml\html\diff.py:175:    Serialize the list of tokens into a list of text chunks, calling
.venv\Lib\site-packages\lxml\html\diff.py:178:    for token in tokens:
.venv\Lib\site-packages\lxml\html\diff.py:179:        yield from token.pre_tags
.venv\Lib\site-packages\lxml\html\diff.py:180:        html = token.html()
.venv\Lib\site-packages\lxml\html\diff.py:181:        html = markup_func(html, token.annotation) + token.trailing_whitespace
.venv\Lib\site-packages\lxml\html\diff.py:183:        yield from token.post_tags
.venv\Lib\site-packages\lxml\html\diff.py:207:    old_html_tokens = tokenize(old_html)
.venv\Lib\site-packages\lxml\html\diff.py:208:    new_html_tokens = tokenize(new_html)
.venv\Lib\site-packages\lxml\html\diff.py:209:    result = htmldiff_tokens(old_html_tokens, new_html_tokens)
.venv\Lib\site-packages\lxml\html\diff.py:218:def htmldiff_tokens(html1_tokens, html2_tokens):
.venv\Lib\site-packages\lxml\html\diff.py:219:    """ Does a diff on the tokens themselves, returning a list of text
.venv\Lib\site-packages\lxml\html\diff.py:220:    chunks (not tokens).
.venv\Lib\site-packages\lxml\html\diff.py:222:    # There are several passes as we do the differences.  The tokens
.venv\Lib\site-packages\lxml\html\diff.py:235:    s = InsensitiveSequenceMatcher(a=html1_tokens, b=html2_tokens)
.venv\Lib\site-packages\lxml\html\diff.py:240:            result.extend(expand_tokens(html2_tokens[j1:j2], equal=True))
.venv\Lib\site-packages\lxml\html\diff.py:243:            ins_tokens = expand_tokens(html2_tokens[j1:j2])
.venv\Lib\site-packages\lxml\html\diff.py:244:            merge_insert(ins_tokens, result)
.venv\Lib\site-packages\lxml\html\diff.py:246:            del_tokens = expand_tokens(html1_tokens[i1:i2])
.venv\Lib\site-packages\lxml\html\diff.py:247:            merge_delete(del_tokens, result)
.venv\Lib\site-packages\lxml\html\diff.py:258:def expand_tokens(tokens, equal=False):
.venv\Lib\site-packages\lxml\html\diff.py:259:    """Given a list of tokens, return a generator of the chunks of
.venv\Lib\site-packages\lxml\html\diff.py:260:    text for the data in the tokens.
.venv\Lib\site-packages\lxml\html\diff.py:262:    for token in tokens:
.venv\Lib\site-packages\lxml\html\diff.py:263:        yield from token.pre_tags
.venv\Lib\site-packages\lxml\html\diff.py:264:        if not equal or not token.hide_when_equal:
.venv\Lib\site-packages\lxml\html\diff.py:265:            yield token.html() + token.trailing_whitespace
.venv\Lib\site-packages\lxml\html\diff.py:266:        yield from token.post_tags
.venv\Lib\site-packages\lxml\html\diff.py:536:class token(str):
.venv\Lib\site-packages\lxml\html\diff.py:537:    """ Represents a diffable token, generally a word that is displayed to
.venv\Lib\site-packages\lxml\html\diff.py:538:    the user.  Opening tags are attached to this token when they are
.venv\Lib\site-packages\lxml\html\diff.py:549:    # When this is true, the token will be eliminated from the
.venv\Lib\site-packages\lxml\html\diff.py:563:        return 'token(%s, %r, %r, %r)' % (
.venv\Lib\site-packages\lxml\html\diff.py:569:class tag_token(token):
.venv\Lib\site-packages\lxml\html\diff.py:571:    """ Represents a token that is actually a tag.  Currently this is just
.venv\Lib\site-packages\lxml\html\diff.py:577:        obj = token.__new__(cls, f"{type}: {data}",
.venv\Lib\site-packages\lxml\html\diff.py:587:        return 'tag_token(%s, %s, html_repr=%s, post_tags=%r, pre_tags=%r, trailing_whitespace=%r)' % (
.venv\Lib\site-packages\lxml\html\diff.py:597:class href_token(token):
.venv\Lib\site-packages\lxml\html\diff.py:608:def tokenize(html, include_hrefs=True):
.venv\Lib\site-packages\lxml\html\diff.py:610:    Parse the given HTML and returns token objects (words with attached tags).
.venv\Lib\site-packages\lxml\html\diff.py:622:    included as a special kind of diffable token."""
.venv\Lib\site-packages\lxml\html\diff.py:629:    # Finally re-joining them into token objects:
.venv\Lib\site-packages\lxml\html\diff.py:675:    This function takes a list of chunks and produces a list of tokens.
.venv\Lib\site-packages\lxml\html\diff.py:685:                cur_word = tag_token('img', src, html_repr=tag,
.venv\Lib\site-packages\lxml\html\diff.py:693:                cur_word = href_token(href, pre_tags=tag_accum, trailing_whitespace=" ")
.venv\Lib\site-packages\lxml\html\diff.py:700:            cur_word = token(chunk, pre_tags=tag_accum, trailing_whitespace=trailing_whitespace)
.venv\Lib\site-packages\lxml\html\diff.py:719:        return [token('', pre_tags=tag_accum)]
.venv\Lib\site-packages\lxml\_elementpath.py:61:xpath_tokenizer_re = re.compile(
.venv\Lib\site-packages\lxml\_elementpath.py:73:def xpath_tokenizer(pattern, namespaces=None, with_prefixes=True):
.venv\Lib\site-packages\lxml\_elementpath.py:77:    for token in xpath_tokenizer_re.findall(pattern):
.venv\Lib\site-packages\lxml\_elementpath.py:78:        ttype, tag = token
.venv\Lib\site-packages\lxml\_elementpath.py:89:                yield token  # index
.venv\Lib\site-packages\lxml\_elementpath.py:93:                yield token
.venv\Lib\site-packages\lxml\_elementpath.py:96:            yield token
.venv\Lib\site-packages\lxml\_elementpath.py:100:def prepare_child(next, token):
.venv\Lib\site-packages\lxml\_elementpath.py:101:    tag = token[1]
.venv\Lib\site-packages\lxml\_elementpath.py:107:def prepare_star(next, token):
.venv\Lib\site-packages\lxml\_elementpath.py:113:def prepare_self(next, token):
.venv\Lib\site-packages\lxml\_elementpath.py:118:def prepare_descendant(next, token):
.venv\Lib\site-packages\lxml\_elementpath.py:119:    token = next()
.venv\Lib\site-packages\lxml\_elementpath.py:120:    if token[0] == "*":
.venv\Lib\site-packages\lxml\_elementpath.py:122:    elif not token[0]:
.venv\Lib\site-packages\lxml\_elementpath.py:123:        tag = token[1]
.venv\Lib\site-packages\lxml\_elementpath.py:131:def prepare_parent(next, token):
.venv\Lib\site-packages\lxml\_elementpath.py:139:def prepare_predicate(next, token):
.venv\Lib\site-packages\lxml\_elementpath.py:146:        token = next()
.venv\Lib\site-packages\lxml\_elementpath.py:147:        if token[0] == "]":
.venv\Lib\site-packages\lxml\_elementpath.py:149:        if token == ('', ''):
.venv\Lib\site-packages\lxml\_elementpath.py:152:        if token[0] and token[0][:1] in "'\"":
.venv\Lib\site-packages\lxml\_elementpath.py:153:            token = "'", token[0][1:-1]
.venv\Lib\site-packages\lxml\_elementpath.py:154:        signature += token[0] or "-"
.venv\Lib\site-packages\lxml\_elementpath.py:155:        predicate.append(token[1])
.venv\Lib\site-packages\lxml\_elementpath.py:280:    stream = iter(xpath_tokenizer(path, namespaces, with_prefixes=with_prefixes))
.venv\Lib\site-packages\lxml\_elementpath.py:287:        token = _next()
.venv\Lib\site-packages\lxml\_elementpath.py:293:            selector.append(ops[token[0]](_next, token))
.venv\Lib\site-packages\lxml\_elementpath.py:297:            token = _next()
.venv\Lib\site-packages\lxml\_elementpath.py:298:            if token[0] == "/":
.venv\Lib\site-packages\lxml\_elementpath.py:299:                token = _next()
.venv\Lib\site-packages\numpy\lib\tests\test_loadtxt.py:314:    With the 'bytes' encoding, tokens are encoded prior to being
.venv\Lib\site-packages\numpy\lib\tests\test_loadtxt.py:802:    # Check that universal newline support within the tokenizer is not applied
.venv\Lib\site-packages\numpy\lib\_format_impl.py:603:    import tokenize
.venv\Lib\site-packages\numpy\lib\_format_impl.py:606:    tokens = []
.venv\Lib\site-packages\numpy\lib\_format_impl.py:607:    last_token_was_number = False
.venv\Lib\site-packages\numpy\lib\_format_impl.py:608:    for token in tokenize.generate_tokens(StringIO(s).readline):
.venv\Lib\site-packages\numpy\lib\_format_impl.py:609:        token_type = token[0]
.venv\Lib\site-packages\numpy\lib\_format_impl.py:610:        token_string = token[1]
.venv\Lib\site-packages\numpy\lib\_format_impl.py:611:        if (last_token_was_number and
.venv\Lib\site-packages\numpy\lib\_format_impl.py:612:                token_type == tokenize.NAME and
.venv\Lib\site-packages\numpy\lib\_format_impl.py:613:                token_string == "L"):
.venv\Lib\site-packages\numpy\lib\_format_impl.py:616:            tokens.append(token)
.venv\Lib\site-packages\numpy\lib\_format_impl.py:617:        last_token_was_number = (token_type == tokenize.NUMBER)
.venv\Lib\site-packages\numpy\lib\_format_impl.py:618:    return tokenize.untokenize(tokens)
.venv\Lib\site-packages\numpy\tests\test_warnings.py:6:import tokenize
.venv\Lib\site-packages\numpy\tests\test_warnings.py:74:        # use tokenize to auto-detect encoding on systems where no
.venv\Lib\site-packages\numpy\tests\test_warnings.py:76:        with tokenize.open(str(path)) as file:
.venv\Lib\site-packages\numpy\_core\arrayprint.py:414:    token = _set_printoptions(*args, **kwargs)
.venv\Lib\site-packages\numpy\_core\arrayprint.py:419:        format_options.reset(token)
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:432:        "_token",
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:438:        self._token = None
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:448:        if self._token is not None:
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:460:        self._token = _extobj_contextvar.set(extobj)
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:463:        _extobj_contextvar.reset(self._token)
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:467:        # because we must store the token per-thread so cannot store it on
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:482:            _token = _extobj_contextvar.set(extobj)
.venv\Lib\site-packages\numpy\_core\_ufunc_config.py:487:                _extobj_contextvar.reset(_token)
.venv\Lib\site-packages\openai\cli.py:130:            max_tokens=args.max_tokens,
.venv\Lib\site-packages\openai\cli.py:170:            max_tokens=args.max_tokens,
.venv\Lib\site-packages\openai\cli.py:873:        "--stream", help="Stream tokens as they're ready.", action="store_true"
.venv\Lib\site-packages\openai\cli.py:876:    sub.add_argument("-l", "--length", help="How many tokens to generate", type=int)
.venv\Lib\site-packages\openai\cli.py:888:        help="""An alternative to sampling with temperature, called nucleus sampling, where the considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10%% probability mass are considered.
.venv\Lib\site-packages\openai\cli.py:901:        help="Include the log probabilites on the `logprobs` most likely tokens. So for example, if `logprobs` is 10, the API will return a list of the 10 most likely tokens. If `logprobs` is supplied, the API will always return the logprob of the generated token, so there may be up to `logprobs+1` elements in the response.",
.venv\Lib\site-packages\openai\cli.py:905:        "--stop", help="A stop sequence at which to stop generating tokens."
.venv\Lib\site-packages\openai\cli.py:951:        "-M", "--max-tokens", help="The maximum number of tokens to generate.", type=int
.venv\Lib\site-packages\openai\cli.py:964:        help="""An alternative to sampling with temperature, called nucleus sampling, where the considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10%% probability mass are considered.
.venv\Lib\site-packages\openai\cli.py:971:        help="A stop sequence at which to stop generating tokens for the message.",
.venv\Lib\site-packages\openai\cli.py:991:        "--stream", help="Stream tokens as they're ready.", action="store_true"
.venv\Lib\site-packages\openai\cli.py:995:        "-M", "--max-tokens", help="The maximum number of tokens to generate", type=int
.venv\Lib\site-packages\openai\cli.py:1008:        help="""An alternative to sampling with temperature, called nucleus sampling, where the considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10%% probability mass are considered.
.venv\Lib\site-packages\openai\cli.py:1021:        help="Include the log probabilites on the `logprobs` most likely tokens, as well the chosen tokens. So for example, if `logprobs` is 10, the API will return a list of the 10 most likely tokens. If `logprobs` is 0, only the chosen tokens will have logprobs returned.",
.venv\Lib\site-packages\openai\cli.py:1025:        "--stop", help="A stop sequence at which to stop generating tokens."
.venv\Lib\site-packages\openai\cli.py:1162:        "learning from prompt tokens vs learning from completion tokens.",
.venv\Lib\site-packages\openai\tests\asyncio\test_endpoints.py:56:            max_tokens=100,
.venv\Lib\site-packages\openai\tests\test_endpoints.py:78:            max_tokens=100,
.venv\Lib\site-packages\openai\tests\test_util.py:40:        "usage": {"prompt_tokens": 57, "completion_tokens": 40, "total_tokens": 97},
.venv\Lib\site-packages\openai\validators.py:172:            immediate_msg = f"\n- There are {len(long_indexes)} examples that are very long. These are rows: {long_indexes}\nFor conditional generation, and for classification the examples shouldn't be longer than 2048 tokens."
.venv\Lib\site-packages\openai\validators.py:421:    This validator will suggest to add a space at the start of the completion if it doesn't already exist. This helps with tokenization.
.venv\Lib\site-packages\openai\validators.py:435:        immediate_msg = "\n- The completion should start with a whitespace character (` `). This tends to produce better results due to the tokenization we use. See https://platform.openai.com/docs/guides/fine-tuning/preparing-your-dataset for more details"
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:2:This module contains a tokenizer for Excel formulae.
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:4:The tokenizer is based on the Javascript tokenizer found at
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:12:class TokenizerError(Exception):
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:13:    """Base class for all Tokenizer errors."""
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:16:class Tokenizer:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:19:    A tokenizer for Excel worksheet formulae.
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:22:    into a sequence of `Token` objects.
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:24:    `formula`: The str string to tokenize
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:26:    Tokenizer defines a method `._parse()` to parse the formula into tokens,
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:43:    TOKEN_ENDERS = ',;}) +-*/^&=><%'  # Each of these characters, marks the
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:44:                                       # end of an operand token
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:49:        self.token_stack = []  # Used to keep track of arrays, functions, and
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:52:        self.token = []  # Used to build up token values char by char
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:56:        """Populate self.items with the tokens from the formula."""
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:64:            self.items.append(Token(self.formula, Token.LITERAL))
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:84:            if curr_char in self.TOKEN_ENDERS:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:85:                self.save_token()
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:91:                self.token.append(curr_char)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:93:        self.save_token()
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:108:        self.assert_empty_token(can_follow=':')
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:115:            raise TokenizerError(f"Reached end of formula while parsing {subtype} in {self.formula}")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:118:            self.items.append(Token.make_operand(match))
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:120:            self.token.append(match)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:142:                self.token.append(
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:146:        raise TokenizerError(f"Encountered unmatched '[' in {self.formula}")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:156:        self.assert_empty_token(can_follow='!')
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:161:                self.items.append(Token.make_operand(''.join(self.token) + err))
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:162:                del self.token[:]
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:164:        raise TokenizerError(f"Invalid error code at position {self.offset} in '{self.formula}'")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:174:        self.items.append(Token(self.formula[self.offset], Token.WSPACE))
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:186:            self.items.append(Token(
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:188:                Token.OP_IN
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:194:            token = Token('%', Token.OP_POST)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:196:            token = Token(curr_char, Token.OP_IN)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:199:            token = Token(curr_char, Token.OP_PRE)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:202:                         if i.type != Token.WSPACE), None)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:204:                prev.subtype == Token.CLOSE
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:205:                or prev.type == Token.OP_POST
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:206:                or prev.type == Token.OPERAND
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:209:                token = Token(curr_char, Token.OP_IN)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:211:                token = Token(curr_char, Token.OP_PRE)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:212:        self.items.append(token)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:225:            self.assert_empty_token()
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:226:            token = Token.make_subexp("{")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:227:        elif self.token:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:228:            token_value = "".join(self.token) + '('
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:229:            del self.token[:]
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:230:            token = Token.make_subexp(token_value)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:232:            token = Token.make_subexp("(")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:233:        self.items.append(token)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:234:        self.token_stack.append(token)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:246:        token = self.token_stack.pop().get_closer()
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:247:        if token.value != self.formula[self.offset]:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:248:            raise TokenizerError(
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:250:        self.items.append(token)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:264:            token = Token.make_separator(";")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:267:                top_type = self.token_stack[-1].type
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:269:                token = Token(",", Token.OP_IN)  # Range Union operator
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:271:                if top_type == Token.PAREN:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:272:                    token = Token(",", Token.OP_IN)  # Range Union operator
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:274:                    token = Token.make_separator(",")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:275:        self.items.append(token)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:288:                and len(self.token) >= 1
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:289:                and self.SN_RE.match("".join(self.token))):
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:290:            self.token.append(curr_char)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:295:    def assert_empty_token(self, can_follow=()):
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:297:        Ensure that there's no token currently being parsed.
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:299:        Or if there is a token being parsed, it must end with a character in
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:302:        If there are unconsumed token contents, it means we hit an unexpected
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:303:        token transition. In this case, we raise a TokenizerError
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:306:        if self.token and self.token[-1] not in can_follow:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:307:            raise TokenizerError(f"Unexpected character at position {self.offset} in '{self.formula}'")
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:309:    def save_token(self):
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:310:        """If there's a token being parsed, add it to the item list."""
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:311:        if self.token:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:312:            self.items.append(Token.make_operand("".join(self.token)))
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:313:            del self.token[:]
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:316:        """Convert the parsed tokens back to a string."""
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:319:        elif self.items[0].type == Token.LITERAL:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:321:        return "=" + "".join(token.value for token in self.items)
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:324:class Token:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:327:    A token in an Excel formula.
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:329:    Tokens have three attributes:
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:331:    * `value`: The string value parsed that led to this token
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:332:    * `type`: A string identifying the type of token
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:333:    * `subtype`: A string identifying subtype of the token (optional, and
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:374:        """Create an operand token."""
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:393:    # parentheticals. Subexpressions have 'OPEN' and 'CLOSE' tokens. 'OPEN'
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:394:    # is used when parsing the initial expression token (i.e., '(' or '{')
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:395:    # and 'CLOSE' is used when parsing the closing expression token ('}' or
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:404:        Create a subexpression token.
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:406:        `value`: The value of the token
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:407:        `func`: If True, force the token to be of type FUNC
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:413:            type_ = Token.FUNC
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:415:            type_ = Token.ARRAY
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:417:            type_ = Token.PAREN
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:419:            type_ = Token.FUNC
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:424:        """Return a closing token that matches this token's type."""
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:430:    # Separator tokens
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:433:    # subtypes: 'ARG', 'ROW'. 'ARG' is used for the ',' token, when used to
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:435:    # the ';' token, which is always used to delimit rows in an array
.venv\Lib\site-packages\openpyxl\formula\tokenizer.py:443:        """Create a separator token"""
.venv\Lib\site-packages\openpyxl\formula\translate.py:5:results in formula "=B2+C2". The algorithm relies on the formula tokenizer
.venv\Lib\site-packages\openpyxl\formula\translate.py:11:from .tokenizer import Tokenizer, Token
.venv\Lib\site-packages\openpyxl\formula\translate.py:50:        self.tokenizer = Tokenizer(formula)
.venv\Lib\site-packages\openpyxl\formula\translate.py:52:    def get_tokens(self):
.venv\Lib\site-packages\openpyxl\formula\translate.py:53:        "Returns a list with the tokens comprising the formula."
.venv\Lib\site-packages\openpyxl\formula\translate.py:54:        return self.tokenizer.items
.venv\Lib\site-packages\openpyxl\formula\translate.py:144:        tokens = self.get_tokens()
.venv\Lib\site-packages\openpyxl\formula\translate.py:145:        if not tokens:
.venv\Lib\site-packages\openpyxl\formula\translate.py:147:        elif tokens[0].type == Token.LITERAL:
.venv\Lib\site-packages\openpyxl\formula\translate.py:148:            return tokens[0].value
.venv\Lib\site-packages\openpyxl\formula\translate.py:159:        for token in tokens:
.venv\Lib\site-packages\openpyxl\formula\translate.py:160:            if (token.type == Token.OPERAND
.venv\Lib\site-packages\openpyxl\formula\translate.py:161:                and token.subtype == Token.RANGE):
.venv\Lib\site-packages\openpyxl\formula\translate.py:162:                out.append(self.translate_range(token.value, row_delta,
.venv\Lib\site-packages\openpyxl\formula\translate.py:165:                out.append(token.value)
.venv\Lib\site-packages\openpyxl\formula\__init__.py:3:from .tokenizer import Tokenizer
.venv\Lib\site-packages\openpyxl\utils\formulas.py:12:from openpyxl.formula import Tokenizer
.venv\Lib\site-packages\openpyxl\utils\formulas.py:20:    formula = Tokenizer(formula)
.venv\Lib\site-packages\openpyxl\workbook\defined_name.py:16:from openpyxl.formula import Tokenizer
.venv\Lib\site-packages\openpyxl\workbook\defined_name.py:88:        tok = Tokenizer("=" + self.value)
.venv\Lib\site-packages\openpyxl\workbook\defined_name.py:98:            tok = Tokenizer("=" + self.value)
.venv\Lib\site-packages\packaging\licenses\__init__.py:67:    # Pad any parentheses so tokenization can be achieved by merely splitting on
.venv\Lib\site-packages\packaging\licenses\__init__.py:81:    tokens = license_expression.split()
.venv\Lib\site-packages\packaging\licenses\__init__.py:86:    python_tokens = []
.venv\Lib\site-packages\packaging\licenses\__init__.py:87:    for token in tokens:
.venv\Lib\site-packages\packaging\licenses\__init__.py:88:        if token not in {"or", "and", "with", "(", ")"}:
.venv\Lib\site-packages\packaging\licenses\__init__.py:89:            python_tokens.append("False")
.venv\Lib\site-packages\packaging\licenses\__init__.py:90:        elif token == "with":
.venv\Lib\site-packages\packaging\licenses\__init__.py:91:            python_tokens.append("or")
.venv\Lib\site-packages\packaging\licenses\__init__.py:92:        elif token == "(" and python_tokens and python_tokens[-1] not in {"or", "and"}:
.venv\Lib\site-packages\packaging\licenses\__init__.py:96:            python_tokens.append(token)
.venv\Lib\site-packages\packaging\licenses\__init__.py:98:    python_expression = " ".join(python_tokens)
.venv\Lib\site-packages\packaging\licenses\__init__.py:109:    normalized_tokens = []
.venv\Lib\site-packages\packaging\licenses\__init__.py:110:    for token in tokens:
.venv\Lib\site-packages\packaging\licenses\__init__.py:111:        if token in {"or", "and", "with", "(", ")"}:
.venv\Lib\site-packages\packaging\licenses\__init__.py:112:            normalized_tokens.append(token.upper())
.venv\Lib\site-packages\packaging\licenses\__init__.py:115:        if normalized_tokens and normalized_tokens[-1] == "WITH":
.venv\Lib\site-packages\packaging\licenses\__init__.py:116:            if token not in EXCEPTIONS:
.venv\Lib\site-packages\packaging\licenses\__init__.py:117:                message = f"Unknown license exception: {token!r}"
.venv\Lib\site-packages\packaging\licenses\__init__.py:120:            normalized_tokens.append(EXCEPTIONS[token]["id"])
.venv\Lib\site-packages\packaging\licenses\__init__.py:122:            if token.endswith("+"):
.venv\Lib\site-packages\packaging\licenses\__init__.py:123:                final_token = token[:-1]
.venv\Lib\site-packages\packaging\licenses\__init__.py:126:                final_token = token
.venv\Lib\site-packages\packaging\licenses\__init__.py:129:            if final_token.startswith("licenseref-"):
.venv\Lib\site-packages\packaging\licenses\__init__.py:130:                if not license_ref_allowed.match(final_token):
.venv\Lib\site-packages\packaging\licenses\__init__.py:131:                    message = f"Invalid licenseref: {final_token!r}"
.venv\Lib\site-packages\packaging\licenses\__init__.py:133:                normalized_tokens.append(license_refs[final_token] + suffix)
.venv\Lib\site-packages\packaging\licenses\__init__.py:135:                if final_token not in LICENSES:
.venv\Lib\site-packages\packaging\licenses\__init__.py:136:                    message = f"Unknown license: {final_token!r}"
.venv\Lib\site-packages\packaging\licenses\__init__.py:138:                normalized_tokens.append(LICENSES[final_token]["id"] + suffix)
.venv\Lib\site-packages\packaging\licenses\__init__.py:140:    normalized_expression = " ".join(normalized_tokens)
.venv\Lib\site-packages\packaging\markers.py:15:from ._tokenizer import ParserSyntaxError
.venv\Lib\site-packages\packaging\requirements.py:9:from ._tokenizer import ParserSyntaxError
.venv\Lib\site-packages\packaging\_parser.py:12:from ._tokenizer import DEFAULT_RULES, Tokenizer
.venv\Lib\site-packages\packaging\_parser.py:62:    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))
.venv\Lib\site-packages\packaging\_parser.py:65:def _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:
.venv\Lib\site-packages\packaging\_parser.py:69:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:71:    name_token = tokenizer.expect(
.venv\Lib\site-packages\packaging\_parser.py:74:    name = name_token.text
.venv\Lib\site-packages\packaging\_parser.py:75:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:77:    extras = _parse_extras(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:78:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:80:    url, specifier, marker = _parse_requirement_details(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:81:    tokenizer.expect("END", expected="end of dependency specifier")
.venv\Lib\site-packages\packaging\_parser.py:87:    tokenizer: Tokenizer,
.venv\Lib\site-packages\packaging\_parser.py:98:    if tokenizer.check("AT"):
.venv\Lib\site-packages\packaging\_parser.py:99:        tokenizer.read()
.venv\Lib\site-packages\packaging\_parser.py:100:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:102:        url_start = tokenizer.position
.venv\Lib\site-packages\packaging\_parser.py:103:        url = tokenizer.expect("URL", expected="URL after @").text
.venv\Lib\site-packages\packaging\_parser.py:104:        if tokenizer.check("END", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:107:        tokenizer.expect("WS", expected="whitespace after URL")
.venv\Lib\site-packages\packaging\_parser.py:110:        if tokenizer.check("END", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:114:            tokenizer, span_start=url_start, after="URL and whitespace"
.venv\Lib\site-packages\packaging\_parser.py:117:        specifier_start = tokenizer.position
.venv\Lib\site-packages\packaging\_parser.py:118:        specifier = _parse_specifier(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:119:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:121:        if tokenizer.check("END", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:125:            tokenizer,
.venv\Lib\site-packages\packaging\_parser.py:138:    tokenizer: Tokenizer, *, span_start: int, after: str
.venv\Lib\site-packages\packaging\_parser.py:144:    if not tokenizer.check("SEMICOLON"):
.venv\Lib\site-packages\packaging\_parser.py:145:        tokenizer.raise_syntax_error(
.venv\Lib\site-packages\packaging\_parser.py:149:    tokenizer.read()
.venv\Lib\site-packages\packaging\_parser.py:151:    marker = _parse_marker(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:152:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:157:def _parse_extras(tokenizer: Tokenizer) -> list[str]:
.venv\Lib\site-packages\packaging\_parser.py:161:    if not tokenizer.check("LEFT_BRACKET", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:164:    with tokenizer.enclosing_tokens(
.venv\Lib\site-packages\packaging\_parser.py:169:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:170:        extras = _parse_extras_list(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:171:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:176:def _parse_extras_list(tokenizer: Tokenizer) -> list[str]:
.venv\Lib\site-packages\packaging\_parser.py:182:    if not tokenizer.check("IDENTIFIER"):
.venv\Lib\site-packages\packaging\_parser.py:185:    extras.append(tokenizer.read().text)
.venv\Lib\site-packages\packaging\_parser.py:188:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:189:        if tokenizer.check("IDENTIFIER", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:190:            tokenizer.raise_syntax_error("Expected comma between extra names")
.venv\Lib\site-packages\packaging\_parser.py:191:        elif not tokenizer.check("COMMA"):
.venv\Lib\site-packages\packaging\_parser.py:194:        tokenizer.read()
.venv\Lib\site-packages\packaging\_parser.py:195:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:197:        extra_token = tokenizer.expect("IDENTIFIER", expected="extra name after comma")
.venv\Lib\site-packages\packaging\_parser.py:198:        extras.append(extra_token.text)
.venv\Lib\site-packages\packaging\_parser.py:203:def _parse_specifier(tokenizer: Tokenizer) -> str:
.venv\Lib\site-packages\packaging\_parser.py:208:    with tokenizer.enclosing_tokens(
.venv\Lib\site-packages\packaging\_parser.py:213:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:214:        parsed_specifiers = _parse_version_many(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:215:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:220:def _parse_version_many(tokenizer: Tokenizer) -> str:
.venv\Lib\site-packages\packaging\_parser.py:225:    while tokenizer.check("SPECIFIER"):
.venv\Lib\site-packages\packaging\_parser.py:226:        span_start = tokenizer.position
.venv\Lib\site-packages\packaging\_parser.py:227:        parsed_specifiers += tokenizer.read().text
.venv\Lib\site-packages\packaging\_parser.py:228:        if tokenizer.check("VERSION_PREFIX_TRAIL", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:229:            tokenizer.raise_syntax_error(
.venv\Lib\site-packages\packaging\_parser.py:232:                span_end=tokenizer.position + 1,
.venv\Lib\site-packages\packaging\_parser.py:234:        if tokenizer.check("VERSION_LOCAL_LABEL_TRAIL", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:235:            tokenizer.raise_syntax_error(
.venv\Lib\site-packages\packaging\_parser.py:238:                span_end=tokenizer.position,
.venv\Lib\site-packages\packaging\_parser.py:240:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:241:        if not tokenizer.check("COMMA"):
.venv\Lib\site-packages\packaging\_parser.py:243:        parsed_specifiers += tokenizer.read().text
.venv\Lib\site-packages\packaging\_parser.py:244:        tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:253:    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))
.venv\Lib\site-packages\packaging\_parser.py:256:def _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:
.venv\Lib\site-packages\packaging\_parser.py:257:    retval = _parse_marker(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:258:    tokenizer.expect("END", expected="end of marker expression")
.venv\Lib\site-packages\packaging\_parser.py:262:def _parse_marker(tokenizer: Tokenizer) -> MarkerList:
.venv\Lib\site-packages\packaging\_parser.py:266:    expression = [_parse_marker_atom(tokenizer)]
.venv\Lib\site-packages\packaging\_parser.py:267:    while tokenizer.check("BOOLOP"):
.venv\Lib\site-packages\packaging\_parser.py:268:        token = tokenizer.read()
.venv\Lib\site-packages\packaging\_parser.py:269:        expr_right = _parse_marker_atom(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:270:        expression.extend((token.text, expr_right))
.venv\Lib\site-packages\packaging\_parser.py:274:def _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:
.venv\Lib\site-packages\packaging\_parser.py:280:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:281:    if tokenizer.check("LEFT_PARENTHESIS", peek=True):
.venv\Lib\site-packages\packaging\_parser.py:282:        with tokenizer.enclosing_tokens(
.venv\Lib\site-packages\packaging\_parser.py:287:            tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:288:            marker: MarkerAtom = _parse_marker(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:289:            tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:291:        marker = _parse_marker_item(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:292:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:296:def _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:
.venv\Lib\site-packages\packaging\_parser.py:300:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:301:    marker_var_left = _parse_marker_var(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:302:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:303:    marker_op = _parse_marker_op(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:304:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:305:    marker_var_right = _parse_marker_var(tokenizer)
.venv\Lib\site-packages\packaging\_parser.py:306:    tokenizer.consume("WS")
.venv\Lib\site-packages\packaging\_parser.py:310:def _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:
.venv\Lib\site-packages\packaging\_parser.py:314:    if tokenizer.check("VARIABLE"):
.venv\Lib\site-packages\packaging\_parser.py:315:        return process_env_var(tokenizer.read().text.replace(".", "_"))
.venv\Lib\site-packages\packaging\_parser.py:316:    elif tokenizer.check("QUOTED_STRING"):
.venv\Lib\site-packages\packaging\_parser.py:317:        return process_python_str(tokenizer.read().text)
.venv\Lib\site-packages\packaging\_parser.py:319:        tokenizer.raise_syntax_error(
.venv\Lib\site-packages\packaging\_parser.py:336:def _parse_marker_op(tokenizer: Tokenizer) -> Op:
.venv\Lib\site-packages\packaging\_parser.py:340:    if tokenizer.check("IN"):
.venv\Lib\site-packages\packaging\_parser.py:341:        tokenizer.read()
.venv\Lib\site-packages\packaging\_parser.py:343:    elif tokenizer.check("NOT"):
.venv\Lib\site-packages\packaging\_parser.py:344:        tokenizer.read()
.venv\Lib\site-packages\packaging\_parser.py:345:        tokenizer.expect("WS", expected="whitespace after 'not'")
.venv\Lib\site-packages\packaging\_parser.py:346:        tokenizer.expect("IN", expected="'in' after 'not'")
.venv\Lib\site-packages\packaging\_parser.py:348:    elif tokenizer.check("OP"):
.venv\Lib\site-packages\packaging\_parser.py:349:        return Op(tokenizer.read().text)
.venv\Lib\site-packages\packaging\_parser.py:351:        return tokenizer.raise_syntax_error(
.venv\Lib\site-packages\packaging\_tokenizer.py:12:class Token:
.venv\Lib\site-packages\packaging\_tokenizer.py:91:class Tokenizer:
.venv\Lib\site-packages\packaging\_tokenizer.py:92:    """Context-sensitive token parsing.
.venv\Lib\site-packages\packaging\_tokenizer.py:94:    Provides methods to examine the input stream to check whether the next token
.venv\Lib\site-packages\packaging\_tokenizer.py:108:        self.next_token: Token | None = None
.venv\Lib\site-packages\packaging\_tokenizer.py:112:        """Move beyond provided token name, if at current position."""
.venv\Lib\site-packages\packaging\_tokenizer.py:117:        """Check whether the next token has the provided name.
.venv\Lib\site-packages\packaging\_tokenizer.py:119:        By default, if the check succeeds, the token *must* be read before
.venv\Lib\site-packages\packaging\_tokenizer.py:120:        another check. If `peek` is set to `True`, the token is not loaded and
.venv\Lib\site-packages\packaging\_tokenizer.py:123:        assert self.next_token is None, (
.venv\Lib\site-packages\packaging\_tokenizer.py:124:            f"Cannot check for {name!r}, already have {self.next_token!r}"
.venv\Lib\site-packages\packaging\_tokenizer.py:126:        assert name in self.rules, f"Unknown token name: {name!r}"
.venv\Lib\site-packages\packaging\_tokenizer.py:134:            self.next_token = Token(name, match[0], self.position)
.venv\Lib\site-packages\packaging\_tokenizer.py:137:    def expect(self, name: str, *, expected: str) -> Token:
.venv\Lib\site-packages\packaging\_tokenizer.py:138:        """Expect a certain token name next, failing with a syntax error otherwise.
.venv\Lib\site-packages\packaging\_tokenizer.py:140:        The token is *not* read.
.venv\Lib\site-packages\packaging\_tokenizer.py:146:    def read(self) -> Token:
.venv\Lib\site-packages\packaging\_tokenizer.py:147:        """Consume the next token and return it."""
.venv\Lib\site-packages\packaging\_tokenizer.py:148:        token = self.next_token
.venv\Lib\site-packages\packaging\_tokenizer.py:149:        assert token is not None
.venv\Lib\site-packages\packaging\_tokenizer.py:151:        self.position += len(token.text)
.venv\Lib\site-packages\packaging\_tokenizer.py:152:        self.next_token = None
.venv\Lib\site-packages\packaging\_tokenizer.py:154:        return token
.venv\Lib\site-packages\packaging\_tokenizer.py:175:    def enclosing_tokens(
.venv\Lib\site-packages\packaging\_tokenizer.py:176:        self, open_token: str, close_token: str, *, around: str
.venv\Lib\site-packages\packaging\_tokenizer.py:178:        if self.check(open_token):
.venv\Lib\site-packages\packaging\_tokenizer.py:189:        if not self.check(close_token):
.venv\Lib\site-packages\packaging\_tokenizer.py:191:                f"Expected matching {close_token} for {open_token}, after {around}",
.venv\Lib\site-packages\pandas\core\computation\eval.py:6:import tokenize
.venv\Lib\site-packages\pandas\core\computation\eval.py:23:from pandas.core.computation.parsing import tokenize_string
.venv\Lib\site-packages\pandas\core\computation\eval.py:168:        for toknum, tokval in tokenize_string(expr):
.venv\Lib\site-packages\pandas\core\computation\eval.py:169:            if toknum == tokenize.OP and tokval == "@":
.venv\Lib\site-packages\pandas\core\computation\expr.py:12:import tokenize
.venv\Lib\site-packages\pandas\core\computation\expr.py:44:    tokenize_string,
.venv\Lib\site-packages\pandas\core\computation\expr.py:59:        ints correspond to the all caps constants in the tokenize module
.venv\Lib\site-packages\pandas\core\computation\expr.py:64:        Either the input or token or the replacement values
.venv\Lib\site-packages\pandas\core\computation\expr.py:78:        ints correspond to the all caps constants in the tokenize module
.venv\Lib\site-packages\pandas\core\computation\expr.py:83:        Either the input or token or the replacement values
.venv\Lib\site-packages\pandas\core\computation\expr.py:86:    if toknum == tokenize.OP:
.venv\Lib\site-packages\pandas\core\computation\expr.py:88:            return tokenize.NAME, "and"
.venv\Lib\site-packages\pandas\core\computation\expr.py:90:            return tokenize.NAME, "or"
.venv\Lib\site-packages\pandas\core\computation\expr.py:102:        ints correspond to the all caps constants in the tokenize module
.venv\Lib\site-packages\pandas\core\computation\expr.py:107:        Either the input or token or the replacement values
.venv\Lib\site-packages\pandas\core\computation\expr.py:112:    ``'__pd_eval_local_a'`` by telling the tokenizer that ``__pd_eval_local_``
.venv\Lib\site-packages\pandas\core\computation\expr.py:113:    is a ``tokenize.OP`` and to replace the ``'@'`` symbol with it.
.venv\Lib\site-packages\pandas\core\computation\expr.py:116:    if toknum == tokenize.OP and tokval == "@":
.venv\Lib\site-packages\pandas\core\computation\expr.py:117:        return tokenize.OP, LOCAL_TAG
.venv\Lib\site-packages\pandas\core\computation\expr.py:143:    Compose a collection of tokenization functions.
.venv\Lib\site-packages\pandas\core\computation\expr.py:164:    the ``tokenize`` module and ``tokval`` is a string.
.venv\Lib\site-packages\pandas\core\computation\expr.py:167:    return tokenize.untokenize(f(x) for x in tokenize_string(source))
.venv\Lib\site-packages\pandas\core\computation\ops.py:507:        The token used to represent the operator.
.venv\Lib\site-packages\pandas\core\computation\ops.py:514:        * If no function associated with the passed operator token is found.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:8:import token
.venv\Lib\site-packages\pandas\core\computation\parsing.py:9:import tokenize
.venv\Lib\site-packages\pandas\core\computation\parsing.py:18:# A token value Python's tokenizer probably will never use.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:34:        This can happen if there is a hashtag in the name, as the tokenizer will
.venv\Lib\site-packages\pandas\core\computation\parsing.py:42:    # EXACT_TOKEN_TYPES contains these special characters
.venv\Lib\site-packages\pandas\core\computation\parsing.py:43:    # token.tok_name contains a readable description of the replacement string.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:45:        char: f"_{token.tok_name[tokval]}_"
.venv\Lib\site-packages\pandas\core\computation\parsing.py:46:        for char, tokval in (tokenize.EXACT_TOKEN_TYPES.items())
.venv\Lib\site-packages\pandas\core\computation\parsing.py:78:    is a backtick quoted token it will processed by
.venv\Lib\site-packages\pandas\core\computation\parsing.py:86:        ints correspond to the all caps constants in the tokenize module
.venv\Lib\site-packages\pandas\core\computation\parsing.py:91:        Either the input or token or the replacement values
.venv\Lib\site-packages\pandas\core\computation\parsing.py:95:        return tokenize.NAME, create_valid_python_identifier(tokval)
.venv\Lib\site-packages\pandas\core\computation\parsing.py:116:        Returns the name after tokenizing and cleaning.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:121:        In that case :func:`tokenize_string` raises a SyntaxError.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:125:        an error will be raised by :func:`tokenize_backtick_quoted_string` instead,
.venv\Lib\site-packages\pandas\core\computation\parsing.py:129:        tokenized = tokenize_string(f"`{name}`")
.venv\Lib\site-packages\pandas\core\computation\parsing.py:130:        tokval = next(tokenized)[1]
.venv\Lib\site-packages\pandas\core\computation\parsing.py:136:def tokenize_backtick_quoted_string(
.venv\Lib\site-packages\pandas\core\computation\parsing.py:137:    token_generator: Iterator[tokenize.TokenInfo], source: str, string_start: int
.venv\Lib\site-packages\pandas\core\computation\parsing.py:140:    Creates a token from a backtick quoted string.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:142:    Moves the token_generator forwards till right after the next backtick.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:146:    token_generator : Iterator[tokenize.TokenInfo]
.venv\Lib\site-packages\pandas\core\computation\parsing.py:147:        The generator that yields the tokens of the source string (Tuple[int, str]).
.venv\Lib\site-packages\pandas\core\computation\parsing.py:148:        The generator is at the first token after the backtick (`)
.venv\Lib\site-packages\pandas\core\computation\parsing.py:159:        The token that represents the backtick quoted string.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:162:    for _, tokval, start, _, _ in token_generator:
.venv\Lib\site-packages\pandas\core\computation\parsing.py:170:def tokenize_string(source: str) -> Iterator[tuple[int, str]]:
.venv\Lib\site-packages\pandas\core\computation\parsing.py:172:    Tokenize a Python source code string.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:182:        An iterator yielding all tokens with only toknum and tokval (Tuple[ing, str]).
.venv\Lib\site-packages\pandas\core\computation\parsing.py:185:    token_generator = tokenize.generate_tokens(line_reader)
.venv\Lib\site-packages\pandas\core\computation\parsing.py:187:    # Loop over all tokens till a backtick (`) is found.
.venv\Lib\site-packages\pandas\core\computation\parsing.py:188:    # Then, take all tokens till the next backtick to form a backtick quoted string
.venv\Lib\site-packages\pandas\core\computation\parsing.py:189:    for toknum, tokval, start, _, _ in token_generator:
.venv\Lib\site-packages\pandas\core\computation\parsing.py:192:                yield tokenize_backtick_quoted_string(
.venv\Lib\site-packages\pandas\core\computation\parsing.py:193:                    token_generator, source, string_start=start[1] + 1
.venv\Lib\site-packages\pandas\io\formats\css.py:45:            value (str): String token for property
.venv\Lib\site-packages\pandas\io\formats\css.py:51:        tokens = value.split()
.venv\Lib\site-packages\pandas\io\formats\css.py:53:            mapping = self.SIDE_SHORTHANDS[len(tokens)]
.venv\Lib\site-packages\pandas\io\formats\css.py:62:            yield prop_fmt.format(key), tokens[idx]
.venv\Lib\site-packages\pandas\io\formats\css.py:98:        tokens = value.split()
.venv\Lib\site-packages\pandas\io\formats\css.py:99:        if len(tokens) == 0 or len(tokens) > 3:
.venv\Lib\site-packages\pandas\io\formats\css.py:101:                f'Too many tokens provided to "{prop}" (expected 1-3)',
.venv\Lib\site-packages\pandas\io\formats\css.py:112:        for token in tokens:
.venv\Lib\site-packages\pandas\io\formats\css.py:113:            if token.lower() in self.BORDER_STYLES:
.venv\Lib\site-packages\pandas\io\formats\css.py:114:                border_declarations[f"border{side}-style"] = token
.venv\Lib\site-packages\pandas\io\formats\css.py:115:            elif any(ratio in token.lower() for ratio in self.BORDER_WIDTH_RATIOS):
.venv\Lib\site-packages\pandas\io\formats\css.py:116:                border_declarations[f"border{side}-width"] = token
.venv\Lib\site-packages\pandas\io\formats\css.py:118:                border_declarations[f"border{side}-color"] = token
.venv\Lib\site-packages\pandas\io\formats\css.py:401:        In a future version may generate parsed tokens from tinycss/tinycss2
.venv\Lib\site-packages\pandas\tests\computation\test_eval.py:1930:def test_query_token(engine, column):
.venv\Lib\site-packages\pandas\tests\io\parser\common\test_verbose.py:43:        assert "Tokenization took:" in captured.out
.venv\Lib\site-packages\pandas\tests\io\parser\common\test_verbose.py:78:        assert "Tokenization took:" in captured.out
.venv\Lib\site-packages\pandas\tests\io\parser\test_c_parser_only.py:41:    # buffer overflows in tokenizer.c
.venv\Lib\site-packages\pandas\tests\io\parser\test_c_parser_only.py:280:def test_tokenize_CR_with_quoting(c_parser_only):
.venv\Lib\site-packages\pandas\tests\io\parser\test_c_parser_only.py:323:    # `tokenizer.c`. Sometimes the test fails on `segfault`, other
.venv\Lib\site-packages\pandas\tests\io\parser\test_textreader.py:134:        msg = r"Error tokenizing data\. C error: Expected 3 fields in line 4, saw 4"
.venv\Lib\site-packages\pandas\tests\io\parser\test_unsupported.py:74:        msg = "Error tokenizing data"
.venv\Lib\site-packages\pandas\tests\io\test_sql.py:4233:        tokens = line.split(" ")
.venv\Lib\site-packages\pandas\tests\io\test_sql.py:4234:        if len(tokens) == 2 and tokens[0] == "A":
.venv\Lib\site-packages\pandas\tests\io\test_sql.py:4235:            assert tokens[1] == "DATETIME"
.venv\Lib\site-packages\pandas\tests\strings\test_case_justify.py:377:    # equal to width, one word greater than width, multiple tokens with
.venv\Lib\site-packages\pandas\_config\config.py:523:    import tokenize
.venv\Lib\site-packages\pandas\_config\config.py:540:        if not re.match("^" + tokenize.Name + "$", k):
.venv\Lib\site-packages\pip\_internal\commands\completion.py:42:                (commandline --current-process --tokenize --cut-at-cursor) \\
.venv\Lib\site-packages\pip\_internal\commands\completion.py:43:                (commandline --current-token --cut-at-cursor)
.venv\Lib\site-packages\pip\_internal\req\req_file.py:458:    tokens = line.split(" ")
.venv\Lib\site-packages\pip\_internal\req\req_file.py:460:    options = tokens[:]
.venv\Lib\site-packages\pip\_internal\req\req_file.py:461:    for token in tokens:
.venv\Lib\site-packages\pip\_internal\req\req_file.py:462:        if token.startswith("-") or token.startswith("--"):
.venv\Lib\site-packages\pip\_internal\req\req_file.py:465:            args.append(token)
.venv\Lib\site-packages\pip\_internal\utils\misc.py:468:        - "accesstoken@example.com" returns "****@example.com"
.venv\Lib\site-packages\pip\_internal\utils\setuptools_build.py:20:    import os, sys, tokenize, traceback
.venv\Lib\site-packages\pip\_internal\utils\setuptools_build.py:38:        with tokenize.open(__file__) as f:
.venv\Lib\site-packages\pip\_vendor\distlib\compat.py:365:    from tokenize import detect_encoding
.venv\Lib\site-packages\pip\_vendor\distlib\compat.py:372:        """Imitates get_normal_name in tokenizer.c."""
.venv\Lib\site-packages\pip\_vendor\distlib\compat.py:386:        in the same way as the tokenize() generator.
.venv\Lib\site-packages\pip\_vendor\distro\distro.py:1121:        tokens = list(lexer)
.venv\Lib\site-packages\pip\_vendor\distro\distro.py:1122:        for token in tokens:
.venv\Lib\site-packages\pip\_vendor\distro\distro.py:1126:            # stripped, etc.), so the tokens are now either:
.venv\Lib\site-packages\pip\_vendor\distro\distro.py:1129:            # Ignore any tokens that are not variable assignments
.venv\Lib\site-packages\pip\_vendor\distro\distro.py:1130:            if "=" in token:
.venv\Lib\site-packages\pip\_vendor\distro\distro.py:1131:                k, v = token.split("=", 1)
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:67:    # Pad any parentheses so tokenization can be achieved by merely splitting on
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:81:    tokens = license_expression.split()
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:86:    python_tokens = []
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:87:    for token in tokens:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:88:        if token not in {"or", "and", "with", "(", ")"}:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:89:            python_tokens.append("False")
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:90:        elif token == "with":
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:91:            python_tokens.append("or")
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:92:        elif token == "(" and python_tokens and python_tokens[-1] not in {"or", "and"}:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:96:            python_tokens.append(token)
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:98:    python_expression = " ".join(python_tokens)
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:109:    normalized_tokens = []
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:110:    for token in tokens:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:111:        if token in {"or", "and", "with", "(", ")"}:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:112:            normalized_tokens.append(token.upper())
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:115:        if normalized_tokens and normalized_tokens[-1] == "WITH":
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:116:            if token not in EXCEPTIONS:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:117:                message = f"Unknown license exception: {token!r}"
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:120:            normalized_tokens.append(EXCEPTIONS[token]["id"])
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:122:            if token.endswith("+"):
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:123:                final_token = token[:-1]
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:126:                final_token = token
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:129:            if final_token.startswith("licenseref-"):
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:130:                if not license_ref_allowed.match(final_token):
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:131:                    message = f"Invalid licenseref: {final_token!r}"
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:133:                normalized_tokens.append(license_refs[final_token] + suffix)
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:135:                if final_token not in LICENSES:
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:136:                    message = f"Unknown license: {final_token!r}"
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:138:                normalized_tokens.append(LICENSES[final_token]["id"] + suffix)
.venv\Lib\site-packages\pip\_vendor\packaging\licenses\__init__.py:140:    normalized_expression = " ".join(normalized_tokens)
.venv\Lib\site-packages\pip\_vendor\packaging\markers.py:15:from ._tokenizer import ParserSyntaxError
.venv\Lib\site-packages\pip\_vendor\packaging\requirements.py:9:from ._tokenizer import ParserSyntaxError
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:12:from ._tokenizer import DEFAULT_RULES, Tokenizer
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:62:    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:65:def _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:69:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:71:    name_token = tokenizer.expect(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:74:    name = name_token.text
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:75:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:77:    extras = _parse_extras(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:78:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:80:    url, specifier, marker = _parse_requirement_details(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:81:    tokenizer.expect("END", expected="end of dependency specifier")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:87:    tokenizer: Tokenizer,
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:98:    if tokenizer.check("AT"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:99:        tokenizer.read()
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:100:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:102:        url_start = tokenizer.position
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:103:        url = tokenizer.expect("URL", expected="URL after @").text
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:104:        if tokenizer.check("END", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:107:        tokenizer.expect("WS", expected="whitespace after URL")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:110:        if tokenizer.check("END", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:114:            tokenizer, span_start=url_start, after="URL and whitespace"
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:117:        specifier_start = tokenizer.position
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:118:        specifier = _parse_specifier(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:119:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:121:        if tokenizer.check("END", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:125:            tokenizer,
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:138:    tokenizer: Tokenizer, *, span_start: int, after: str
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:144:    if not tokenizer.check("SEMICOLON"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:145:        tokenizer.raise_syntax_error(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:149:    tokenizer.read()
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:151:    marker = _parse_marker(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:152:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:157:def _parse_extras(tokenizer: Tokenizer) -> list[str]:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:161:    if not tokenizer.check("LEFT_BRACKET", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:164:    with tokenizer.enclosing_tokens(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:169:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:170:        extras = _parse_extras_list(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:171:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:176:def _parse_extras_list(tokenizer: Tokenizer) -> list[str]:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:182:    if not tokenizer.check("IDENTIFIER"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:185:    extras.append(tokenizer.read().text)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:188:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:189:        if tokenizer.check("IDENTIFIER", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:190:            tokenizer.raise_syntax_error("Expected comma between extra names")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:191:        elif not tokenizer.check("COMMA"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:194:        tokenizer.read()
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:195:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:197:        extra_token = tokenizer.expect("IDENTIFIER", expected="extra name after comma")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:198:        extras.append(extra_token.text)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:203:def _parse_specifier(tokenizer: Tokenizer) -> str:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:208:    with tokenizer.enclosing_tokens(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:213:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:214:        parsed_specifiers = _parse_version_many(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:215:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:220:def _parse_version_many(tokenizer: Tokenizer) -> str:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:225:    while tokenizer.check("SPECIFIER"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:226:        span_start = tokenizer.position
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:227:        parsed_specifiers += tokenizer.read().text
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:228:        if tokenizer.check("VERSION_PREFIX_TRAIL", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:229:            tokenizer.raise_syntax_error(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:232:                span_end=tokenizer.position + 1,
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:234:        if tokenizer.check("VERSION_LOCAL_LABEL_TRAIL", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:235:            tokenizer.raise_syntax_error(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:238:                span_end=tokenizer.position,
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:240:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:241:        if not tokenizer.check("COMMA"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:243:        parsed_specifiers += tokenizer.read().text
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:244:        tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:253:    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:256:def _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:257:    retval = _parse_marker(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:258:    tokenizer.expect("END", expected="end of marker expression")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:262:def _parse_marker(tokenizer: Tokenizer) -> MarkerList:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:266:    expression = [_parse_marker_atom(tokenizer)]
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:267:    while tokenizer.check("BOOLOP"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:268:        token = tokenizer.read()
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:269:        expr_right = _parse_marker_atom(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:270:        expression.extend((token.text, expr_right))
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:274:def _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:280:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:281:    if tokenizer.check("LEFT_PARENTHESIS", peek=True):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:282:        with tokenizer.enclosing_tokens(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:287:            tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:288:            marker: MarkerAtom = _parse_marker(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:289:            tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:291:        marker = _parse_marker_item(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:292:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:296:def _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:300:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:301:    marker_var_left = _parse_marker_var(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:302:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:303:    marker_op = _parse_marker_op(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:304:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:305:    marker_var_right = _parse_marker_var(tokenizer)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:306:    tokenizer.consume("WS")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:310:def _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:314:    if tokenizer.check("VARIABLE"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:315:        return process_env_var(tokenizer.read().text.replace(".", "_"))
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:316:    elif tokenizer.check("QUOTED_STRING"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:317:        return process_python_str(tokenizer.read().text)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:319:        tokenizer.raise_syntax_error(
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:336:def _parse_marker_op(tokenizer: Tokenizer) -> Op:
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:340:    if tokenizer.check("IN"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:341:        tokenizer.read()
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:343:    elif tokenizer.check("NOT"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:344:        tokenizer.read()
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:345:        tokenizer.expect("WS", expected="whitespace after 'not'")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:346:        tokenizer.expect("IN", expected="'in' after 'not'")
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:348:    elif tokenizer.check("OP"):
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:349:        return Op(tokenizer.read().text)
.venv\Lib\site-packages\pip\_vendor\packaging\_parser.py:351:        return tokenizer.raise_syntax_error(
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:12:class Token:
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:91:class Tokenizer:
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:92:    """Context-sensitive token parsing.
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:94:    Provides methods to examine the input stream to check whether the next token
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:108:        self.next_token: Token | None = None
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:112:        """Move beyond provided token name, if at current position."""
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:117:        """Check whether the next token has the provided name.
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:119:        By default, if the check succeeds, the token *must* be read before
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:120:        another check. If `peek` is set to `True`, the token is not loaded and
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:123:        assert self.next_token is None, (
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:124:            f"Cannot check for {name!r}, already have {self.next_token!r}"
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:126:        assert name in self.rules, f"Unknown token name: {name!r}"
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:134:            self.next_token = Token(name, match[0], self.position)
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:137:    def expect(self, name: str, *, expected: str) -> Token:
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:138:        """Expect a certain token name next, failing with a syntax error otherwise.
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:140:        The token is *not* read.
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:146:    def read(self) -> Token:
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:147:        """Consume the next token and return it."""
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:148:        token = self.next_token
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:149:        assert token is not None
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:151:        self.position += len(token.text)
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:152:        self.next_token = None
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:154:        return token
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:175:    def enclosing_tokens(
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:176:        self, open_token: str, close_token: str, *, around: str
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:178:        if self.check(open_token):
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:189:        if not self.check(close_token):
.venv\Lib\site-packages\pip\_vendor\packaging\_tokenizer.py:191:                f"Expected matching {close_token} for {open_token}, after {around}",
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:14:from pip._vendor.pygments.token import String, Comment, Keyword, Name, Error, Whitespace, \
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:15:    string_to_tokentype
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:716:    """Highlight a normal Name (and Name.*) token with a different token type.
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:722:            tokentype=Name.Function,
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:726:    as functions. `Name.Function` is the default token type.
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:731:      A list of names that should be given the different token type.
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:733:    `tokentype` : TokenType or string
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:734:      A token type or a string containing a token type name that is
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:742:        tokentype = options.get('tokentype')
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:743:        if tokentype:
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:744:            self.tokentype = string_to_tokentype(tokentype)
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:746:            self.tokentype = Name.Function
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:751:                yield self.tokentype, value
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:756:class ErrorToken(Exception):
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:760:class RaiseOnErrorTokenFilter(Filter):
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:761:    """Raise an exception when the lexer generates an error token.
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:767:      The default is `pygments.filters.ErrorToken`.
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:774:        self.exception = options.get('excclass', ErrorToken)
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:811:    `wstokentype` : bool
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:812:      If true, give whitespace the special `Whitespace` token type.  This allows
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:834:        self.wstt = get_bool_opt(options, 'wstokentype', True)
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:896:            # Remove ``left`` tokens from first line, ``n`` from all others.
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:907:class TokenMergeFilter(Filter):
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:908:    """Merges consecutive tokens with the same token type in the output
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:935:    'raiseonerror':   RaiseOnErrorTokenFilter,
.venv\Lib\site-packages\pip\_vendor\pygments\filters\__init__.py:938:    'tokenmerge':     TokenMergeFilter,
.venv\Lib\site-packages\pip\_vendor\pygments\formatter.py:27:    Converts a token stream to text.
.venv\Lib\site-packages\pip\_vendor\pygments\formatter.py:58:        convert the Unicode token strings to byte strings in the
.venv\Lib\site-packages\pip\_vendor\pygments\formatter.py:114:    def format(self, tokensource, outfile):
.venv\Lib\site-packages\pip\_vendor\pygments\formatter.py:116:        This method must format the tokens from the `tokensource` iterable and
.venv\Lib\site-packages\pip\_vendor\pygments\formatter.py:119:        Formatter options can control how exactly the tokens are converted.
.venv\Lib\site-packages\pip\_vendor\pygments\formatter.py:124:        return self.format_unencoded(tokensource, outfile)
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:5:    'BBCodeFormatter': ('pygments.formatters.bbcode', 'BBCode', ('bbcode', 'bb'), (), 'Format tokens with BBcodes. These formatting codes are used by many bulletin boards, so you can highlight your sourcecode with pygments before posting it there.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:8:    'GroffFormatter': ('pygments.formatters.groff', 'groff', ('groff', 'troff', 'roff'), (), 'Format tokens with groff escapes to change their color and font style.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:9:    'HtmlFormatter': ('pygments.formatters.html', 'HTML', ('html',), ('*.html', '*.htm'), "Format tokens as HTML 4 ``<span>`` tags. By default, the content is enclosed in a ``<pre>`` tag, itself wrapped in a ``<div>`` tag (but see the `nowrap` option). The ``<div>``'s CSS class can be set by the `cssclass` option."),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:10:    'IRCFormatter': ('pygments.formatters.irc', 'IRC', ('irc', 'IRC'), (), 'Format tokens with IRC color sequences'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:13:    'LatexFormatter': ('pygments.formatters.latex', 'LaTeX', ('latex', 'tex'), ('*.tex',), 'Format tokens as LaTeX code. This needs the `fancyvrb` and `color` standard packages.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:15:    'PangoMarkupFormatter': ('pygments.formatters.pangomarkup', 'Pango Markup', ('pango', 'pangomarkup'), (), 'Format tokens as Pango Markup code. It can then be rendered to an SVG.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:16:    'RawTokenFormatter': ('pygments.formatters.other', 'Raw tokens', ('raw', 'tokens'), ('*.raw',), 'Format tokens as a raw representation for storing token streams.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:17:    'RtfFormatter': ('pygments.formatters.rtf', 'RTF', ('rtf',), ('*.rtf',), 'Format tokens as RTF markup. This formatter automatically outputs full RTF documents with color information and other useful stuff. Perfect for Copy and Paste into Microsoft(R) Word(R) documents.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:18:    'SvgFormatter': ('pygments.formatters.svg', 'SVG', ('svg',), ('*.svg',), 'Format tokens as an SVG graphics file.  This formatter is still experimental. Each line of code is a ``<text>`` element with explicit ``x`` and ``y`` coordinates containing ``<tspan>`` elements with the individual token styles.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:19:    'Terminal256Formatter': ('pygments.formatters.terminal256', 'Terminal256', ('terminal256', 'console256', '256'), (), 'Format tokens with ANSI color sequences, for output in a 256-color terminal or console.  Like in `TerminalFormatter` color sequences are terminated at newlines, so that paging the output works correctly.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:20:    'TerminalFormatter': ('pygments.formatters.terminal', 'Terminal', ('terminal', 'console'), (), 'Format tokens with ANSI color sequences, for output in a text console. Color sequences are terminated at newlines, so that paging the output works correctly.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:21:    'TerminalTrueColorFormatter': ('pygments.formatters.terminal256', 'TerminalTrueColor', ('terminal16m', 'console16m', '16m'), (), 'Format tokens with ANSI color sequences, for output in a true-color terminal or console.  Like in `TerminalFormatter` color sequences are terminated at newlines, so that paging the output works correctly.'),
.venv\Lib\site-packages\pip\_vendor\pygments\formatters\_mapping.py:22:    'TestcaseFormatter': ('pygments.formatters.other', 'Testcase', ('testcase',), (), 'Format tokens as appropriate for a new testcase.'),
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:17:from pip._vendor.pygments.token import Error, Text, Other, Whitespace, _TokenType
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:255:    def get_tokens(self, text, unfiltered=False):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:259:        iterable of ``(tokentype, value)`` pairs from `text`.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:263:        (`stripnl`, `stripall` and so on), and then yields all tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:264:        from `get_tokens_unprocessed()`, with the ``index`` dropped.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:272:            for _, t, v in self.get_tokens_unprocessed(text):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:279:    def get_tokens_unprocessed(self, text):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:282:        ``(index, tokentype, value)`` tuples where ``index`` is the starting
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:283:        position of the token within the input text.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:295:    lexer, afterwards all ``Other`` tokens are lexed using the root
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:307:    def get_tokens_unprocessed(self, text):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:311:        for i, t, v in self.language_lexer.get_tokens_unprocessed(text):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:322:                             self.root_lexer.get_tokens_unprocessed(buffered))
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:395:            elif type(action) is _TokenType:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:454:            for i, t, v in lx.get_tokens_unprocessed(match.group(), **gt_kwargs):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:465:            for i, t, v in lx.get_tokens_unprocessed(match.group(), **gt_kwargs):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:475:    For example default('#pop') is equivalent to ('', Token, '#pop')
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:502:    Metaclass for RegexLexer, creates the self._tokens attribute from
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:503:    self.tokens on the first instantiation.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:507:        """Preprocess the regular expression component of a token definition."""
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:512:    def _process_token(cls, token):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:513:        """Preprocess the token component of a token definition."""
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:514:        assert type(token) is _TokenType or callable(token), \
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:515:            f'token type must be simple type or callable, not {token!r}'
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:516:        return token
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:519:        """Preprocess the state transition action of a token definition."""
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:536:            itokens = []
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:539:                itokens.extend(cls._process_state(unprocessed,
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:541:            processed[tmp_state] = itokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:559:        tokens = processed[state] = []
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:565:                tokens.extend(cls._process_state(unprocessed, processed,
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:575:                tokens.append((re.compile('').match, None, new_state))
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:585:            token = cls._process_token(tdef[1])
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:593:            tokens.append((rex, token, new_state))
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:594:        return tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:596:    def process_tokendef(cls, name, tokendefs=None):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:597:        """Preprocess a dictionary of token definitions."""
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:598:        processed = cls._all_tokens[name] = {}
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:599:        tokendefs = tokendefs or cls.tokens[name]
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:600:        for state in list(tokendefs):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:601:            cls._process_state(tokendefs, processed, state)
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:604:    def get_tokendefs(cls):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:606:        Merge tokens from superclasses in MRO order, returning a single tokendef
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:616:        tokens = {}
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:619:            toks = c.__dict__.get('tokens', {})
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:622:                curitems = tokens.get(state)
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:628:                    tokens[state] = items
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:651:        return tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:654:        """Instantiate cls after preprocessing its token definitions."""
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:655:        if '_tokens' not in cls.__dict__:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:656:            cls._all_tokens = {}
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:658:            if hasattr(cls, 'token_variants') and cls.token_variants:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:662:                cls._tokens = cls.process_tokendef('', cls.get_tokendefs())
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:681:    #: Dict of ``{'state': [(regex, tokentype, new_state), ...], ...}``
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:700:    tokens = {}
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:702:    def get_tokens_unprocessed(self, text, stack=('root',)):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:704:        Split ``text`` into (tokentype, text) pairs.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:709:        tokendefs = self._tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:711:        statetokens = tokendefs[statestack[-1]]
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:713:            for rexmatch, action, new_state in statetokens:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:717:                        if type(action) is _TokenType:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:745:                        statetokens = tokendefs[statestack[-1]]
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:748:                # We are here only if all state tokens have been considered
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:754:                        statetokens = tokendefs['root']
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:784:    def get_tokens_unprocessed(self, text=None, context=None):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:786:        Split ``text`` into (tokentype, text) pairs.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:789:        tokendefs = self._tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:792:            statetokens = tokendefs['root']
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:795:            statetokens = tokendefs[ctx.stack[-1]]
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:798:            for rexmatch, action, new_state in statetokens:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:802:                        if type(action) is _TokenType:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:809:                                statetokens = tokendefs[ctx.stack[-1]]
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:832:                        statetokens = tokendefs[ctx.stack[-1]]
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:841:                        statetokens = tokendefs['root']
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:851:def do_insertions(insertions, tokens):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:856:    ``insertions`` is a list of ``(index, itokens)`` pairs.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:857:    Each ``itokens`` iterable should be inserted at position
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:858:    ``index`` into the token stream given by the ``tokens``
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:861:    The result is a combined token stream.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:867:        index, itokens = next(insertions)
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:870:        yield from tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:876:    # iterate over the token stream where we want to insert
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:877:    # the tokens from the insertion list.
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:878:    for i, t, v in tokens:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:888:            for it_index, it_token, it_value in itokens:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:889:                yield realpos, it_token, it_value
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:893:                index, itokens = next(insertions)
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:901:    # leftover tokens
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:903:        # no normal tokens, set realpos to zero
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:905:        for p, t, v in itokens:
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:909:            index, itokens = next(insertions)
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:943:    def get_tokens_unprocessed(self, text, stack=('root',)):
.venv\Lib\site-packages\pip\_vendor\pygments\lexer.py:946:        yield from RegexLexer.get_tokens_unprocessed(self, text, stack)
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:16:from pip._vendor.pygments.token import Text, Comment, Operator, Keyword, Name, String, \
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:99:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:446:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:646:    Code tokens are output as ``Token.Other.Code``, traceback tokens as
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:647:    ``Token.Other.Traceback``.
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:649:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:715:        # different tokens.  TODO: DelegatingLexer should support this
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:717:        # distinguishing tokens. Then we wouldn't need this intermediary
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:741:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:798:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:842:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:1022:    tokens = {
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:1189:    def get_tokens_unprocessed(self, text):
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:1190:        for index, token, value in \
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:1191:                PythonLexer.get_tokens_unprocessed(self, text):
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:1192:            if token is Name and value in self.EXTRA_KEYWORDS:
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\python.py:1195:                yield index, token, value
.venv\Lib\site-packages\pip\_vendor\pygments\lexers\_mapping.py:439:    'RawTokenLexer': ('pip._vendor.pygments.lexers.special', 'Raw token data', (), (), ('application/x-pygments-tokens',)),
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:11:from pip._vendor.pygments.token import Token, STANDARD_TYPES
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:62:        for token in STANDARD_TYPES:
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:63:            if token not in obj.styles:
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:64:                obj.styles[token] = ''
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:84:            for token in ttype.split():
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:85:                if token in _styles:
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:87:                ndef = _styles.get(token.parent, None)
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:88:                styledefs = obj.styles.get(token, '').split()
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:89:                if not ndef or token is None:
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:91:                elif 'noinherit' in styledefs and token is not Token:
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:92:                    ndef = _styles[Token][:]
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:95:                _styles[token] = ndef
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:96:                for styledef in obj.styles.get(token, '').split():
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:126:    def style_for_token(cls, token):
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:127:        t = cls._styles[token]
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:159:    def styles_token(cls, ttype):
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:163:        for token in cls._styles:
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:164:            yield token, cls.style_for_token(token)
.venv\Lib\site-packages\pip\_vendor\pygments\style.py:190:    #: Style definitions for individual token types.
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:2:    pygments.token
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:5:    Basic token types and the standard tokens.
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:12:class _TokenType(tuple):
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:37:        new = _TokenType(self + (val,))
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:44:        return 'Token' + (self and '.' or '') + '.'.join(self)
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:55:Token = _TokenType()
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:57:# Special token types
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:58:Text = Token.Text
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:60:Escape = Token.Escape
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:61:Error = Token.Error
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:63:Other = Token.Other
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:65:# Common token types for source code
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:66:Keyword = Token.Keyword
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:67:Name = Token.Name
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:68:Literal = Token.Literal
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:71:Punctuation = Token.Punctuation
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:72:Operator = Token.Operator
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:73:Comment = Token.Comment
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:76:Generic = Token.Generic
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:78:# String and some others are not direct children of Token.
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:80:Token.Token = Token
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:81:Token.String = String
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:82:Token.Number = Number
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:85:def is_token_subtype(ttype, other):
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:94:def string_to_tokentype(s):
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:96:    Convert a string into a token type::
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:98:        >>> string_to_token('String.Double')
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:99:        Token.Literal.String.Double
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:100:        >>> string_to_token('Token.Literal.Number')
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:101:        Token.Literal.Number
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:102:        >>> string_to_token('')
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:103:        Token
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:105:    Tokens that are already tokens are returned unchanged:
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:107:        >>> string_to_token(String)
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:108:        Token.Literal.String
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:110:    if isinstance(s, _TokenType):
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:113:        return Token
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:114:    node = Token
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:120:# Map standard token types to short names, used in CSS class naming.
.venv\Lib\site-packages\pip\_vendor\pygments\token.py:124:    Token:                         '',
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:38:    and return an iterable of tokens. Currently, this only calls
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:39:    `lexer.get_tokens()`.
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:42:        return lexer.get_tokens(code)
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:52:def format(tokens, formatter, outfile=None):  # pylint: disable=redefined-builtin
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:54:    Format ``tokens`` (an iterable of tokens) with the formatter ``formatter``
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:64:            formatter.format(tokens, realoutfile)
.venv\Lib\site-packages\pip\_vendor\pygments\__init__.py:67:            formatter.format(tokens, outfile)
.venv\Lib\site-packages\pip\_vendor\requests\utils.py:388:    >>> parse_list_header('token, "quoted value"')
.venv\Lib\site-packages\pip\_vendor\requests\utils.py:389:    ['token', 'quoted value']
.venv\Lib\site-packages\pip\_vendor\requests\utils.py:522:    tokens = header.split(";")
.venv\Lib\site-packages\pip\_vendor\requests\utils.py:523:    content_type, params = tokens[0].strip(), tokens[1:]
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:20:class _AnsiToken(NamedTuple):
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:21:    """Result of ansi tokenized string."""
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:28:def _ansi_tokenize(ansi_text: str) -> Iterable[_AnsiToken]:
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:29:    """Tokenize a string in to plain text and ANSI codes.
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:35:        AnsiToken: A named tuple of (plain, sgr, osc)
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:45:            yield _AnsiToken(ansi_text[position:start])
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:51:                yield _AnsiToken("", sgr[1:-1], osc)
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:53:            yield _AnsiToken("", sgr, osc)
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:56:        yield _AnsiToken(ansi_text[position:])
.venv\Lib\site-packages\pip\_vendor\rich\ansi.py:153:        for plain_text, sgr, osc in _ansi_tokenize(line):
.venv\Lib\site-packages\pip\_vendor\rich\containers.py:157:                tokens: List[Text] = []
.venv\Lib\site-packages\pip\_vendor\rich\containers.py:161:                    tokens.append(word)
.venv\Lib\site-packages\pip\_vendor\rich\containers.py:166:                        tokens.append(Text(" " * spaces[index], style=space_style))
.venv\Lib\site-packages\pip\_vendor\rich\containers.py:167:                self[line_index] = Text("").join(tokens)
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:424:    def iter_tokens(self) -> Iterable[str]:
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:425:        """Generate tokens for this node."""
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:435:                    yield from self.children[0].iter_tokens()
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:439:                        yield from child.iter_tokens()
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:457:        for token in self.iter_tokens():
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:458:            total_length += cell_len(token)
.venv\Lib\site-packages\pip\_vendor\rich\pretty.py:464:        repr_text = "".join(self.iter_tokens())
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:25:from pip._vendor.pygments.token import (
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:34:    Token,
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:52:TokenType = Tuple[str, ...]
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:60:ANSI_LIGHT: Dict[TokenType, Style] = {
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:61:    Token: Style(),
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:89:ANSI_DARK: Dict[TokenType, Style] = {
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:90:    Token: Style(),
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:126:    def get_style_for_token(self, token_type: TokenType) -> Style:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:127:        """Get a style for a given Pygments token."""
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:140:        self._style_cache: Dict[TokenType, Style] = {}
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:152:    def get_style_for_token(self, token_type: TokenType) -> Style:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:155:            return self._style_cache[token_type]
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:158:                pygments_style = self._pygments_style_class.style_for_token(token_type)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:171:            self._style_cache[token_type] = style
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:181:    def __init__(self, style_map: Dict[TokenType, Style]) -> None:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:185:        self._style_cache: Dict[TokenType, Style] = {}
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:187:    def get_style_for_token(self, token_type: TokenType) -> Style:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:190:            return self._style_cache[token_type]
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:196:            token = tuple(token_type)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:198:            while token:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:199:                _style = get_style(token)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:203:                token = token[:-1]
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:204:            self._style_cache[token_type] = style
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:411:    def _get_token_color(self, token_type: TokenType) -> Optional[Color]:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:412:        """Get a color (if any) for the given token.
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:415:            token_type (TokenType): A token type tuple from Pygments.
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:420:        style = self._theme.get_style_for_token(token_type)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:478:        _get_theme_style = self._theme.get_style_for_token
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:490:                def line_tokenize() -> Iterable[Tuple[Any, str]]:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:491:                    """Split tokens to one per line."""
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:494:                    for token_type, token in lexer.get_tokens(code):
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:495:                        while token:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:496:                            line_token, new_line, token = token.partition("\n")
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:497:                            yield token_type, line_token + new_line
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:499:                def tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:500:                    """Convert tokens to spans."""
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:501:                    tokens = iter(line_tokenize())
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:505:                    # Skip over tokens until line start
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:508:                            _token_type, token = next(tokens)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:511:                        yield (token, None)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:512:                        if token.endswith("\n"):
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:515:                    for token_type, token in tokens:
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:516:                        yield (token, _get_theme_style(token_type))
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:517:                        if token.endswith("\n"):
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:522:                text.append_tokens(tokens_to_spans())
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:525:                text.append_tokens(
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:526:                    (token, _get_theme_style(token_type))
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:527:                    for token_type, token in lexer.get_tokens(code)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:563:        foreground_color = self._get_token_color(Token.Text)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:592:                self._theme.get_style_for_token(Token.Text),
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:598:                self._theme.get_style_for_token(Token.Text),
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:662:                + self._theme.get_style_for_token(Comment)
.venv\Lib\site-packages\pip\_vendor\rich\syntax.py:698:                + self._theme.get_style_for_token(Comment)
.venv\Lib\site-packages\pip\_vendor\rich\text.py:1031:    def append_tokens(
.venv\Lib\site-packages\pip\_vendor\rich\text.py:1032:        self, tokens: Iterable[Tuple[str, Optional[StyleType]]]
.venv\Lib\site-packages\pip\_vendor\rich\text.py:1037:            tokens (Iterable[Tuple[str, Optional[StyleType]]]): An iterable of tuples containing str content and style.
.venv\Lib\site-packages\pip\_vendor\rich\text.py:1046:        for content, style in tokens:
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:23:from pip._vendor.pygments.token import Comment, Keyword, Name, Number, Operator, String
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:24:from pip._vendor.pygments.token import Text as TextToken
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:25:from pip._vendor.pygments.token import Token
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:593:        token_style = theme.get_style_for_token
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:597:                "pretty": token_style(TextToken),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:598:                "pygments.text": token_style(Token),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:599:                "pygments.string": token_style(String),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:600:                "pygments.function": token_style(Name.Function),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:601:                "pygments.number": token_style(Number),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:602:                "repr.indent": token_style(Comment) + Style(dim=True),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:603:                "repr.str": token_style(String),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:604:                "repr.brace": token_style(TextToken) + Style(bold=True),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:605:                "repr.number": token_style(Number),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:606:                "repr.bool_true": token_style(Keyword.Constant),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:607:                "repr.bool_false": token_style(Keyword.Constant),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:608:                "repr.none": token_style(Keyword.Constant),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:609:                "scope.border": token_style(String.Delimiter),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:610:                "scope.equals": token_style(Operator),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:611:                "scope.key": token_style(Name),
.venv\Lib\site-packages\pip\_vendor\rich\traceback.py:612:                "scope.key.special": token_style(Name.Constant) + Style(dim=True),
.venv\Lib\site-packages\pip\_vendor\urllib3\connection.py:215:                "Method cannot contain non-token characters %r (found at least %r)"
.venv\Lib\site-packages\pyasn1\debug.py:139:    def push(self, token):
.venv\Lib\site-packages\pyasn1\debug.py:140:        self._list.append(token)
.venv\Lib\site-packages\pyasn1_modules\rfc2511.py:22:id_regCtrl_regToken = univ.ObjectIdentifier('1.3.6.1.5.5.7.5.1.1')
.venv\Lib\site-packages\pyasn1_modules\rfc2511.py:120:class RegToken(char.UTF8String):
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:87:# Need a place to import PKCS15Token; it does not yet appear in an RFC
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:256:# PKCS #12 token
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:265:# PKCS #15 token
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:267:pkcs_9_at_pkcs15Token = _OID(pkcs_9_at, 1)
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:269:# TODO: Once PKCS15Token can be imported, this can be included
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:271:# pKCS15Token = Attribute()
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:272:# userPKCS12['type'] = pkcs_9_at_pkcs15Token
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:273:# userPKCS12['values'][0] = PKCS15Token()
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:543:    # TODO: Once PKCS15Token can be imported, this can be included
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:544:    # pkcs_9_at_pkcs15Token: PKCS15Token(),
.venv\Lib\site-packages\pyasn1_modules\rfc2985.py:581:    # Attributes for use in PKCS #12 "PFX" PDUs or PKCS #15 tokens
.venv\Lib\site-packages\pyasn1_modules\rfc3161.py:132:class TimeStampToken(ContentInfo):
.venv\Lib\site-packages\pyasn1_modules\rfc3161.py:141:    namedtype.OptionalNamedType('timeStampToken', TimeStampToken())
.venv\Lib\site-packages\pyasn1_modules\rfc4211.py:384:id_regCtrl_regToken = _buildOid(id_regCtrl, 1)
.venv\Lib\site-packages\pyasn1_modules\rfc4211.py:395:class RegToken(char.UTF8String):
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:129:TimeStampToken = rfc3161.TimeStampToken
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:334:id_aa_signatureTimeStampToken = univ.ObjectIdentifier('1.2.840.113549.1.9.16.2.14')
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:337:class SignatureTimeStampToken(TimeStampToken):
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:346:class ContentTimestamp(TimeStampToken):
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:506:class ESCTimeStampToken(TimeStampToken):
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:515:class TimestampedCertsCRLs(TimeStampToken):
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:524:class ArchiveTimeStampToken(TimeStampToken):
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:563:    id_aa_signatureTimeStampToken: SignatureTimeStampToken(),
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:570:    id_aa_ets_escTimeStamp: ESCTimeStampToken(),
.venv\Lib\site-packages\pyasn1_modules\rfc5126.py:572:    id_aa_ets_archiveTimestampV2: ArchiveTimeStampToken(),
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:43:id_kisa_tac_token = id_kisa_tac + (1,)
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:46:id_kisa_tac_tokenandblindbash = id_kisa_tac + (2,)
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:49:id_kisa_tac_tokenandpartially = id_kisa_tac + (3,)
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:70:class Token(ContentInfo):
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:74:class TokenandBlindHash(ContentInfo):
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:78:class TokenandPartiallySignedCertificateHash(ContentInfo):
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:84:class TACToken(univ.Sequence):
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:91:class TACTokenandBlindHash(univ.Sequence):
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:93:        namedtype.NamedType('token', Token()),
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:98:class TACTokenandPartiallySignedCertificateHash(univ.Sequence):
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:100:        namedtype.NamedType('token', Token()),
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:108:    id_kisa_tac_token: TACToken(),
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:109:    id_kisa_tac_tokenandblindbash: TACTokenandBlindHash(),
.venv\Lib\site-packages\pyasn1_modules\rfc5636.py:110:    id_kisa_tac_tokenandpartially: TACTokenandPartiallySignedCertificateHash(),
.venv\Lib\site-packages\pyasn1_modules\rfc6402.py:82:    namedtype.NamedType('pendToken', univ.OctetString()),
.venv\Lib\site-packages\pycparser\c_lexer.py:12:from .ply.lex import TOKEN
.venv\Lib\site-packages\pycparser\c_lexer.py:17:        input text with input(), and call token() to get new
.venv\Lib\site-packages\pycparser\c_lexer.py:18:        tokens.
.venv\Lib\site-packages\pycparser\c_lexer.py:48:        # Keeps track of the last token returned from self.token()
.venv\Lib\site-packages\pycparser\c_lexer.py:49:        self.last_token = None
.venv\Lib\site-packages\pycparser\c_lexer.py:75:    def token(self):
.venv\Lib\site-packages\pycparser\c_lexer.py:76:        self.last_token = self.lexer.token()
.venv\Lib\site-packages\pycparser\c_lexer.py:77:        return self.last_token
.venv\Lib\site-packages\pycparser\c_lexer.py:79:    def find_tok_column(self, token):
.venv\Lib\site-packages\pycparser\c_lexer.py:80:        """ Find the column of the token in its line.
.venv\Lib\site-packages\pycparser\c_lexer.py:82:        last_cr = self.lexer.lexdata.rfind('\n', 0, token.lexpos)
.venv\Lib\site-packages\pycparser\c_lexer.py:83:        return token.lexpos - last_cr
.venv\Lib\site-packages\pycparser\c_lexer.py:90:    def _error(self, msg, token):
.venv\Lib\site-packages\pycparser\c_lexer.py:91:        location = self._make_tok_location(token)
.venv\Lib\site-packages\pycparser\c_lexer.py:95:    def _make_tok_location(self, token):
.venv\Lib\site-packages\pycparser\c_lexer.py:96:        return (token.lineno, self.find_tok_column(token))
.venv\Lib\site-packages\pycparser\c_lexer.py:127:    ## All the tokens recognized by the lexer
.venv\Lib\site-packages\pycparser\c_lexer.py:129:    tokens = keywords + keywords_new + (
.venv\Lib\site-packages\pycparser\c_lexer.py:191:    ## Regexes for use in tokens
.venv\Lib\site-packages\pycparser\c_lexer.py:308:    @TOKEN(string_literal)
.venv\Lib\site-packages\pycparser\c_lexer.py:315:    @TOKEN(decimal_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:440:    # lookahead token.  If we open a new scope in brace_open, then TT has
.venv\Lib\site-packages\pycparser\c_lexer.py:445:    @TOKEN(r'\{')
.venv\Lib\site-packages\pycparser\c_lexer.py:449:    @TOKEN(r'\}')
.venv\Lib\site-packages\pycparser\c_lexer.py:461:    @TOKEN(floating_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:465:    @TOKEN(hex_floating_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:469:    @TOKEN(hex_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:473:    @TOKEN(bin_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:477:    @TOKEN(bad_octal_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:482:    @TOKEN(unsupported_c_style_comment)
.venv\Lib\site-packages\pycparser\c_lexer.py:487:    @TOKEN(unsupported_cxx_style_comment)
.venv\Lib\site-packages\pycparser\c_lexer.py:492:    @TOKEN(octal_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:496:    @TOKEN(decimal_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:503:    @TOKEN(multicharacter_constant)
.venv\Lib\site-packages\pycparser\c_lexer.py:507:    @TOKEN(char_const)
.venv\Lib\site-packages\pycparser\c_lexer.py:511:    @TOKEN(wchar_const)
.venv\Lib\site-packages\pycparser\c_lexer.py:515:    @TOKEN(u8char_const)
.venv\Lib\site-packages\pycparser\c_lexer.py:519:    @TOKEN(u16char_const)
.venv\Lib\site-packages\pycparser\c_lexer.py:523:    @TOKEN(u32char_const)
.venv\Lib\site-packages\pycparser\c_lexer.py:527:    @TOKEN(unmatched_quote)
.venv\Lib\site-packages\pycparser\c_lexer.py:532:    @TOKEN(bad_char_const)
.venv\Lib\site-packages\pycparser\c_lexer.py:537:    @TOKEN(wstring_literal)
.venv\Lib\site-packages\pycparser\c_lexer.py:541:    @TOKEN(u8string_literal)
.venv\Lib\site-packages\pycparser\c_lexer.py:545:    @TOKEN(u16string_literal)
.venv\Lib\site-packages\pycparser\c_lexer.py:549:    @TOKEN(u32string_literal)
.venv\Lib\site-packages\pycparser\c_lexer.py:555:    @TOKEN(bad_string_literal)
.venv\Lib\site-packages\pycparser\c_lexer.py:560:    @TOKEN(identifier)
.venv\Lib\site-packages\pycparser\c_parser.py:87:        self.tokens = self.clex.tokens
.venv\Lib\site-packages\pycparser\c_parser.py:127:        # Keeps track of the last token given to yacc (the lookahead token)
.venv\Lib\site-packages\pycparser\c_parser.py:128:        self._last_yielded_token = None
.venv\Lib\site-packages\pycparser\c_parser.py:146:        self._last_yielded_token = None
.venv\Lib\site-packages\pycparser\c_parser.py:208:    def _get_yacc_lookahead_token(self):
.venv\Lib\site-packages\pycparser\c_parser.py:209:        """ We need access to yacc's lookahead token in certain cases.
.venv\Lib\site-packages\pycparser\c_parser.py:210:            This is the last token yacc requested from the lexer, so we
.venv\Lib\site-packages\pycparser\c_parser.py:213:        return self.clex.last_token
.venv\Lib\site-packages\pycparser\c_parser.py:474:    def _select_struct_union_class(self, token):
.venv\Lib\site-packages\pycparser\c_parser.py:475:        """ Given a token (either STRUCT or UNION), selects the
.venv\Lib\site-packages\pycparser\c_parser.py:478:        if token == 'struct':
.venv\Lib\site-packages\pycparser\c_parser.py:564:            p[0] = [c_ast.StaticAssert(p[3], None, self._token_coord(p, 1))]
.venv\Lib\site-packages\pycparser\c_parser.py:566:            p[0] = [c_ast.StaticAssert(p[3], p[5], self._token_coord(p, 1))]
.venv\Lib\site-packages\pycparser\c_parser.py:572:                          self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:585:            p[0] = c_ast.Pragma(p[3], self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:587:            p[0] = c_ast.Pragma(p[2], self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:589:            p[0] = c_ast.Pragma("", self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:608:                                       coord=self._token_coord(p, 1))],
.venv\Lib\site-packages\pycparser\c_parser.py:694:                coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:760:    # the parser's lookahead asked for the token after SEMI, which
.venv\Lib\site-packages\pycparser\c_parser.py:880:        p[0] = c_ast.IdentifierType([p[1]], coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:978:            coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:990:                coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:995:                coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:1010:                coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:1015:                coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:1109:        p[0] = c_ast.Enum(p[2], None, self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1114:        p[0] = c_ast.Enum(None, p[3], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1120:        p[0] = c_ast.Enum(p[2], p[4], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1139:        p[0] = c_ast.Alignas(p[3], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1148:                        self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1152:                        self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1184:            coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1235:            dim=c_ast.ID(p[4], self._token_coord(p, 4)),
.venv\Lib\site-packages\pycparser\c_parser.py:1251:        # To see why _get_yacc_lookahead_token is needed, consider:
.venv\Lib\site-packages\pycparser\c_parser.py:1256:        # yacc's lookahead token.  We don't know if we're declaring or
.venv\Lib\site-packages\pycparser\c_parser.py:1258:        # trigger a rule on that token, then TT will have already been read
.venv\Lib\site-packages\pycparser\c_parser.py:1262:        if self._get_yacc_lookahead_token().type == "LBRACE":
.venv\Lib\site-packages\pycparser\c_parser.py:1274:        coord = self._token_coord(p, 1)
.venv\Lib\site-packages\pycparser\c_parser.py:1311:            p[1].params.append(c_ast.EllipsisParam(self._token_coord(p, 3)))
.venv\Lib\site-packages\pycparser\c_parser.py:1342:                coord=self._token_coord(p, 1))]
.venv\Lib\site-packages\pycparser\c_parser.py:1353:                coord=self._token_coord(p, 1))]
.venv\Lib\site-packages\pycparser\c_parser.py:1373:                coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:1399:            p[0] = c_ast.InitList([], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1443:            coord=self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:1493:            coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1500:            dim=c_ast.ID(p[3], self._token_coord(p, 3)),
.venv\Lib\site-packages\pycparser\c_parser.py:1511:            dim=c_ast.ID(p[3], self._token_coord(p, 3)),
.venv\Lib\site-packages\pycparser\c_parser.py:1513:            coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1531:            coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1545:            coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1569:            coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1573:        p[0] = c_ast.Label(p[1], p[3], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1577:        p[0] = c_ast.Case(p[2], [p[4]], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1581:        p[0] = c_ast.Default([p[3]], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1585:        p[0] = c_ast.Label(p[1], c_ast.EmptyStatement(self._token_coord(p, 1)), self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1589:        p[0] = c_ast.Case(p[2], [c_ast.EmptyStatement(self._token_coord(p, 2))], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1593:        p[0] = c_ast.Default([c_ast.EmptyStatement(self._token_coord(p, 1))], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1597:        p[0] = c_ast.If(p[3], p[5], None, self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1601:        p[0] = c_ast.If(p[3], p[5], p[7], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1606:                c_ast.Switch(p[3], p[5], self._token_coord(p, 1)))
.venv\Lib\site-packages\pycparser\c_parser.py:1610:        p[0] = c_ast.While(p[3], p[5], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1614:        p[0] = c_ast.DoWhile(p[5], p[2], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1618:        p[0] = c_ast.For(p[3], p[5], p[7], p[9], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1622:        p[0] = c_ast.For(c_ast.DeclList(p[3], self._token_coord(p, 1)),
.venv\Lib\site-packages\pycparser\c_parser.py:1623:                         p[4], p[6], p[8], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1627:        p[0] = c_ast.Goto(p[2], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1631:        p[0] = c_ast.Break(self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1635:        p[0] = c_ast.Continue(self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1641:        p[0] = c_ast.Return(p[2] if len(p) == 4 else None, self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1646:            p[0] = c_ast.EmptyStatement(self._token_coord(p, 2))
.venv\Lib\site-packages\pycparser\c_parser.py:1669:        p[0] = c_ast.IdentifierType([p[1]], coord=self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1745:        p[0] = c_ast.Cast(p[2], p[4], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1766:            self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1798:        field = c_ast.ID(p[3], self._token_coord(p, 3))
.venv\Lib\site-packages\pycparser\c_parser.py:1834:        coord = self._token_coord(p, 1)
.venv\Lib\site-packages\pycparser\c_parser.py:1865:        p[0] = c_ast.ID(p[1], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1888:            prefix + 'int', p[1], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1902:            t, p[1], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1912:            'char', p[1], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1925:                'string', p[1], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1942:                'string', p[1], self._token_coord(p, 1))
.venv\Lib\site-packages\pycparser\c_parser.py:1965:        # _get_yacc_lookahead_token still works!
.venv\Lib\site-packages\pycparser\lextab.py:3:_lextokens    = set(('AND', 'ANDEQUAL', 'ARROW', 'AUTO', 'BREAK', 'CASE', 'CHAR', 'CHAR_CONST', 'COLON', 'COMMA', 'CONDOP', 'CONST', 'CONTINUE', 'DEFAULT', 'DIVEQUAL', 'DIVIDE', 'DO', 'DOUBLE', 'ELLIPSIS', 'ELSE', 'ENUM', 'EQ', 'EQUALS', 'EXTERN', 'FLOAT', 'FLOAT_CONST', 'FOR', 'GE', 'GOTO', 'GT', 'HEX_FLOAT_CONST', 'ID', 'IF', 'INLINE', 'INT', 'INT_CONST_BIN', 'INT_CONST_CHAR', 'INT_CONST_DEC', 'INT_CONST_HEX', 'INT_CONST_OCT', 'LAND', 'LBRACE', 'LBRACKET', 'LE', 'LNOT', 'LONG', 'LOR', 'LPAREN', 'LSHIFT', 'LSHIFTEQUAL', 'LT', 'MINUS', 'MINUSEQUAL', 'MINUSMINUS', 'MOD', 'MODEQUAL', 'NE', 'NOT', 'OFFSETOF', 'OR', 'OREQUAL', 'PERIOD', 'PLUS', 'PLUSEQUAL', 'PLUSPLUS', 'PPHASH', 'PPPRAGMA', 'PPPRAGMASTR', 'RBRACE', 'RBRACKET', 'REGISTER', 'RESTRICT', 'RETURN', 'RPAREN', 'RSHIFT', 'RSHIFTEQUAL', 'SEMI', 'SHORT', 'SIGNED', 'SIZEOF', 'STATIC', 'STRING_LITERAL', 'STRUCT', 'SWITCH', 'TIMES', 'TIMESEQUAL', 'TYPEDEF', 'TYPEID', 'U16CHAR_CONST', 'U16STRING_LITERAL', 'U32CHAR_CONST', 'U32STRING_LITERAL', 'U8CHAR_CONST', 'U8STRING_LITERAL', 'UNION', 'UNSIGNED', 'VOID', 'VOLATILE', 'WCHAR_CONST', 'WHILE', 'WSTRING_LITERAL', 'XOR', 'XOREQUAL', '_ALIGNAS', '_ALIGNOF', '_ATOMIC', '_BOOL', '_COMPLEX', '_NORETURN', '_PRAGMA', '_STATIC_ASSERT', '_THREAD_LOCAL', '__INT128'))
.venv\Lib\site-packages\pycparser\ply\cpp.py:20:# Default preprocessor lexer definitions.   These tokens are enough to get
.venv\Lib\site-packages\pycparser\ply\cpp.py:24:tokens = (
.venv\Lib\site-packages\pycparser\ply\cpp.py:130:#    .value     - Macro value (a list of tokens)
.venv\Lib\site-packages\pycparser\ply\cpp.py:135:# When a macro is created, the macro replacement token sequence is
.venv\Lib\site-packages\pycparser\ply\cpp.py:166:        # Probe the lexer for selected tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:175:    # tokenize()
.venv\Lib\site-packages\pycparser\ply\cpp.py:177:    # Utility function. Given a string of text, tokenize into a list of tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:180:    def tokenize(self,text):
.venv\Lib\site-packages\pycparser\ply\cpp.py:181:        tokens = []
.venv\Lib\site-packages\pycparser\ply\cpp.py:184:            tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:186:            tokens.append(tok)
.venv\Lib\site-packages\pycparser\ply\cpp.py:187:        return tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:202:    # the token types of symbols that are important to the preprocessor.
.venv\Lib\site-packages\pycparser\ply\cpp.py:204:    # with any suitable lexer regardless of how tokens have been named.
.venv\Lib\site-packages\pycparser\ply\cpp.py:209:        # Determine the token type for identifiers
.venv\Lib\site-packages\pycparser\ply\cpp.py:211:        tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:217:        # Determine the token type for integers
.venv\Lib\site-packages\pycparser\ply\cpp.py:219:        tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:226:        # Determine the token type for strings enclosed in double quotes
.venv\Lib\site-packages\pycparser\ply\cpp.py:228:        tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:234:        # Determine the token type for whitespace--if any
.venv\Lib\site-packages\pycparser\ply\cpp.py:236:        tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:242:        # Determine the token type for newlines
.venv\Lib\site-packages\pycparser\ply\cpp.py:244:        tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:247:            print("Couldn't determine token for newlines")
.venv\Lib\site-packages\pycparser\ply\cpp.py:257:            tok = self.lexer.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:295:            tok = lex.token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:307:    # tokenstrip()
.venv\Lib\site-packages\pycparser\ply\cpp.py:309:    # Remove leading/trailing whitespace tokens from a token list
.venv\Lib\site-packages\pycparser\ply\cpp.py:312:    def tokenstrip(self,tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:314:        while i < len(tokens) and tokens[i].type in self.t_WS:
.venv\Lib\site-packages\pycparser\ply\cpp.py:316:        del tokens[:i]
.venv\Lib\site-packages\pycparser\ply\cpp.py:317:        i = len(tokens)-1
.venv\Lib\site-packages\pycparser\ply\cpp.py:318:        while i >= 0 and tokens[i].type in self.t_WS:
.venv\Lib\site-packages\pycparser\ply\cpp.py:320:        del tokens[i+1:]
.venv\Lib\site-packages\pycparser\ply\cpp.py:321:        return tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:327:    # Collects comma separated arguments from a list of tokens.   The arguments
.venv\Lib\site-packages\pycparser\ply\cpp.py:328:    # must be enclosed in parenthesis.  Returns a tuple (tokencount,args,positions)
.venv\Lib\site-packages\pycparser\ply\cpp.py:329:    # where tokencount is the number of tokens consumed, args is a list of arguments,
.venv\Lib\site-packages\pycparser\ply\cpp.py:331:    # argument.  Each argument is represented by a list of tokens.
.venv\Lib\site-packages\pycparser\ply\cpp.py:340:    def collect_args(self,tokenlist):
.venv\Lib\site-packages\pycparser\ply\cpp.py:345:        tokenlen = len(tokenlist)
.venv\Lib\site-packages\pycparser\ply\cpp.py:349:        while (i < tokenlen) and (tokenlist[i].type in self.t_WS):
.venv\Lib\site-packages\pycparser\ply\cpp.py:352:        if (i < tokenlen) and (tokenlist[i].value == '('):
.venv\Lib\site-packages\pycparser\ply\cpp.py:355:            self.error(self.source,tokenlist[0].lineno,"Missing '(' in macro arguments")
.venv\Lib\site-packages\pycparser\ply\cpp.py:360:        while i < tokenlen:
.venv\Lib\site-packages\pycparser\ply\cpp.py:361:            t = tokenlist[i]
.venv\Lib\site-packages\pycparser\ply\cpp.py:369:                        args.append(self.tokenstrip(current_arg))
.venv\Lib\site-packages\pycparser\ply\cpp.py:374:                args.append(self.tokenstrip(current_arg))
.venv\Lib\site-packages\pycparser\ply\cpp.py:382:        self.error(self.source,tokenlist[-1].lineno,"Missing ')' in macro arguments")
.venv\Lib\site-packages\pycparser\ply\cpp.py:388:    # Examine the macro value (token sequence) and identify patch points
.venv\Lib\site-packages\pycparser\ply\cpp.py:431:    # Given a Macro and list of arguments (each a token list), this method
.venv\Lib\site-packages\pycparser\ply\cpp.py:432:    # returns an expanded version of a macro.  The return value is a token sequence
.venv\Lib\site-packages\pycparser\ply\cpp.py:433:    # representing the replacement macro tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:437:        # Make a copy of the macro token sequence
.venv\Lib\site-packages\pycparser\ply\cpp.py:481:    # Given a list of tokens, this function performs macro expansion.
.venv\Lib\site-packages\pycparser\ply\cpp.py:486:    def expand_macros(self,tokens,expanded=None):
.venv\Lib\site-packages\pycparser\ply\cpp.py:490:        while i < len(tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:491:            t = tokens[i]
.venv\Lib\site-packages\pycparser\ply\cpp.py:503:                        tokens[i:i+1] = ex
.venv\Lib\site-packages\pycparser\ply\cpp.py:508:                        while j < len(tokens) and tokens[j].type in self.t_WS:
.venv\Lib\site-packages\pycparser\ply\cpp.py:510:                        if tokens[j].value == '(':
.venv\Lib\site-packages\pycparser\ply\cpp.py:511:                            tokcount,args,positions = self.collect_args(tokens[j:])
.venv\Lib\site-packages\pycparser\ply\cpp.py:526:                                        args[len(m.arglist)-1] = tokens[j+positions[len(m.arglist)-1]:j+tokcount-1]
.venv\Lib\site-packages\pycparser\ply\cpp.py:534:                                tokens[i:j+tokcount] = rep
.venv\Lib\site-packages\pycparser\ply\cpp.py:543:        return tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:548:    # Evaluate an expression token sequence for the purposes of evaluating
.venv\Lib\site-packages\pycparser\ply\cpp.py:552:    def evalexpr(self,tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:553:        # tokens = tokenize(line)
.venv\Lib\site-packages\pycparser\ply\cpp.py:556:        while i < len(tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:557:            if tokens[i].type == self.t_ID and tokens[i].value == 'defined':
.venv\Lib\site-packages\pycparser\ply\cpp.py:561:                while j < len(tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:562:                    if tokens[j].type in self.t_WS:
.venv\Lib\site-packages\pycparser\ply\cpp.py:565:                    elif tokens[j].type == self.t_ID:
.venv\Lib\site-packages\pycparser\ply\cpp.py:566:                        if tokens[j].value in self.macros:
.venv\Lib\site-packages\pycparser\ply\cpp.py:571:                    elif tokens[j].value == '(':
.venv\Lib\site-packages\pycparser\ply\cpp.py:573:                    elif tokens[j].value == ')':
.venv\Lib\site-packages\pycparser\ply\cpp.py:576:                        self.error(self.source,tokens[i].lineno,"Malformed defined()")
.venv\Lib\site-packages\pycparser\ply\cpp.py:578:                tokens[i].type = self.t_INTEGER
.venv\Lib\site-packages\pycparser\ply\cpp.py:579:                tokens[i].value = self.t_INTEGER_TYPE(result)
.venv\Lib\site-packages\pycparser\ply\cpp.py:580:                del tokens[i+1:j+1]
.venv\Lib\site-packages\pycparser\ply\cpp.py:582:        tokens = self.expand_macros(tokens)
.venv\Lib\site-packages\pycparser\ply\cpp.py:583:        for i,t in enumerate(tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:585:                tokens[i] = copy.copy(t)
.venv\Lib\site-packages\pycparser\ply\cpp.py:586:                tokens[i].type = self.t_INTEGER
.venv\Lib\site-packages\pycparser\ply\cpp.py:587:                tokens[i].value = self.t_INTEGER_TYPE("0L")
.venv\Lib\site-packages\pycparser\ply\cpp.py:589:                tokens[i] = copy.copy(t)
.venv\Lib\site-packages\pycparser\ply\cpp.py:591:                tokens[i].value = str(tokens[i].value)
.venv\Lib\site-packages\pycparser\ply\cpp.py:592:                while tokens[i].value[-1] not in "0123456789abcdefABCDEF":
.venv\Lib\site-packages\pycparser\ply\cpp.py:593:                    tokens[i].value = tokens[i].value[:-1]
.venv\Lib\site-packages\pycparser\ply\cpp.py:595:        expr = "".join([str(x.value) for x in tokens])
.venv\Lib\site-packages\pycparser\ply\cpp.py:602:            self.error(self.source,tokens[0].lineno,"Couldn't evaluate expression")
.venv\Lib\site-packages\pycparser\ply\cpp.py:634:                # insert necessary whitespace instead of eaten tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:639:                dirtokens = self.tokenstrip(x[i+1:])
.venv\Lib\site-packages\pycparser\ply\cpp.py:640:                if dirtokens:
.venv\Lib\site-packages\pycparser\ply\cpp.py:641:                    name = dirtokens[0].value
.venv\Lib\site-packages\pycparser\ply\cpp.py:642:                    args = self.tokenstrip(dirtokens[1:])
.venv\Lib\site-packages\pycparser\ply\cpp.py:705:                        self.error(self.source,dirtokens[0].lineno,"Misplaced #elif")
.venv\Lib\site-packages\pycparser\ply\cpp.py:716:                        self.error(self.source,dirtokens[0].lineno,"Misplaced #else")
.venv\Lib\site-packages\pycparser\ply\cpp.py:722:                        self.error(self.source,dirtokens[0].lineno,"Misplaced #endif")
.venv\Lib\site-packages\pycparser\ply\cpp.py:742:    def include(self,tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:744:        if not tokens:
.venv\Lib\site-packages\pycparser\ply\cpp.py:746:        if tokens:
.venv\Lib\site-packages\pycparser\ply\cpp.py:747:            if tokens[0].value != '<' and tokens[0].type != self.t_STRING:
.venv\Lib\site-packages\pycparser\ply\cpp.py:748:                tokens = self.expand_macros(tokens)
.venv\Lib\site-packages\pycparser\ply\cpp.py:750:            if tokens[0].value == '<':
.venv\Lib\site-packages\pycparser\ply\cpp.py:753:                while i < len(tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:754:                    if tokens[i].value == '>':
.venv\Lib\site-packages\pycparser\ply\cpp.py:760:                filename = "".join([x.value for x in tokens[1:i]])
.venv\Lib\site-packages\pycparser\ply\cpp.py:762:            elif tokens[0].type == self.t_STRING:
.venv\Lib\site-packages\pycparser\ply\cpp.py:763:                filename = tokens[0].value[1:-1]
.venv\Lib\site-packages\pycparser\ply\cpp.py:791:    def define(self,tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:792:        if isinstance(tokens,STRING_TYPES):
.venv\Lib\site-packages\pycparser\ply\cpp.py:793:            tokens = self.tokenize(tokens)
.venv\Lib\site-packages\pycparser\ply\cpp.py:795:        linetok = tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:807:                m = Macro(name.value,self.tokenstrip(linetok[2:]))
.venv\Lib\site-packages\pycparser\ply\cpp.py:837:                    mvalue = self.tokenstrip(linetok[1+tokcount:])
.venv\Lib\site-packages\pycparser\ply\cpp.py:861:    def undef(self,tokens):
.venv\Lib\site-packages\pycparser\ply\cpp.py:862:        id = tokens[0].value
.venv\Lib\site-packages\pycparser\ply\cpp.py:878:    # token()
.venv\Lib\site-packages\pycparser\ply\cpp.py:880:    # Method to return individual tokens
.venv\Lib\site-packages\pycparser\ply\cpp.py:882:    def token(self):
.venv\Lib\site-packages\pycparser\ply\cpp.py:903:        tok = p.token()
.venv\Lib\site-packages\pycparser\ply\ctokens.py:2:# ctokens.py
.venv\Lib\site-packages\pycparser\ply\ctokens.py:4:# Token specifications for symbols in ANSI C and C++.  This file is
.venv\Lib\site-packages\pycparser\ply\ctokens.py:5:# meant to be used as a library in other tokenizers.
.venv\Lib\site-packages\pycparser\ply\ctokens.py:10:tokens = [
.venv\Lib\site-packages\pycparser\ply\lex.py:52:# This regular expression is used to match valid token names
.venv\Lib\site-packages\pycparser\ply\lex.py:55:# Exception thrown when invalid token encountered and no default error
.venv\Lib\site-packages\pycparser\ply\lex.py:63:# Token class.  This class is used to represent the tokens produced.
.venv\Lib\site-packages\pycparser\ply\lex.py:64:class LexToken(object):
.venv\Lib\site-packages\pycparser\ply\lex.py:66:        return 'LexToken(%s,%r,%d,%d)' % (self.type, self.value, self.lineno, self.lexpos)
.venv\Lib\site-packages\pycparser\ply\lex.py:108:#    token()          -  Get the next token
.venv\Lib\site-packages\pycparser\ply\lex.py:137:        self.lextokens = None         # List of valid tokens
.venv\Lib\site-packages\pycparser\ply\lex.py:182:            tf.write('_lextokens    = set(%s)\n' % repr(tuple(sorted(self.lextokens))))
.venv\Lib\site-packages\pycparser\ply\lex.py:221:        self.lextokens      = lextab._lextokens
.venv\Lib\site-packages\pycparser\ply\lex.py:224:        self.lextokens_all  = self.lextokens | set(self.lexliterals)
.venv\Lib\site-packages\pycparser\ply\lex.py:299:    # opttoken() - Return the next token from the Lexer
.venv\Lib\site-packages\pycparser\ply\lex.py:305:    def token(self):
.venv\Lib\site-packages\pycparser\ply\lex.py:324:                # Create a token for return
.venv\Lib\site-packages\pycparser\ply\lex.py:325:                tok = LexToken()
.venv\Lib\site-packages\pycparser\ply\lex.py:334:                    # If no token type was set, it's an ignored token
.venv\Lib\site-packages\pycparser\ply\lex.py:344:                # If token is processed by a function, call it
.venv\Lib\site-packages\pycparser\ply\lex.py:346:                tok.lexer = self      # Set additional attributes useful in token rules
.venv\Lib\site-packages\pycparser\ply\lex.py:352:                # Every function must return a token, if nothing, we just move to next token
.venv\Lib\site-packages\pycparser\ply\lex.py:358:                # Verify type of the token.  If not in the token map, raise an error
.venv\Lib\site-packages\pycparser\ply\lex.py:360:                    if newtok.type not in self.lextokens_all:
.venv\Lib\site-packages\pycparser\ply\lex.py:361:                        raise LexError("%s:%d: Rule '%s' returned an unknown token type '%s'" % (
.venv\Lib\site-packages\pycparser\ply\lex.py:369:                    tok = LexToken()
.venv\Lib\site-packages\pycparser\ply\lex.py:379:                    tok = LexToken()
.venv\Lib\site-packages\pycparser\ply\lex.py:399:            tok = LexToken()
.venv\Lib\site-packages\pycparser\ply\lex.py:419:        t = self.token()
.venv\Lib\site-packages\pycparser\ply\lex.py:437:# or as a .regex attribute attached by the @TOKEN decorator.
.venv\Lib\site-packages\pycparser\ply\lex.py:526:# def _statetoken(s,names)
.venv\Lib\site-packages\pycparser\ply\lex.py:529:# state names, this function returns a tuple (states,tokenname) where states
.venv\Lib\site-packages\pycparser\ply\lex.py:530:# is a tuple of state names and tokenname is the name of the token.  For example,
.venv\Lib\site-packages\pycparser\ply\lex.py:533:def _statetoken(s, names):
.venv\Lib\site-packages\pycparser\ply\lex.py:548:    tokenname = '_'.join(parts[i:])
.venv\Lib\site-packages\pycparser\ply\lex.py:549:    return (states, tokenname)
.venv\Lib\site-packages\pycparser\ply\lex.py:562:        self.tokens     = []
.venv\Lib\site-packages\pycparser\ply\lex.py:571:        self.get_tokens()
.venv\Lib\site-packages\pycparser\ply\lex.py:578:        self.validate_tokens()
.venv\Lib\site-packages\pycparser\ply\lex.py:583:    # Get the tokens map
.venv\Lib\site-packages\pycparser\ply\lex.py:584:    def get_tokens(self):
.venv\Lib\site-packages\pycparser\ply\lex.py:585:        tokens = self.ldict.get('tokens', None)
.venv\Lib\site-packages\pycparser\ply\lex.py:586:        if not tokens:
.venv\Lib\site-packages\pycparser\ply\lex.py:587:            self.log.error('No token list is defined')
.venv\Lib\site-packages\pycparser\ply\lex.py:591:        if not isinstance(tokens, (list, tuple)):
.venv\Lib\site-packages\pycparser\ply\lex.py:592:            self.log.error('tokens must be a list or tuple')
.venv\Lib\site-packages\pycparser\ply\lex.py:596:        if not tokens:
.venv\Lib\site-packages\pycparser\ply\lex.py:597:            self.log.error('tokens is empty')
.venv\Lib\site-packages\pycparser\ply\lex.py:601:        self.tokens = tokens
.venv\Lib\site-packages\pycparser\ply\lex.py:603:    # Validate the tokens
.venv\Lib\site-packages\pycparser\ply\lex.py:604:    def validate_tokens(self):
.venv\Lib\site-packages\pycparser\ply\lex.py:606:        for n in self.tokens:
.venv\Lib\site-packages\pycparser\ply\lex.py:608:                self.log.error("Bad token name '%s'", n)
.venv\Lib\site-packages\pycparser\ply\lex.py:611:                self.log.warning("Token '%s' multiply defined", n)
.venv\Lib\site-packages\pycparser\ply\lex.py:667:        self.toknames = {}        # Mapping of symbols to token names
.venv\Lib\site-packages\pycparser\ply\lex.py:685:            states, tokname = _statetoken(f, self.stateinfo)
.venv\Lib\site-packages\pycparser\ply\lex.py:779:                if tokname not in self.tokens and tokname.find('ignore_') < 0:
.venv\Lib\site-packages\pycparser\ply\lex.py:780:                    self.log.error("Rule '%s' defined for an unspecified token %s", name, tokname)
.venv\Lib\site-packages\pycparser\ply\lex.py:875:    global token, input
.venv\Lib\site-packages\pycparser\ply\lex.py:915:            token = lexobj.token
.venv\Lib\site-packages\pycparser\ply\lex.py:925:        debuglog.info('lex: tokens   = %r', linfo.tokens)
.venv\Lib\site-packages\pycparser\ply\lex.py:929:    # Build a dictionary of valid token names
.venv\Lib\site-packages\pycparser\ply\lex.py:930:    lexobj.lextokens = set()
.venv\Lib\site-packages\pycparser\ply\lex.py:931:    for n in linfo.tokens:
.venv\Lib\site-packages\pycparser\ply\lex.py:932:        lexobj.lextokens.add(n)
.venv\Lib\site-packages\pycparser\ply\lex.py:940:    lexobj.lextokens_all = lexobj.lextokens | set(lexobj.lexliterals)
.venv\Lib\site-packages\pycparser\ply\lex.py:1019:    # Create global versions of the token() and input() functions
.venv\Lib\site-packages\pycparser\ply\lex.py:1020:    token = lexobj.token
.venv\Lib\site-packages\pycparser\ply\lex.py:1072:        _token = lexer.token
.venv\Lib\site-packages\pycparser\ply\lex.py:1074:        _token = token
.venv\Lib\site-packages\pycparser\ply\lex.py:1077:        tok = _token()
.venv\Lib\site-packages\pycparser\ply\lex.py:1083:# @TOKEN(regex)
.venv\Lib\site-packages\pycparser\ply\lex.py:1089:def TOKEN(r):
.venv\Lib\site-packages\pycparser\ply\lex.py:1098:# Alternative spelling of the TOKEN decorator
.venv\Lib\site-packages\pycparser\ply\lex.py:1099:Token = TOKEN
.venv\Lib\site-packages\pycparser\ply\yacc.py:162:_token = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:164:_warnmsg = '''PLY: Don't use global functions errok(), token(), and restart() in p_error().
.venv\Lib\site-packages\pycparser\ply\yacc.py:169:        # Use parser.errok(), parser.token(), parser.restart()
.venv\Lib\site-packages\pycparser\ply\yacc.py:183:def token():
.venv\Lib\site-packages\pycparser\ply\yacc.py:185:    return _token()
.venv\Lib\site-packages\pycparser\ply\yacc.py:188:def call_errorfunc(errorfunc, token, parser):
.venv\Lib\site-packages\pycparser\ply\yacc.py:189:    global _errok, _token, _restart
.venv\Lib\site-packages\pycparser\ply\yacc.py:191:    _token = parser.token
.venv\Lib\site-packages\pycparser\ply\yacc.py:193:    r = errorfunc(token)
.venv\Lib\site-packages\pycparser\ply\yacc.py:195:        del _errok, _token, _restart
.venv\Lib\site-packages\pycparser\ply\yacc.py:308:    # the next look-ahead token.  This delayed invocation of the tokenizer can be useful in
.venv\Lib\site-packages\pycparser\ply\yacc.py:323:    def parse(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
.venv\Lib\site-packages\pycparser\ply\yacc.py:327:            return self.parsedebug(input, lexer, debug, tracking, tokenfunc)
.venv\Lib\site-packages\pycparser\ply\yacc.py:329:            return self.parseopt(input, lexer, debug, tracking, tokenfunc)
.venv\Lib\site-packages\pycparser\ply\yacc.py:331:            return self.parseopt_notrack(input, lexer, debug, tracking, tokenfunc)
.venv\Lib\site-packages\pycparser\ply\yacc.py:348:    def parsedebug(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
.venv\Lib\site-packages\pycparser\ply\yacc.py:376:        if tokenfunc is None:
.venv\Lib\site-packages\pycparser\ply\yacc.py:377:            # Tokenize function
.venv\Lib\site-packages\pycparser\ply\yacc.py:378:            get_token = lexer.token
.venv\Lib\site-packages\pycparser\ply\yacc.py:380:            get_token = tokenfunc
.venv\Lib\site-packages\pycparser\ply\yacc.py:382:        # Set the parser() token method (sometimes used in error recovery)
.venv\Lib\site-packages\pycparser\ply\yacc.py:383:        self.token = get_token
.venv\Lib\site-packages\pycparser\ply\yacc.py:393:        errtoken   = None               # Err token
.venv\Lib\site-packages\pycparser\ply\yacc.py:405:            # the next token off of the lookaheadstack or from the lexer
.venv\Lib\site-packages\pycparser\ply\yacc.py:415:                        lookahead = get_token()     # Get the next token
.venv\Lib\site-packages\pycparser\ply\yacc.py:511:                            lookaheadstack.append(lookahead)    # Save the current lookahead token
.venv\Lib\site-packages\pycparser\ply\yacc.py:553:                            lookaheadstack.append(lookahead)    # Save the current lookahead token
.venv\Lib\site-packages\pycparser\ply\yacc.py:582:                # this, we are going to push the current token onto
.venv\Lib\site-packages\pycparser\ply\yacc.py:583:                # the tokenstack and replace it with an 'error' token.
.venv\Lib\site-packages\pycparser\ply\yacc.py:587:                # In addition to pushing the error token, we call call
.venv\Lib\site-packages\pycparser\ply\yacc.py:594:                    errtoken = lookahead
.venv\Lib\site-packages\pycparser\ply\yacc.py:595:                    if errtoken.type == '$end':
.venv\Lib\site-packages\pycparser\ply\yacc.py:596:                        errtoken = None               # End of file!
.venv\Lib\site-packages\pycparser\ply\yacc.py:598:                        if errtoken and not hasattr(errtoken, 'lexer'):
.venv\Lib\site-packages\pycparser\ply\yacc.py:599:                            errtoken.lexer = lexer
.venv\Lib\site-packages\pycparser\ply\yacc.py:601:                        tok = call_errorfunc(self.errorfunc, errtoken, self)
.venv\Lib\site-packages\pycparser\ply\yacc.py:605:                            # returned token is the next lookahead
.venv\Lib\site-packages\pycparser\ply\yacc.py:607:                            errtoken = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:610:                        if errtoken:
.venv\Lib\site-packages\pycparser\ply\yacc.py:611:                            if hasattr(errtoken, 'lineno'):
.venv\Lib\site-packages\pycparser\ply\yacc.py:616:                                sys.stderr.write('yacc: Syntax error at line %d, token=%s\n' % (lineno, errtoken.type))
.venv\Lib\site-packages\pycparser\ply\yacc.py:618:                                sys.stderr.write('yacc: Syntax error, token=%s' % errtoken.type)
.venv\Lib\site-packages\pycparser\ply\yacc.py:627:                # entire parse has been rolled back and we're completely hosed.   The token is
.venv\Lib\site-packages\pycparser\ply\yacc.py:632:                    errtoken = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:639:                # at the end of the file. nuke the top entry and generate an error token
.venv\Lib\site-packages\pycparser\ply\yacc.py:695:    def parseopt(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
.venv\Lib\site-packages\pycparser\ply\yacc.py:720:        if tokenfunc is None:
.venv\Lib\site-packages\pycparser\ply\yacc.py:721:            # Tokenize function
.venv\Lib\site-packages\pycparser\ply\yacc.py:722:            get_token = lexer.token
.venv\Lib\site-packages\pycparser\ply\yacc.py:724:            get_token = tokenfunc
.venv\Lib\site-packages\pycparser\ply\yacc.py:726:        # Set the parser() token method (sometimes used in error recovery)
.venv\Lib\site-packages\pycparser\ply\yacc.py:727:        self.token = get_token
.venv\Lib\site-packages\pycparser\ply\yacc.py:737:        errtoken   = None               # Err token
.venv\Lib\site-packages\pycparser\ply\yacc.py:749:            # the next token off of the lookaheadstack or from the lexer
.venv\Lib\site-packages\pycparser\ply\yacc.py:755:                        lookahead = get_token()     # Get the next token
.venv\Lib\site-packages\pycparser\ply\yacc.py:828:                            lookaheadstack.append(lookahead)    # Save the current lookahead token
.venv\Lib\site-packages\pycparser\ply\yacc.py:867:                            lookaheadstack.append(lookahead)    # Save the current lookahead token
.venv\Lib\site-packages\pycparser\ply\yacc.py:888:                # this, we are going to push the current token onto
.venv\Lib\site-packages\pycparser\ply\yacc.py:889:                # the tokenstack and replace it with an 'error' token.
.venv\Lib\site-packages\pycparser\ply\yacc.py:893:                # In addition to pushing the error token, we call call
.venv\Lib\site-packages\pycparser\ply\yacc.py:900:                    errtoken = lookahead
.venv\Lib\site-packages\pycparser\ply\yacc.py:901:                    if errtoken.type == '$end':
.venv\Lib\site-packages\pycparser\ply\yacc.py:902:                        errtoken = None               # End of file!
.venv\Lib\site-packages\pycparser\ply\yacc.py:904:                        if errtoken and not hasattr(errtoken, 'lexer'):
.venv\Lib\site-packages\pycparser\ply\yacc.py:905:                            errtoken.lexer = lexer
.venv\Lib\site-packages\pycparser\ply\yacc.py:907:                        tok = call_errorfunc(self.errorfunc, errtoken, self)
.venv\Lib\site-packages\pycparser\ply\yacc.py:911:                            # returned token is the next lookahead
.venv\Lib\site-packages\pycparser\ply\yacc.py:913:                            errtoken = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:916:                        if errtoken:
.venv\Lib\site-packages\pycparser\ply\yacc.py:917:                            if hasattr(errtoken, 'lineno'):
.venv\Lib\site-packages\pycparser\ply\yacc.py:922:                                sys.stderr.write('yacc: Syntax error at line %d, token=%s\n' % (lineno, errtoken.type))
.venv\Lib\site-packages\pycparser\ply\yacc.py:924:                                sys.stderr.write('yacc: Syntax error, token=%s' % errtoken.type)
.venv\Lib\site-packages\pycparser\ply\yacc.py:933:                # entire parse has been rolled back and we're completely hosed.   The token is
.venv\Lib\site-packages\pycparser\ply\yacc.py:938:                    errtoken = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:945:                # at the end of the file. nuke the top entry and generate an error token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1001:    def parseopt_notrack(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
.venv\Lib\site-packages\pycparser\ply\yacc.py:1026:        if tokenfunc is None:
.venv\Lib\site-packages\pycparser\ply\yacc.py:1027:            # Tokenize function
.venv\Lib\site-packages\pycparser\ply\yacc.py:1028:            get_token = lexer.token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1030:            get_token = tokenfunc
.venv\Lib\site-packages\pycparser\ply\yacc.py:1032:        # Set the parser() token method (sometimes used in error recovery)
.venv\Lib\site-packages\pycparser\ply\yacc.py:1033:        self.token = get_token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1043:        errtoken   = None               # Err token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1055:            # the next token off of the lookaheadstack or from the lexer
.venv\Lib\site-packages\pycparser\ply\yacc.py:1061:                        lookahead = get_token()     # Get the next token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1125:                            lookaheadstack.append(lookahead)    # Save the current lookahead token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1159:                            lookaheadstack.append(lookahead)    # Save the current lookahead token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1180:                # this, we are going to push the current token onto
.venv\Lib\site-packages\pycparser\ply\yacc.py:1181:                # the tokenstack and replace it with an 'error' token.
.venv\Lib\site-packages\pycparser\ply\yacc.py:1185:                # In addition to pushing the error token, we call call
.venv\Lib\site-packages\pycparser\ply\yacc.py:1192:                    errtoken = lookahead
.venv\Lib\site-packages\pycparser\ply\yacc.py:1193:                    if errtoken.type == '$end':
.venv\Lib\site-packages\pycparser\ply\yacc.py:1194:                        errtoken = None               # End of file!
.venv\Lib\site-packages\pycparser\ply\yacc.py:1196:                        if errtoken and not hasattr(errtoken, 'lexer'):
.venv\Lib\site-packages\pycparser\ply\yacc.py:1197:                            errtoken.lexer = lexer
.venv\Lib\site-packages\pycparser\ply\yacc.py:1199:                        tok = call_errorfunc(self.errorfunc, errtoken, self)
.venv\Lib\site-packages\pycparser\ply\yacc.py:1203:                            # returned token is the next lookahead
.venv\Lib\site-packages\pycparser\ply\yacc.py:1205:                            errtoken = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:1208:                        if errtoken:
.venv\Lib\site-packages\pycparser\ply\yacc.py:1209:                            if hasattr(errtoken, 'lineno'):
.venv\Lib\site-packages\pycparser\ply\yacc.py:1214:                                sys.stderr.write('yacc: Syntax error at line %d, token=%s\n' % (lineno, errtoken.type))
.venv\Lib\site-packages\pycparser\ply\yacc.py:1216:                                sys.stderr.write('yacc: Syntax error, token=%s' % errtoken.type)
.venv\Lib\site-packages\pycparser\ply\yacc.py:1225:                # entire parse has been rolled back and we're completely hosed.   The token is
.venv\Lib\site-packages\pycparser\ply\yacc.py:1230:                    errtoken = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:1237:                # at the end of the file. nuke the top entry and generate an error token
.venv\Lib\site-packages\pycparser\ply\yacc.py:1552:            raise GrammarError('%s:%d: Illegal rule name %r. Already defined as a token' % (file, line, prodname))
.venv\Lib\site-packages\pycparser\ply\yacc.py:1558:        # Look for literal tokens
.venv\Lib\site-packages\pycparser\ply\yacc.py:1564:                        raise GrammarError('%s:%d: Literal token %s in rule %r may only be a single character' %
.venv\Lib\site-packages\pycparser\ply\yacc.py:1732:    # Find all symbols that were used the grammar, but not defined as tokens or
.venv\Lib\site-packages\pycparser\ply\yacc.py:2589:                                        # Shift precedence comes from the token
.venv\Lib\site-packages\pycparser\ply\yacc.py:2653:                                        # Shift precedence comes from the token
.venv\Lib\site-packages\pycparser\ply\yacc.py:2933:# start symbol, error function, tokens, precedence list, action functions,
.venv\Lib\site-packages\pycparser\ply\yacc.py:2941:        self.tokens     = None
.venv\Lib\site-packages\pycparser\ply\yacc.py:2955:        self.get_tokens()
.venv\Lib\site-packages\pycparser\ply\yacc.py:2963:        self.validate_tokens()
.venv\Lib\site-packages\pycparser\ply\yacc.py:2977:            if self.tokens:
.venv\Lib\site-packages\pycparser\ply\yacc.py:2978:                parts.append(' '.join(self.tokens))
.venv\Lib\site-packages\pycparser\ply\yacc.py:3057:    # Get the tokens map
.venv\Lib\site-packages\pycparser\ply\yacc.py:3058:    def get_tokens(self):
.venv\Lib\site-packages\pycparser\ply\yacc.py:3059:        tokens = self.pdict.get('tokens')
.venv\Lib\site-packages\pycparser\ply\yacc.py:3060:        if not tokens:
.venv\Lib\site-packages\pycparser\ply\yacc.py:3061:            self.log.error('No token list is defined')
.venv\Lib\site-packages\pycparser\ply\yacc.py:3065:        if not isinstance(tokens, (list, tuple)):
.venv\Lib\site-packages\pycparser\ply\yacc.py:3066:            self.log.error('tokens must be a list or tuple')
.venv\Lib\site-packages\pycparser\ply\yacc.py:3070:        if not tokens:
.venv\Lib\site-packages\pycparser\ply\yacc.py:3071:            self.log.error('tokens is empty')
.venv\Lib\site-packages\pycparser\ply\yacc.py:3075:        self.tokens = tokens
.venv\Lib\site-packages\pycparser\ply\yacc.py:3077:    # Validate the tokens
.venv\Lib\site-packages\pycparser\ply\yacc.py:3078:    def validate_tokens(self):
.venv\Lib\site-packages\pycparser\ply\yacc.py:3079:        # Validate the tokens.
.venv\Lib\site-packages\pycparser\ply\yacc.py:3080:        if 'error' in self.tokens:
.venv\Lib\site-packages\pycparser\ply\yacc.py:3081:            self.log.error("Illegal token name 'error'. Is a reserved word")
.venv\Lib\site-packages\pycparser\ply\yacc.py:3086:        for n in self.tokens:
.venv\Lib\site-packages\pycparser\ply\yacc.py:3088:                self.log.warning('Token %r multiply defined', n)
.venv\Lib\site-packages\pycparser\ply\yacc.py:3323:    grammar = Grammar(pinfo.tokens)
.venv\Lib\site-packages\pycparser\ply\yacc.py:3357:        errorlog.error('%s:%d: Symbol %r used, but not defined as a token or a rule', prod.file, prod.line, sym)
.venv\Lib\site-packages\pycparser\ply\yacc.py:3366:            errorlog.warning('Token %r defined, but not used', term)
.venv\Lib\site-packages\pycparser\ply\yacc.py:3383:        errorlog.warning('There is 1 unused token')
.venv\Lib\site-packages\pycparser\ply\yacc.py:3385:        errorlog.warning('There are %d unused tokens', len(unused_terminals))
.venv\Lib\site-packages\pycparser\plyparser.py:55:    def _token_coord(self, p, token_idx):
.venv\Lib\site-packages\pycparser\plyparser.py:57:            with 'token_idx'. The coordinate includes the 'lineno' and
.venv\Lib\site-packages\pycparser\plyparser.py:60:        last_cr = p.lexer.lexer.lexdata.rfind('\n', 0, p.lexpos(token_idx))
.venv\Lib\site-packages\pycparser\plyparser.py:63:        column = (p.lexpos(token_idx) - (last_cr))
.venv\Lib\site-packages\pycparser\plyparser.py:64:        return self._coord(p.lineno(token_idx), column)
.venv\Lib\site-packages\pydantic\_internal\_generics.py:413:        token = _generic_recursion_cache.set(previously_seen_type_refs)
.venv\Lib\site-packages\pydantic\_internal\_generics.py:415:        token = None
.venv\Lib\site-packages\pydantic\_internal\_generics.py:427:        if token:
.venv\Lib\site-packages\pydantic\_internal\_generics.py:428:            _generic_recursion_cache.reset(token)
.venv\Lib\site-packages\pydub\utils.py:242:        tokens = [x.strip() for x in re.split('[:,]', content_line) if x]
.venv\Lib\site-packages\pydub\utils.py:243:        extra_info[int(i.group('stream_id'))] = tokens
.venv\Lib\site-packages\pydub\utils.py:299:    for token in extra_info[stream['index']]:
.venv\Lib\site-packages\pydub\utils.py:300:        m = re.match('([su]([0-9]{1,2})p?) \(([0-9]{1,2}) bit\)$', token)
.venv\Lib\site-packages\pydub\utils.py:301:        m2 = re.match('([su]([0-9]{1,2})p?)( \(default\))?$', token)
.venv\Lib\site-packages\pydub\utils.py:310:        elif re.match('(flt)p?( \(default\))?$', token):
.venv\Lib\site-packages\pydub\utils.py:311:            set_property(stream, 'sample_fmt', token)
.venv\Lib\site-packages\pydub\utils.py:314:        elif re.match('(dbl)p?( \(default\))?$', token):
.venv\Lib\site-packages\pydub\utils.py:315:            set_property(stream, 'sample_fmt', token)
.venv\Lib\site-packages\requests\utils.py:378:    >>> parse_list_header('token, "quoted value"')
.venv\Lib\site-packages\requests\utils.py:379:    ['token', 'quoted value']
.venv\Lib\site-packages\requests\utils.py:512:    tokens = header.split(";")
.venv\Lib\site-packages\requests\utils.py:513:    content_type, params = tokens[0].strip(), tokens[1:]
.venv\Lib\site-packages\sniffio\_tests\test_sniffio.py:16:    token = current_async_library_cvar.set("generic-lib")
.venv\Lib\site-packages\sniffio\_tests\test_sniffio.py:20:        current_async_library_cvar.reset(token)
.venv\Lib\site-packages\stripe\apps\_secret.py:27:    A `user` scoped secret is accessible by the app backend and one specific Dashboard user. Use the `user` scope for per-user secrets like per-user OAuth tokens, where different users might have different permissions.
.venv\Lib\site-packages\stripe\checkout\_session.py:2299:    phone_number_collection: Optional[PhoneNumberCollection]
.venv\Lib\site-packages\stripe\checkout\_session.py:2756:        "phone_number_collection": PhoneNumberCollection,
.venv\Lib\site-packages\stripe\financial_connections\_transaction.py:76:    The token of the transaction refresh that last updated or created this transaction.
.venv\Lib\site-packages\stripe\identity\_verification_report.py:420:    The configuration token of a verification flow from the dashboard.
.venv\Lib\site-packages\stripe\identity\_verification_session.py:168:        Token referencing the associated Account of the related Person resource.
.venv\Lib\site-packages\stripe\identity\_verification_session.py:172:        Token referencing the related Person resource.
.venv\Lib\site-packages\stripe\identity\_verification_session.py:329:    The configuration token of a verification flow from the dashboard.
.venv\Lib\site-packages\stripe\issuing\_authorization.py:17:    from stripe.issuing._token import Token
.venv\Lib\site-packages\stripe\issuing\_authorization.py:192:            Literal["no_phone_number", "unsupported_phone_number"]
.venv\Lib\site-packages\stripe\issuing\_authorization.py:581:    token: Optional[ExpandableField["Token"]]
.venv\Lib\site-packages\stripe\issuing\_authorization.py:583:    [Token](https://stripe.com/docs/api/issuing/tokens/object) object used for this authorization. If a network token was not used for this authorization, this field will be null.
.venv\Lib\site-packages\stripe\issuing\_card.py:150:        phone_number: Optional[str]
.venv\Lib\site-packages\stripe\issuing\_cardholder.py:1173:    phone_number: Optional[str]
.venv\Lib\site-packages\stripe\issuing\_dispute.py:292:            "eci5_token_transaction_with_tavv",
.venv\Lib\site-packages\stripe\issuing\_token.py:14:    from stripe.params.issuing._token_list_params import TokenListParams
.venv\Lib\site-packages\stripe\issuing\_token.py:15:    from stripe.params.issuing._token_modify_params import TokenModifyParams
.venv\Lib\site-packages\stripe\issuing\_token.py:16:    from stripe.params.issuing._token_retrieve_params import (
.venv\Lib\site-packages\stripe\issuing\_token.py:17:        TokenRetrieveParams,
.venv\Lib\site-packages\stripe\issuing\_token.py:21:class Token(ListableAPIResource["Token"], UpdateableAPIResource["Token"]):
.venv\Lib\site-packages\stripe\issuing\_token.py:23:    An issuing token object is created when an issued card is added to a digital wallet. As a [card issuer](https://stripe.com/docs/issuing), you can [view and manage these tokens](https://stripe.com/docs/issuing/controls/token-management) through Stripe.
.venv\Lib\site-packages\stripe\issuing\_token.py:26:    OBJECT_NAME: ClassVar[Literal["issuing.token"]] = "issuing.token"
.venv\Lib\site-packages\stripe\issuing\_token.py:44:            The name of the device used for tokenization.
.venv\Lib\site-packages\stripe\issuing\_token.py:46:            phone_number: Optional[str]
.venv\Lib\site-packages\stripe\issuing\_token.py:48:            The phone number of the device used for tokenization.
.venv\Lib\site-packages\stripe\issuing\_token.py:52:            The type of device used for tokenization.
.venv\Lib\site-packages\stripe\issuing\_token.py:60:            token_reference_id: str
.venv\Lib\site-packages\stripe\issuing\_token.py:62:            The network-unique identifier for the token.
.venv\Lib\site-packages\stripe\issuing\_token.py:64:            token_requestor_id: str
.venv\Lib\site-packages\stripe\issuing\_token.py:66:            The ID of the entity requesting tokenization, specific to MasterCard.
.venv\Lib\site-packages\stripe\issuing\_token.py:68:            token_requestor_name: Optional[str]
.venv\Lib\site-packages\stripe\issuing\_token.py:70:            The name of the entity requesting tokenization, if known. This is directly provided from MasterCard.
.venv\Lib\site-packages\stripe\issuing\_token.py:78:            token_reference_id: str
.venv\Lib\site-packages\stripe\issuing\_token.py:80:            The network-unique identifier for the token.
.venv\Lib\site-packages\stripe\issuing\_token.py:82:            token_requestor_id: str
.venv\Lib\site-packages\stripe\issuing\_token.py:84:            The ID of the entity requesting tokenization, specific to Visa.
.venv\Lib\site-packages\stripe\issuing\_token.py:86:            token_risk_score: Optional[str]
.venv\Lib\site-packages\stripe\issuing\_token.py:88:            Degree of risk associated with the token between `01` and `99`, with higher number indicating higher risk. A `00` value indicates the token was not scored by Visa.
.venv\Lib\site-packages\stripe\issuing\_token.py:95:                The street address of the cardholder tokenizing the card.
.venv\Lib\site-packages\stripe\issuing\_token.py:99:                The postal code of the cardholder tokenizing the card.
.venv\Lib\site-packages\stripe\issuing\_token.py:104:            The wallet provider-given account ID of the digital wallet the token belongs to.
.venv\Lib\site-packages\stripe\issuing\_token.py:114:            The method used for tokenizing a card.
.venv\Lib\site-packages\stripe\issuing\_token.py:119:            The name of the cardholder tokenizing the card.
.venv\Lib\site-packages\stripe\issuing\_token.py:141:                        "has_suspended_tokens",
.venv\Lib\site-packages\stripe\issuing\_token.py:147:                        "low_phone_number_score",
.venv\Lib\site-packages\stripe\issuing\_token.py:159:                        "too_many_recent_tokens",
.venv\Lib\site-packages\stripe\issuing\_token.py:164:            The reasons for suggested tokenization given by the card network.
.venv\Lib\site-packages\stripe\issuing\_token.py:170:            The recommendation on responding to the tokenization request.
.venv\Lib\site-packages\stripe\issuing\_token.py:182:        The network that the token is associated with. An additional hash is included with a name matching this value, containing tokenization data specific to the card network.
.venv\Lib\site-packages\stripe\issuing\_token.py:195:    Card associated with this token.
.venv\Lib\site-packages\stripe\issuing\_token.py:203:    The hashed ID derived from the device ID from the card network associated with the token.
.venv\Lib\site-packages\stripe\issuing\_token.py:211:    The last four digits of the token.
.venv\Lib\site-packages\stripe\issuing\_token.py:219:    The token service provider / card network associated with the token.
.venv\Lib\site-packages\stripe\issuing\_token.py:224:    Time at which the token was last updated by the card network. Measured in seconds since the Unix epoch.
.venv\Lib\site-packages\stripe\issuing\_token.py:226:    object: Literal["issuing.token"]
.venv\Lib\site-packages\stripe\issuing\_token.py:232:    The usage state of the token.
.venv\Lib\site-packages\stripe\issuing\_token.py:238:    The digital wallet for this token, if one was used.
.venv\Lib\site-packages\stripe\issuing\_token.py:242:    def list(cls, **params: Unpack["TokenListParams"]) -> ListObject["Token"]:
.venv\Lib\site-packages\stripe\issuing\_token.py:244:        Lists all Issuing Token objects for a given card.
.venv\Lib\site-packages\stripe\issuing\_token.py:261:        cls, **params: Unpack["TokenListParams"]
.venv\Lib\site-packages\stripe\issuing\_token.py:262:    ) -> ListObject["Token"]:
.venv\Lib\site-packages\stripe\issuing\_token.py:264:        Lists all Issuing Token objects for a given card.
.venv\Lib\site-packages\stripe\issuing\_token.py:280:    def modify(cls, id: str, **params: Unpack["TokenModifyParams"]) -> "Token":
.venv\Lib\site-packages\stripe\issuing\_token.py:282:        Attempts to update the specified Issuing Token object to the status specified.
.venv\Lib\site-packages\stripe\issuing\_token.py:286:            "Token",
.venv\Lib\site-packages\stripe\issuing\_token.py:296:        cls, id: str, **params: Unpack["TokenModifyParams"]
.venv\Lib\site-packages\stripe\issuing\_token.py:297:    ) -> "Token":
.venv\Lib\site-packages\stripe\issuing\_token.py:299:        Attempts to update the specified Issuing Token object to the status specified.
.venv\Lib\site-packages\stripe\issuing\_token.py:303:            "Token",
.venv\Lib\site-packages\stripe\issuing\_token.py:313:        cls, id: str, **params: Unpack["TokenRetrieveParams"]
.venv\Lib\site-packages\stripe\issuing\_token.py:314:    ) -> "Token":
.venv\Lib\site-packages\stripe\issuing\_token.py:316:        Retrieves an Issuing Token object.
.venv\Lib\site-packages\stripe\issuing\_token.py:324:        cls, id: str, **params: Unpack["TokenRetrieveParams"]
.venv\Lib\site-packages\stripe\issuing\_token.py:325:    ) -> "Token":
.venv\Lib\site-packages\stripe\issuing\_token.py:327:        Retrieves an Issuing Token object.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:7:from stripe.issuing._token import Token
.venv\Lib\site-packages\stripe\issuing\_token_service.py:12:    from stripe.params.issuing._token_list_params import TokenListParams
.venv\Lib\site-packages\stripe\issuing\_token_service.py:13:    from stripe.params.issuing._token_retrieve_params import (
.venv\Lib\site-packages\stripe\issuing\_token_service.py:14:        TokenRetrieveParams,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:16:    from stripe.params.issuing._token_update_params import TokenUpdateParams
.venv\Lib\site-packages\stripe\issuing\_token_service.py:19:class TokenService(StripeService):
.venv\Lib\site-packages\stripe\issuing\_token_service.py:22:        params: "TokenListParams",
.venv\Lib\site-packages\stripe\issuing\_token_service.py:24:    ) -> ListObject[Token]:
.venv\Lib\site-packages\stripe\issuing\_token_service.py:26:        Lists all Issuing Token objects for a given card.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:29:            ListObject[Token],
.venv\Lib\site-packages\stripe\issuing\_token_service.py:32:                "/v1/issuing/tokens",
.venv\Lib\site-packages\stripe\issuing\_token_service.py:41:        params: "TokenListParams",
.venv\Lib\site-packages\stripe\issuing\_token_service.py:43:    ) -> ListObject[Token]:
.venv\Lib\site-packages\stripe\issuing\_token_service.py:45:        Lists all Issuing Token objects for a given card.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:48:            ListObject[Token],
.venv\Lib\site-packages\stripe\issuing\_token_service.py:51:                "/v1/issuing/tokens",
.venv\Lib\site-packages\stripe\issuing\_token_service.py:60:        token: str,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:61:        params: Optional["TokenRetrieveParams"] = None,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:63:    ) -> Token:
.venv\Lib\site-packages\stripe\issuing\_token_service.py:65:        Retrieves an Issuing Token object.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:68:            Token,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:71:                "/v1/issuing/tokens/{token}".format(token=sanitize_id(token)),
.venv\Lib\site-packages\stripe\issuing\_token_service.py:80:        token: str,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:81:        params: Optional["TokenRetrieveParams"] = None,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:83:    ) -> Token:
.venv\Lib\site-packages\stripe\issuing\_token_service.py:85:        Retrieves an Issuing Token object.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:88:            Token,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:91:                "/v1/issuing/tokens/{token}".format(token=sanitize_id(token)),
.venv\Lib\site-packages\stripe\issuing\_token_service.py:100:        token: str,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:101:        params: "TokenUpdateParams",
.venv\Lib\site-packages\stripe\issuing\_token_service.py:103:    ) -> Token:
.venv\Lib\site-packages\stripe\issuing\_token_service.py:105:        Attempts to update the specified Issuing Token object to the status specified.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:108:            Token,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:111:                "/v1/issuing/tokens/{token}".format(token=sanitize_id(token)),
.venv\Lib\site-packages\stripe\issuing\_token_service.py:120:        token: str,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:121:        params: "TokenUpdateParams",
.venv\Lib\site-packages\stripe\issuing\_token_service.py:123:    ) -> Token:
.venv\Lib\site-packages\stripe\issuing\_token_service.py:125:        Attempts to update the specified Issuing Token object to the status specified.
.venv\Lib\site-packages\stripe\issuing\_token_service.py:128:            Token,
.venv\Lib\site-packages\stripe\issuing\_token_service.py:131:                "/v1/issuing/tokens/{token}".format(token=sanitize_id(token)),
.venv\Lib\site-packages\stripe\issuing\_transaction.py:19:    from stripe.issuing._token import Token
.venv\Lib\site-packages\stripe\issuing\_transaction.py:422:    token: Optional[ExpandableField["Token"]]
.venv\Lib\site-packages\stripe\issuing\_transaction.py:424:    [Token](https://stripe.com/docs/api/issuing/tokens/object) object used for this transaction. If a network token was not used for this transaction, this field will be null.
.venv\Lib\site-packages\stripe\issuing\__init__.py:25:from stripe.issuing._token import Token as Token
.venv\Lib\site-packages\stripe\issuing\__init__.py:26:from stripe.issuing._token_service import TokenService as TokenService
.venv\Lib\site-packages\stripe\params\checkout\_session_create_params.py:355:    phone_number_collection: NotRequired[
.venv\Lib\site-packages\stripe\params\identity\_verification_session_create_params.py:37:    Tokens referencing a Person resource and it's associated account.
.venv\Lib\site-packages\stripe\params\identity\_verification_session_create_params.py:97:    A token representing a connected account. If provided, the person parameter is also required and must be associated with the account.
.venv\Lib\site-packages\stripe\params\identity\_verification_session_create_params.py:101:    A token referencing a Person resource that this verification is being used to verify.
.venv\Lib\site-packages\stripe\params\issuing\_cardholder_create_params.py:37:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_cardholder_list_params.py:29:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_cardholder_modify_params.py:33:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_cardholder_update_params.py:32:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_card_create_params.py:103:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_card_modify_params.py:66:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_card_update_params.py:65:    phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\params\issuing\_token_list_params.py:8:class TokenListParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\issuing\_token_list_params.py:11:    The Issuing card identifier to list tokens for.
.venv\Lib\site-packages\stripe\params\issuing\_token_list_params.py:13:    created: NotRequired["TokenListParamsCreated|int"]
.venv\Lib\site-packages\stripe\params\issuing\_token_list_params.py:15:    Only return Issuing tokens that were created during the given date interval.
.venv\Lib\site-packages\stripe\params\issuing\_token_list_params.py:35:    Select Issuing tokens with the given status.
.venv\Lib\site-packages\stripe\params\issuing\_token_list_params.py:39:class TokenListParamsCreated(TypedDict):
.venv\Lib\site-packages\stripe\params\issuing\_token_modify_params.py:8:class TokenModifyParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\issuing\_token_modify_params.py:15:    Specifies which status the token should be updated to.
.venv\Lib\site-packages\stripe\params\issuing\_token_retrieve_params.py:8:class TokenRetrieveParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\issuing\_token_update_params.py:7:class TokenUpdateParams(TypedDict):
.venv\Lib\site-packages\stripe\params\issuing\_token_update_params.py:14:    Specifies which status the token should be updated to.
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:135:from stripe.params.issuing._token_list_params import (
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:136:    TokenListParams as TokenListParams,
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:138:from stripe.params.issuing._token_modify_params import (
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:139:    TokenModifyParams as TokenModifyParams,
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:141:from stripe.params.issuing._token_retrieve_params import (
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:142:    TokenRetrieveParams as TokenRetrieveParams,
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:144:from stripe.params.issuing._token_update_params import (
.venv\Lib\site-packages\stripe\params\issuing\__init__.py:145:    TokenUpdateParams as TokenUpdateParams,
.venv\Lib\site-packages\stripe\params\terminal\_connection_token_create_params.py:8:class ConnectionTokenCreateParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\terminal\_connection_token_create_params.py:15:    The id of the location that this connection token is scoped to. If specified the connection token will only be usable with readers assigned to that location, otherwise the connection token will be usable with all readers. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://docs.stripe.com/terminal/fleet/locations-and-zones?dashboard-or-api=api#connection-tokens).
.venv\Lib\site-packages\stripe\params\terminal\__init__.py:21:from stripe.params.terminal._connection_token_create_params import (
.venv\Lib\site-packages\stripe\params\terminal\__init__.py:22:    ConnectionTokenCreateParams as ConnectionTokenCreateParams,
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:7:class ConfirmationTokenCreateParams(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:17:        "ConfirmationTokenCreateParamsPaymentMethodData"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:23:        "ConfirmationTokenCreateParamsPaymentMethodOptions"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:26:    Payment-method-specific configuration for this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:34:    Indicates that you intend to make future payments with this ConfirmationToken's payment method.
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:38:    shipping: NotRequired["ConfirmationTokenCreateParamsShipping"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:40:    Shipping information for this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:44:class ConfirmationTokenCreateParamsPaymentMethodData(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:46:        "ConfirmationTokenCreateParamsPaymentMethodDataAcssDebit"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:51:    affirm: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataAffirm"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:56:        "ConfirmationTokenCreateParamsPaymentMethodDataAfterpayClearpay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:61:    alipay: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataAlipay"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:69:    alma: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataAlma"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:74:        "ConfirmationTokenCreateParamsPaymentMethodDataAmazonPay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:80:        "ConfirmationTokenCreateParamsPaymentMethodDataAuBecsDebit"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:86:        "ConfirmationTokenCreateParamsPaymentMethodDataBacsDebit"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:92:        "ConfirmationTokenCreateParamsPaymentMethodDataBancontact"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:97:    billie: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataBillie"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:102:        "ConfirmationTokenCreateParamsPaymentMethodDataBillingDetails"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:107:    blik: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataBlik"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:111:    boleto: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataBoleto"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:116:        "ConfirmationTokenCreateParamsPaymentMethodDataCashapp"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:121:    crypto: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataCrypto"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:126:        "ConfirmationTokenCreateParamsPaymentMethodDataCustomerBalance"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:131:    eps: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataEps"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:135:    fpx: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataFpx"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:140:        "ConfirmationTokenCreateParamsPaymentMethodDataGiropay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:146:        "ConfirmationTokenCreateParamsPaymentMethodDataGrabpay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:151:    ideal: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataIdeal"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:156:        "ConfirmationTokenCreateParamsPaymentMethodDataInteracPresent"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:162:        "ConfirmationTokenCreateParamsPaymentMethodDataKakaoPay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:167:    klarna: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataKlarna"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:172:        "ConfirmationTokenCreateParamsPaymentMethodDataKonbini"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:178:        "ConfirmationTokenCreateParamsPaymentMethodDataKrCard"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:183:    link: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataLink"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:187:    mb_way: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataMbWay"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:196:        "ConfirmationTokenCreateParamsPaymentMethodDataMobilepay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:202:        "ConfirmationTokenCreateParamsPaymentMethodDataMultibanco"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:208:        "ConfirmationTokenCreateParamsPaymentMethodDataNaverPay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:214:        "ConfirmationTokenCreateParamsPaymentMethodDataNzBankAccount"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:219:    oxxo: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataOxxo"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:223:    p24: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataP24"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:228:        "ConfirmationTokenCreateParamsPaymentMethodDataPayByBank"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:233:    payco: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPayco"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:237:    paynow: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPaynow"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:241:    paypal: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPaypal"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:245:    pix: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPix"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:250:        "ConfirmationTokenCreateParamsPaymentMethodDataPromptpay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:256:        "ConfirmationTokenCreateParamsPaymentMethodDataRadarOptions"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:262:        "ConfirmationTokenCreateParamsPaymentMethodDataRevolutPay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:268:        "ConfirmationTokenCreateParamsPaymentMethodDataSamsungPay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:274:        "ConfirmationTokenCreateParamsPaymentMethodDataSatispay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:280:        "ConfirmationTokenCreateParamsPaymentMethodDataSepaDebit"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:285:    sofort: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataSofort"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:289:    swish: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataSwish"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:293:    twint: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataTwint"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:351:        "ConfirmationTokenCreateParamsPaymentMethodDataUsBankAccount"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:357:        "ConfirmationTokenCreateParamsPaymentMethodDataWechatPay"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:362:    zip: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataZip"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:368:class ConfirmationTokenCreateParamsPaymentMethodDataAcssDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:383:class ConfirmationTokenCreateParamsPaymentMethodDataAffirm(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:387:class ConfirmationTokenCreateParamsPaymentMethodDataAfterpayClearpay(
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:393:class ConfirmationTokenCreateParamsPaymentMethodDataAlipay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:397:class ConfirmationTokenCreateParamsPaymentMethodDataAlma(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:401:class ConfirmationTokenCreateParamsPaymentMethodDataAmazonPay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:405:class ConfirmationTokenCreateParamsPaymentMethodDataAuBecsDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:416:class ConfirmationTokenCreateParamsPaymentMethodDataBacsDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:427:class ConfirmationTokenCreateParamsPaymentMethodDataBancontact(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:431:class ConfirmationTokenCreateParamsPaymentMethodDataBillie(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:435:class ConfirmationTokenCreateParamsPaymentMethodDataBillingDetails(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:437:        "Literal['']|ConfirmationTokenCreateParamsPaymentMethodDataBillingDetailsAddress"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:460:class ConfirmationTokenCreateParamsPaymentMethodDataBillingDetailsAddress(
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:489:class ConfirmationTokenCreateParamsPaymentMethodDataBlik(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:493:class ConfirmationTokenCreateParamsPaymentMethodDataBoleto(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:500:class ConfirmationTokenCreateParamsPaymentMethodDataCashapp(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:504:class ConfirmationTokenCreateParamsPaymentMethodDataCrypto(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:508:class ConfirmationTokenCreateParamsPaymentMethodDataCustomerBalance(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:512:class ConfirmationTokenCreateParamsPaymentMethodDataEps(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:550:class ConfirmationTokenCreateParamsPaymentMethodDataFpx(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:584:class ConfirmationTokenCreateParamsPaymentMethodDataGiropay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:588:class ConfirmationTokenCreateParamsPaymentMethodDataGrabpay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:592:class ConfirmationTokenCreateParamsPaymentMethodDataIdeal(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:619:class ConfirmationTokenCreateParamsPaymentMethodDataInteracPresent(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:623:class ConfirmationTokenCreateParamsPaymentMethodDataKakaoPay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:627:class ConfirmationTokenCreateParamsPaymentMethodDataKlarna(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:628:    dob: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataKlarnaDob"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:634:class ConfirmationTokenCreateParamsPaymentMethodDataKlarnaDob(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:649:class ConfirmationTokenCreateParamsPaymentMethodDataKonbini(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:653:class ConfirmationTokenCreateParamsPaymentMethodDataKrCard(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:657:class ConfirmationTokenCreateParamsPaymentMethodDataLink(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:661:class ConfirmationTokenCreateParamsPaymentMethodDataMbWay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:665:class ConfirmationTokenCreateParamsPaymentMethodDataMobilepay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:669:class ConfirmationTokenCreateParamsPaymentMethodDataMultibanco(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:673:class ConfirmationTokenCreateParamsPaymentMethodDataNaverPay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:680:class ConfirmationTokenCreateParamsPaymentMethodDataNzBankAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:704:class ConfirmationTokenCreateParamsPaymentMethodDataOxxo(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:708:class ConfirmationTokenCreateParamsPaymentMethodDataP24(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:744:class ConfirmationTokenCreateParamsPaymentMethodDataPayByBank(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:748:class ConfirmationTokenCreateParamsPaymentMethodDataPayco(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:752:class ConfirmationTokenCreateParamsPaymentMethodDataPaynow(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:756:class ConfirmationTokenCreateParamsPaymentMethodDataPaypal(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:760:class ConfirmationTokenCreateParamsPaymentMethodDataPix(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:764:class ConfirmationTokenCreateParamsPaymentMethodDataPromptpay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:768:class ConfirmationTokenCreateParamsPaymentMethodDataRadarOptions(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:775:class ConfirmationTokenCreateParamsPaymentMethodDataRevolutPay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:779:class ConfirmationTokenCreateParamsPaymentMethodDataSamsungPay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:783:class ConfirmationTokenCreateParamsPaymentMethodDataSatispay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:787:class ConfirmationTokenCreateParamsPaymentMethodDataSepaDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:794:class ConfirmationTokenCreateParamsPaymentMethodDataSofort(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:801:class ConfirmationTokenCreateParamsPaymentMethodDataSwish(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:805:class ConfirmationTokenCreateParamsPaymentMethodDataTwint(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:809:class ConfirmationTokenCreateParamsPaymentMethodDataUsBankAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:832:class ConfirmationTokenCreateParamsPaymentMethodDataWechatPay(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:836:class ConfirmationTokenCreateParamsPaymentMethodDataZip(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:840:class ConfirmationTokenCreateParamsPaymentMethodOptions(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:841:    card: NotRequired["ConfirmationTokenCreateParamsPaymentMethodOptionsCard"]
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:843:    Configuration for any card payments confirmed using this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:847:class ConfirmationTokenCreateParamsPaymentMethodOptionsCard(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:849:        "ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallments"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:852:    Installment configuration for payments confirmed using this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:856:class ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallments(
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:860:        "ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallmentsPlan"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:868:class ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallmentsPlan(
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:886:class ConfirmationTokenCreateParamsShipping(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:887:    address: "ConfirmationTokenCreateParamsShippingAddress"
.venv\Lib\site-packages\stripe\params\test_helpers\_confirmation_token_create_params.py:901:class ConfirmationTokenCreateParamsShippingAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\test_helpers\__init__.py:8:from stripe.params.test_helpers._confirmation_token_create_params import (
.venv\Lib\site-packages\stripe\params\test_helpers\__init__.py:9:    ConfirmationTokenCreateParams as ConfirmationTokenCreateParams,
.venv\Lib\site-packages\stripe\params\_account_create_external_account_params.py:21:        "AccountCreateExternalAccountParamsCardToken",
.venv\Lib\site-packages\stripe\params\_account_create_external_account_params.py:24:    A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js) or a dictionary containing a user's external account details (with the options shown below). Please refer to full [documentation](https://stripe.com/docs/api/external_accounts) instead.
.venv\Lib\site-packages\stripe\params\_account_create_external_account_params.py:80:class AccountCreateExternalAccountParamsCardToken(TypedDict):
.venv\Lib\site-packages\stripe\params\_account_create_external_account_params.py:83:    token: str
.venv\Lib\site-packages\stripe\params\_account_create_params.py:9:    account_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_account_create_params.py:11:    An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
.venv\Lib\site-packages\stripe\params\_account_create_params.py:63:        "str|AccountCreateParamsBankAccount|AccountCreateParamsCard|AccountCreateParamsCardToken"
.venv\Lib\site-packages\stripe\params\_account_create_params.py:66:    A card or bank account to attach to the account for receiving [payouts](https://docs.stripe.com/connect/bank-debit-card-payouts) (you won't be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://docs.stripe.com/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://docs.stripe.com/api#account_create_bank_account) creation.
.venv\Lib\site-packages\stripe\params\_account_create_params.py:72:    A hash of account group type to tokens. These are account groups this account should be added to.
.venv\Lib\site-packages\stripe\params\_account_create_params.py:1425:class AccountCreateParamsCardToken(TypedDict):
.venv\Lib\site-packages\stripe\params\_account_create_params.py:1428:    token: str
.venv\Lib\site-packages\stripe\params\_account_create_params.py:1481:    The government-issued ID number of the individual, as appropriate for the representative's country. (Examples are a Social Security Number in the U.S., or a Social Insurance Number in Canada). Instead of the number itself, you can also provide a [PII token created with Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_create_params.py:1485:    The government-issued secondary ID number of the individual, as appropriate for the representative's country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token created with Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_create_person_params.py:65:    The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_create_person_params.py:69:    The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_create_person_params.py:95:    person_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_account_create_person_params.py:97:    A [person token](https://docs.stripe.com/connect/account-tokens), used to securely provide details to the person.
.venv\Lib\site-packages\stripe\params\_account_external_account_create_params.py:20:        "AccountExternalAccountCreateParamsCardToken",
.venv\Lib\site-packages\stripe\params\_account_external_account_create_params.py:23:    A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js) or a dictionary containing a user's external account details (with the options shown below). Please refer to full [documentation](https://stripe.com/docs/api/external_accounts) instead.
.venv\Lib\site-packages\stripe\params\_account_external_account_create_params.py:79:class AccountExternalAccountCreateParamsCardToken(TypedDict):
.venv\Lib\site-packages\stripe\params\_account_external_account_create_params.py:82:    token: str
.venv\Lib\site-packages\stripe\params\_account_modify_person_params.py:65:    The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_modify_person_params.py:69:    The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_modify_person_params.py:95:    person_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_account_modify_person_params.py:97:    A [person token](https://docs.stripe.com/connect/account-tokens), used to securely provide details to the person.
.venv\Lib\site-packages\stripe\params\_account_person_create_params.py:64:    The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_person_create_params.py:68:    The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_person_create_params.py:94:    person_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_account_person_create_params.py:96:    A [person token](https://docs.stripe.com/connect/account-tokens), used to securely provide details to the person.
.venv\Lib\site-packages\stripe\params\_account_person_update_params.py:64:    The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_person_update_params.py:68:    The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_person_update_params.py:94:    person_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_account_person_update_params.py:96:    A [person token](https://docs.stripe.com/connect/account-tokens), used to securely provide details to the person.
.venv\Lib\site-packages\stripe\params\_account_update_params.py:8:    account_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_account_update_params.py:10:    An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
.venv\Lib\site-packages\stripe\params\_account_update_params.py:54:        "Literal['']|str|AccountUpdateParamsBankAccount|AccountUpdateParamsCard|AccountUpdateParamsCardToken"
.venv\Lib\site-packages\stripe\params\_account_update_params.py:57:    A card or bank account to attach to the account for receiving [payouts](https://docs.stripe.com/connect/bank-debit-card-payouts) (you won't be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://docs.stripe.com/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://docs.stripe.com/api#account_create_bank_account) creation.
.venv\Lib\site-packages\stripe\params\_account_update_params.py:63:    A hash of account group type to tokens. These are account groups this account should be added to.
.venv\Lib\site-packages\stripe\params\_account_update_params.py:1367:class AccountUpdateParamsCardToken(TypedDict):
.venv\Lib\site-packages\stripe\params\_account_update_params.py:1370:    token: str
.venv\Lib\site-packages\stripe\params\_account_update_params.py:1423:    The government-issued ID number of the individual, as appropriate for the representative's country. (Examples are a Social Security Number in the U.S., or a Social Insurance Number in Canada). Instead of the number itself, you can also provide a [PII token created with Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_account_update_params.py:1427:    The government-issued secondary ID number of the individual, as appropriate for the representative's country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token created with Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_charge_create_params.py:61:    A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:8:class ConfirmationTokenCreateParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:18:        "ConfirmationTokenCreateParamsPaymentMethodData"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:24:        "ConfirmationTokenCreateParamsPaymentMethodOptions"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:27:    Payment-method-specific configuration for this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:35:    Indicates that you intend to make future payments with this ConfirmationToken's payment method.
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:39:    shipping: NotRequired["ConfirmationTokenCreateParamsShipping"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:41:    Shipping information for this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:45:class ConfirmationTokenCreateParamsPaymentMethodData(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:47:        "ConfirmationTokenCreateParamsPaymentMethodDataAcssDebit"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:52:    affirm: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataAffirm"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:57:        "ConfirmationTokenCreateParamsPaymentMethodDataAfterpayClearpay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:62:    alipay: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataAlipay"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:70:    alma: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataAlma"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:75:        "ConfirmationTokenCreateParamsPaymentMethodDataAmazonPay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:81:        "ConfirmationTokenCreateParamsPaymentMethodDataAuBecsDebit"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:87:        "ConfirmationTokenCreateParamsPaymentMethodDataBacsDebit"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:93:        "ConfirmationTokenCreateParamsPaymentMethodDataBancontact"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:98:    billie: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataBillie"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:103:        "ConfirmationTokenCreateParamsPaymentMethodDataBillingDetails"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:108:    blik: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataBlik"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:112:    boleto: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataBoleto"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:117:        "ConfirmationTokenCreateParamsPaymentMethodDataCashapp"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:122:    crypto: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataCrypto"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:127:        "ConfirmationTokenCreateParamsPaymentMethodDataCustomerBalance"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:132:    eps: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataEps"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:136:    fpx: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataFpx"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:141:        "ConfirmationTokenCreateParamsPaymentMethodDataGiropay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:147:        "ConfirmationTokenCreateParamsPaymentMethodDataGrabpay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:152:    ideal: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataIdeal"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:157:        "ConfirmationTokenCreateParamsPaymentMethodDataInteracPresent"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:163:        "ConfirmationTokenCreateParamsPaymentMethodDataKakaoPay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:168:    klarna: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataKlarna"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:173:        "ConfirmationTokenCreateParamsPaymentMethodDataKonbini"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:179:        "ConfirmationTokenCreateParamsPaymentMethodDataKrCard"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:184:    link: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataLink"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:188:    mb_way: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataMbWay"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:197:        "ConfirmationTokenCreateParamsPaymentMethodDataMobilepay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:203:        "ConfirmationTokenCreateParamsPaymentMethodDataMultibanco"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:209:        "ConfirmationTokenCreateParamsPaymentMethodDataNaverPay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:215:        "ConfirmationTokenCreateParamsPaymentMethodDataNzBankAccount"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:220:    oxxo: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataOxxo"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:224:    p24: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataP24"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:229:        "ConfirmationTokenCreateParamsPaymentMethodDataPayByBank"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:234:    payco: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPayco"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:238:    paynow: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPaynow"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:242:    paypal: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPaypal"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:246:    pix: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataPix"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:251:        "ConfirmationTokenCreateParamsPaymentMethodDataPromptpay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:257:        "ConfirmationTokenCreateParamsPaymentMethodDataRadarOptions"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:263:        "ConfirmationTokenCreateParamsPaymentMethodDataRevolutPay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:269:        "ConfirmationTokenCreateParamsPaymentMethodDataSamsungPay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:275:        "ConfirmationTokenCreateParamsPaymentMethodDataSatispay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:281:        "ConfirmationTokenCreateParamsPaymentMethodDataSepaDebit"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:286:    sofort: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataSofort"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:290:    swish: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataSwish"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:294:    twint: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataTwint"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:352:        "ConfirmationTokenCreateParamsPaymentMethodDataUsBankAccount"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:358:        "ConfirmationTokenCreateParamsPaymentMethodDataWechatPay"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:363:    zip: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataZip"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:369:class ConfirmationTokenCreateParamsPaymentMethodDataAcssDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:384:class ConfirmationTokenCreateParamsPaymentMethodDataAffirm(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:388:class ConfirmationTokenCreateParamsPaymentMethodDataAfterpayClearpay(
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:394:class ConfirmationTokenCreateParamsPaymentMethodDataAlipay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:398:class ConfirmationTokenCreateParamsPaymentMethodDataAlma(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:402:class ConfirmationTokenCreateParamsPaymentMethodDataAmazonPay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:406:class ConfirmationTokenCreateParamsPaymentMethodDataAuBecsDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:417:class ConfirmationTokenCreateParamsPaymentMethodDataBacsDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:428:class ConfirmationTokenCreateParamsPaymentMethodDataBancontact(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:432:class ConfirmationTokenCreateParamsPaymentMethodDataBillie(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:436:class ConfirmationTokenCreateParamsPaymentMethodDataBillingDetails(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:438:        "Literal['']|ConfirmationTokenCreateParamsPaymentMethodDataBillingDetailsAddress"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:461:class ConfirmationTokenCreateParamsPaymentMethodDataBillingDetailsAddress(
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:490:class ConfirmationTokenCreateParamsPaymentMethodDataBlik(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:494:class ConfirmationTokenCreateParamsPaymentMethodDataBoleto(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:501:class ConfirmationTokenCreateParamsPaymentMethodDataCashapp(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:505:class ConfirmationTokenCreateParamsPaymentMethodDataCrypto(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:509:class ConfirmationTokenCreateParamsPaymentMethodDataCustomerBalance(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:513:class ConfirmationTokenCreateParamsPaymentMethodDataEps(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:551:class ConfirmationTokenCreateParamsPaymentMethodDataFpx(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:585:class ConfirmationTokenCreateParamsPaymentMethodDataGiropay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:589:class ConfirmationTokenCreateParamsPaymentMethodDataGrabpay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:593:class ConfirmationTokenCreateParamsPaymentMethodDataIdeal(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:620:class ConfirmationTokenCreateParamsPaymentMethodDataInteracPresent(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:624:class ConfirmationTokenCreateParamsPaymentMethodDataKakaoPay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:628:class ConfirmationTokenCreateParamsPaymentMethodDataKlarna(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:629:    dob: NotRequired["ConfirmationTokenCreateParamsPaymentMethodDataKlarnaDob"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:635:class ConfirmationTokenCreateParamsPaymentMethodDataKlarnaDob(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:650:class ConfirmationTokenCreateParamsPaymentMethodDataKonbini(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:654:class ConfirmationTokenCreateParamsPaymentMethodDataKrCard(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:658:class ConfirmationTokenCreateParamsPaymentMethodDataLink(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:662:class ConfirmationTokenCreateParamsPaymentMethodDataMbWay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:666:class ConfirmationTokenCreateParamsPaymentMethodDataMobilepay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:670:class ConfirmationTokenCreateParamsPaymentMethodDataMultibanco(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:674:class ConfirmationTokenCreateParamsPaymentMethodDataNaverPay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:681:class ConfirmationTokenCreateParamsPaymentMethodDataNzBankAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:705:class ConfirmationTokenCreateParamsPaymentMethodDataOxxo(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:709:class ConfirmationTokenCreateParamsPaymentMethodDataP24(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:745:class ConfirmationTokenCreateParamsPaymentMethodDataPayByBank(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:749:class ConfirmationTokenCreateParamsPaymentMethodDataPayco(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:753:class ConfirmationTokenCreateParamsPaymentMethodDataPaynow(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:757:class ConfirmationTokenCreateParamsPaymentMethodDataPaypal(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:761:class ConfirmationTokenCreateParamsPaymentMethodDataPix(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:765:class ConfirmationTokenCreateParamsPaymentMethodDataPromptpay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:769:class ConfirmationTokenCreateParamsPaymentMethodDataRadarOptions(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:776:class ConfirmationTokenCreateParamsPaymentMethodDataRevolutPay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:780:class ConfirmationTokenCreateParamsPaymentMethodDataSamsungPay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:784:class ConfirmationTokenCreateParamsPaymentMethodDataSatispay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:788:class ConfirmationTokenCreateParamsPaymentMethodDataSepaDebit(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:795:class ConfirmationTokenCreateParamsPaymentMethodDataSofort(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:802:class ConfirmationTokenCreateParamsPaymentMethodDataSwish(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:806:class ConfirmationTokenCreateParamsPaymentMethodDataTwint(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:810:class ConfirmationTokenCreateParamsPaymentMethodDataUsBankAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:833:class ConfirmationTokenCreateParamsPaymentMethodDataWechatPay(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:837:class ConfirmationTokenCreateParamsPaymentMethodDataZip(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:841:class ConfirmationTokenCreateParamsPaymentMethodOptions(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:842:    card: NotRequired["ConfirmationTokenCreateParamsPaymentMethodOptionsCard"]
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:844:    Configuration for any card payments confirmed using this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:848:class ConfirmationTokenCreateParamsPaymentMethodOptionsCard(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:850:        "ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallments"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:853:    Installment configuration for payments confirmed using this ConfirmationToken.
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:857:class ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallments(
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:861:        "ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallmentsPlan"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:869:class ConfirmationTokenCreateParamsPaymentMethodOptionsCardInstallmentsPlan(
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:887:class ConfirmationTokenCreateParamsShipping(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:888:    address: "ConfirmationTokenCreateParamsShippingAddress"
.venv\Lib\site-packages\stripe\params\_confirmation_token_create_params.py:902:class ConfirmationTokenCreateParamsShippingAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\_confirmation_token_retrieve_params.py:8:class ConfirmationTokenRetrieveParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\_ephemeral_key_create_params.py:22:    A single-use token, created by Stripe.js, used for creating ephemeral keys for Issuing Cards without exchanging sensitive information.
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:15:    confirmation_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:17:    ID of the ConfirmationToken used to confirm this PaymentIntent.
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:19:    If the provided ConfirmationToken contains properties that are also being provided in this request, such as `payment_method`, then the values in this request will take precedence.
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:1551:    cvc_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:1553:    A single-use `cvc_update` Token that represents a card CVC value. When provided, the CVC value will be verified during the card payment attempt. This parameter can only be provided during confirmation.
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:1623:    When enabled, using a card that is attached to a customer will require the CVC to be provided again (i.e. using the cvc_token parameter).
.venv\Lib\site-packages\stripe\params\_payment_intent_confirm_params.py:2269:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:37:    confirmation_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:39:    ID of the ConfirmationToken used to confirm this PaymentIntent.
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:41:    If the provided ConfirmationToken contains properties that are also being provided in this request, such as `payment_method`, then the values in this request will take precedence.
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:1678:    cvc_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:1680:    A single-use `cvc_update` Token that represents a card CVC value. When provided, the CVC value will be verified during the card payment attempt. This parameter can only be provided during confirmation.
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:1750:    When enabled, using a card that is attached to a customer will require the CVC to be provided again (i.e. using the cvc_token parameter).
.venv\Lib\site-packages\stripe\params\_payment_intent_create_params.py:2392:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_modify_params.py:1512:    cvc_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_modify_params.py:1514:    A single-use `cvc_update` Token that represents a card CVC value. When provided, the CVC value will be verified during the card payment attempt. This parameter can only be provided during confirmation.
.venv\Lib\site-packages\stripe\params\_payment_intent_modify_params.py:1584:    When enabled, using a card that is attached to a customer will require the CVC to be provided again (i.e. using the cvc_token parameter).
.venv\Lib\site-packages\stripe\params\_payment_intent_modify_params.py:2226:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_update_params.py:1511:    cvc_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_intent_update_params.py:1513:    A single-use `cvc_update` Token that represents a card CVC value. When provided, the CVC value will be verified during the card payment attempt. This parameter can only be provided during confirmation.
.venv\Lib\site-packages\stripe\params\_payment_intent_update_params.py:1583:    When enabled, using a card that is attached to a customer will require the CVC to be provided again (i.e. using the cvc_token parameter).
.venv\Lib\site-packages\stripe\params\_payment_intent_update_params.py:2225:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_link_create_params.py:143:    phone_number_collection: NotRequired[
.venv\Lib\site-packages\stripe\params\_payment_link_modify_params.py:83:    phone_number_collection: NotRequired[
.venv\Lib\site-packages\stripe\params\_payment_link_update_params.py:82:    phone_number_collection: NotRequired[
.venv\Lib\site-packages\stripe\params\_payment_method_create_params.py:67:    If this is a `card` PaymentMethod, this hash contains the user's card details. For backwards compatibility, you can alternatively provide a Stripe token (e.g., for Apple Pay, Amex Express Checkout, or legacy Checkout) into the card hash with format `card: {token: "tok_visa"}`. When providing a card number, you must meet the requirements for [PCI compliance](https://stripe.com/docs/security#validating-pci-compliance). We strongly recommend using Stripe.js instead of interacting with this API directly.
.venv\Lib\site-packages\stripe\params\_payment_method_create_params.py:444:    token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_payment_method_create_params.py:446:    For backwards compatibility, you can alternatively provide a Stripe token (e.g., for Apple Pay, Amex Express Checkout, or legacy Checkout) into the card hash with format card: {token: "tok_visa"}.
.venv\Lib\site-packages\stripe\params\_setup_intent_confirm_params.py:9:    confirmation_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_setup_intent_confirm_params.py:11:    ID of the ConfirmationToken used to confirm this SetupIntent.
.venv\Lib\site-packages\stripe\params\_setup_intent_confirm_params.py:13:    If the provided ConfirmationToken contains properties that are also being provided in this request, such as `payment_method`, then the values in this request will take precedence.
.venv\Lib\site-packages\stripe\params\_setup_intent_confirm_params.py:1307:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_setup_intent_create_params.py:25:    confirmation_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_setup_intent_create_params.py:27:    ID of the ConfirmationToken used to confirm this SetupIntent.
.venv\Lib\site-packages\stripe\params\_setup_intent_create_params.py:29:    If the provided ConfirmationToken contains properties that are also being provided in this request, such as `payment_method`, then the values in this request will take precedence.
.venv\Lib\site-packages\stripe\params\_setup_intent_create_params.py:1365:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_setup_intent_modify_params.py:1265:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_setup_intent_update_params.py:1264:    persistent_token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_source_create_params.py:60:    token: NotRequired[str]
.venv\Lib\site-packages\stripe\params\_source_create_params.py:62:    An optional token used to create the source. When passed, token properties will override source parameters.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:8:class TokenCreateParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:9:    account: NotRequired["TokenCreateParamsAccount"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:11:    Information for the account this token represents.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:13:    bank_account: NotRequired["TokenCreateParamsBankAccount"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:15:    The bank account this token will represent.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:17:    card: NotRequired["TokenCreateParamsCard|str"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:19:    The card this token will represent. If you also pass in a customer, the card must be the ID of a card belonging to the customer. Otherwise, if you do not pass in a customer, this is a dictionary containing a user's credit card details, with the options described below.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:23:    Create a token for the customer, which is owned by the application's account. You can only use this with an [OAuth access token](https://stripe.com/docs/connect/standard-accounts) or [Stripe-Account header](https://stripe.com/docs/connect/authentication). Learn more about [cloning saved payment methods](https://stripe.com/docs/connect/cloning-saved-payment-methods).
.venv\Lib\site-packages\stripe\params\_token_create_params.py:25:    cvc_update: NotRequired["TokenCreateParamsCvcUpdate"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:27:    The updated CVC value this token represents.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:33:    person: NotRequired["TokenCreateParamsPerson"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:35:    Information for the person this token represents.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:37:    pii: NotRequired["TokenCreateParamsPii"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:39:    The PII this token represents.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:43:class TokenCreateParamsAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:50:    company: NotRequired["TokenCreateParamsAccountCompany"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:54:    individual: NotRequired["TokenCreateParamsAccountIndividual"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:60:    Whether the user described by the data in the token has been shown [the Stripe Connected Account Agreement](https://docs.stripe.com/connect/account-tokens#stripe-connected-account-agreement). When creating an account token to create a new Connect account, this value must be `true`.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:64:class TokenCreateParamsAccountCompany(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:65:    address: NotRequired["TokenCreateParamsAccountCompanyAddress"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:69:    address_kana: NotRequired["TokenCreateParamsAccountCompanyAddressKana"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:73:    address_kanji: NotRequired["TokenCreateParamsAccountCompanyAddressKanji"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:82:        "TokenCreateParamsAccountCompanyDirectorshipDeclaration"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:116:        "TokenCreateParamsAccountCompanyOwnershipDeclaration"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:123:    Whether the user described by the data in the token has been shown the Ownership Declaration and indicated that it is correct.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:136:        "Literal['']|TokenCreateParamsAccountCompanyRegistrationDate"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:163:    verification: NotRequired["TokenCreateParamsAccountCompanyVerification"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:169:class TokenCreateParamsAccountCompanyAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:196:class TokenCreateParamsAccountCompanyAddressKana(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:227:class TokenCreateParamsAccountCompanyAddressKanji(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:258:class TokenCreateParamsAccountCompanyDirectorshipDeclaration(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:273:class TokenCreateParamsAccountCompanyOwnershipDeclaration(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:288:class TokenCreateParamsAccountCompanyRegistrationDate(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:303:class TokenCreateParamsAccountCompanyVerification(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:305:        "TokenCreateParamsAccountCompanyVerificationDocument"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:312:class TokenCreateParamsAccountCompanyVerificationDocument(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:323:class TokenCreateParamsAccountIndividual(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:324:    address: NotRequired["TokenCreateParamsAccountIndividualAddress"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:328:    address_kana: NotRequired["TokenCreateParamsAccountIndividualAddressKana"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:333:        "TokenCreateParamsAccountIndividualAddressKanji"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:338:    dob: NotRequired["Literal['']|TokenCreateParamsAccountIndividualDob"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:368:    The government-issued ID number of the individual, as appropriate for the representative's country. (Examples are a Social Security Number in the U.S., or a Social Insurance Number in Canada). Instead of the number itself, you can also provide a [PII token created with Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_token_create_params.py:372:    The government-issued secondary ID number of the individual, as appropriate for the representative's country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token created with Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_token_create_params.py:403:        "TokenCreateParamsAccountIndividualRegisteredAddress"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:408:    relationship: NotRequired["TokenCreateParamsAccountIndividualRelationship"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:416:    verification: NotRequired["TokenCreateParamsAccountIndividualVerification"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:422:class TokenCreateParamsAccountIndividualAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:449:class TokenCreateParamsAccountIndividualAddressKana(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:480:class TokenCreateParamsAccountIndividualAddressKanji(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:511:class TokenCreateParamsAccountIndividualDob(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:526:class TokenCreateParamsAccountIndividualRegisteredAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:553:class TokenCreateParamsAccountIndividualRelationship(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:576:class TokenCreateParamsAccountIndividualVerification(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:578:        "TokenCreateParamsAccountIndividualVerificationAdditionalDocument"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:584:        "TokenCreateParamsAccountIndividualVerificationDocument"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:591:class TokenCreateParamsAccountIndividualVerificationAdditionalDocument(
.venv\Lib\site-packages\stripe\params\_token_create_params.py:604:class TokenCreateParamsAccountIndividualVerificationDocument(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:615:class TokenCreateParamsBankAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:642:    The ID of a Payment Method with a `type` of `us_bank_account`. The Payment Method's bank account information will be copied and returned as a Bank Account Token. This parameter is exclusive with respect to all other parameters in the `bank_account` hash. You must include the top-level `customer` parameter if the Payment Method is attached to a `Customer` object. If the Payment Method is not attached to a `Customer` object, it will be consumed and cannot be used again. You may not use Payment Methods which were created by a Setup Intent with `attach_to_self=true`.
.venv\Lib\site-packages\stripe\params\_token_create_params.py:650:class TokenCreateParamsCard(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:695:    networks: NotRequired["TokenCreateParamsCardNetworks"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:705:class TokenCreateParamsCardNetworks(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:712:class TokenCreateParamsCvcUpdate(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:719:class TokenCreateParamsPerson(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:721:        "TokenCreateParamsPersonAdditionalTosAcceptances"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:726:    address: NotRequired["TokenCreateParamsPersonAddress"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:730:    address_kana: NotRequired["TokenCreateParamsPersonAddressKana"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:734:    address_kanji: NotRequired["TokenCreateParamsPersonAddressKanji"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:738:    dob: NotRequired["Literal['']|TokenCreateParamsPersonDob"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:742:    documents: NotRequired["TokenCreateParamsPersonDocuments"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:772:    The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_token_create_params.py:776:    The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://docs.stripe.com/js/tokens/create_token?type=pii).
.venv\Lib\site-packages\stripe\params\_token_create_params.py:810:    registered_address: NotRequired["TokenCreateParamsPersonRegisteredAddress"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:814:    relationship: NotRequired["TokenCreateParamsPersonRelationship"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:822:    us_cfpb_data: NotRequired["TokenCreateParamsPersonUsCfpbData"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:826:    verification: NotRequired["TokenCreateParamsPersonVerification"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:832:class TokenCreateParamsPersonAdditionalTosAcceptances(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:834:        "TokenCreateParamsPersonAdditionalTosAcceptancesAccount"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:841:class TokenCreateParamsPersonAdditionalTosAcceptancesAccount(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:856:class TokenCreateParamsPersonAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:883:class TokenCreateParamsPersonAddressKana(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:914:class TokenCreateParamsPersonAddressKanji(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:945:class TokenCreateParamsPersonDob(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:960:class TokenCreateParamsPersonDocuments(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:962:        "TokenCreateParamsPersonDocumentsCompanyAuthorization"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:967:    passport: NotRequired["TokenCreateParamsPersonDocumentsPassport"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:971:    visa: NotRequired["TokenCreateParamsPersonDocumentsVisa"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:977:class TokenCreateParamsPersonDocumentsCompanyAuthorization(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:984:class TokenCreateParamsPersonDocumentsPassport(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:991:class TokenCreateParamsPersonDocumentsVisa(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:998:class TokenCreateParamsPersonRegisteredAddress(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1025:class TokenCreateParamsPersonRelationship(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1060:class TokenCreateParamsPersonUsCfpbData(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1062:        "TokenCreateParamsPersonUsCfpbDataEthnicityDetails"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1067:    race_details: NotRequired["TokenCreateParamsPersonUsCfpbDataRaceDetails"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1077:class TokenCreateParamsPersonUsCfpbDataEthnicityDetails(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1100:class TokenCreateParamsPersonUsCfpbDataRaceDetails(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1140:class TokenCreateParamsPersonVerification(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1142:        "TokenCreateParamsPersonVerificationAdditionalDocument"
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1147:    document: NotRequired["TokenCreateParamsPersonVerificationDocument"]
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1153:class TokenCreateParamsPersonVerificationAdditionalDocument(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1164:class TokenCreateParamsPersonVerificationDocument(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_create_params.py:1175:class TokenCreateParamsPii(TypedDict):
.venv\Lib\site-packages\stripe\params\_token_retrieve_params.py:8:class TokenRetrieveParams(RequestOptions):
.venv\Lib\site-packages\stripe\params\_topup_create_params.py:31:    The ID of a source to transfer funds from. For most users, this should be left unspecified which will use the bank account that was set up in the dashboard for the specified currency. In test mode, this can be a test bank token (see [Testing Top-ups](https://stripe.com/docs/connect/testing#testing-top-ups)).
.venv\Lib\site-packages\stripe\params\_webhook_endpoint_create_params.py:262:            "issuing_token.created",
.venv\Lib\site-packages\stripe\params\_webhook_endpoint_create_params.py:263:            "issuing_token.updated",
.venv\Lib\site-packages\stripe\params\_webhook_endpoint_modify_params.py:140:                "issuing_token.created",
.venv\Lib\site-packages\stripe\params\_webhook_endpoint_modify_params.py:141:                "issuing_token.updated",
.venv\Lib\site-packages\stripe\params\_webhook_endpoint_update_params.py:139:                "issuing_token.created",
.venv\Lib\site-packages\stripe\params\_webhook_endpoint_update_params.py:140:                "issuing_token.updated",
.venv\Lib\site-packages\stripe\params\__init__.py:232:from stripe.params._confirmation_token_create_params import (
.venv\Lib\site-packages\stripe\params\__init__.py:233:    ConfirmationTokenCreateParams as ConfirmationTokenCreateParams,
.venv\Lib\site-packages\stripe\params\__init__.py:235:from stripe.params._confirmation_token_retrieve_params import (
.venv\Lib\site-packages\stripe\params\__init__.py:236:    ConfirmationTokenRetrieveParams as ConfirmationTokenRetrieveParams,
.venv\Lib\site-packages\stripe\params\__init__.py:1057:from stripe.params._token_create_params import (
.venv\Lib\site-packages\stripe\params\__init__.py:1058:    TokenCreateParams as TokenCreateParams,
.venv\Lib\site-packages\stripe\params\__init__.py:1060:from stripe.params._token_retrieve_params import (
.venv\Lib\site-packages\stripe\params\__init__.py:1061:    TokenRetrieveParams as TokenRetrieveParams,
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:8:    from stripe.params.terminal._connection_token_create_params import (
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:9:        ConnectionTokenCreateParams,
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:13:class ConnectionToken(CreateableAPIResource["ConnectionToken"]):
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:15:    A Connection Token is used by the Stripe Terminal SDK to connect to a reader.
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:20:    OBJECT_NAME: ClassVar[Literal["terminal.connection_token"]] = (
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:21:        "terminal.connection_token"
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:25:    The id of the location that this connection token is scoped to. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://docs.stripe.com/terminal/fleet/locations-and-zones?dashboard-or-api=api#connection-tokens).
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:27:    object: Literal["terminal.connection_token"]
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:33:    Your application should pass this token to the Stripe Terminal SDK.
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:38:        cls, **params: Unpack["ConnectionTokenCreateParams"]
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:39:    ) -> "ConnectionToken":
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:41:        To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:44:            "ConnectionToken",
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:54:        cls, **params: Unpack["ConnectionTokenCreateParams"]
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:55:    ) -> "ConnectionToken":
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:57:        To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.
.venv\Lib\site-packages\stripe\terminal\_connection_token.py:60:            "ConnectionToken",
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:5:from stripe.terminal._connection_token import ConnectionToken
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:10:    from stripe.params.terminal._connection_token_create_params import (
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:11:        ConnectionTokenCreateParams,
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:15:class ConnectionTokenService(StripeService):
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:18:        params: Optional["ConnectionTokenCreateParams"] = None,
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:20:    ) -> ConnectionToken:
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:22:        To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:25:            ConnectionToken,
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:28:                "/v1/terminal/connection_tokens",
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:37:        params: Optional["ConnectionTokenCreateParams"] = None,
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:39:    ) -> ConnectionToken:
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:41:        To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:44:            ConnectionToken,
.venv\Lib\site-packages\stripe\terminal\_connection_token_service.py:47:                "/v1/terminal/connection_tokens",
.venv\Lib\site-packages\stripe\terminal\__init__.py:7:from stripe.terminal._connection_token import (
.venv\Lib\site-packages\stripe\terminal\__init__.py:8:    ConnectionToken as ConnectionToken,
.venv\Lib\site-packages\stripe\terminal\__init__.py:10:from stripe.terminal._connection_token_service import (
.venv\Lib\site-packages\stripe\terminal\__init__.py:11:    ConnectionTokenService as ConnectionTokenService,
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:3:from stripe._confirmation_token import ConfirmationToken
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:10:    from stripe.params.test_helpers._confirmation_token_create_params import (
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:11:        ConfirmationTokenCreateParams,
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:15:class ConfirmationTokenService(StripeService):
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:18:        params: Optional["ConfirmationTokenCreateParams"] = None,
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:20:    ) -> ConfirmationToken:
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:22:        Creates a test mode Confirmation Token server side for your integration tests.
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:25:            ConfirmationToken,
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:28:                "/v1/test_helpers/confirmation_tokens",
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:37:        params: Optional["ConfirmationTokenCreateParams"] = None,
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:39:    ) -> ConfirmationToken:
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:41:        Creates a test mode Confirmation Token server side for your integration tests.
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:44:            ConfirmationToken,
.venv\Lib\site-packages\stripe\test_helpers\_confirmation_token_service.py:47:                "/v1/test_helpers/confirmation_tokens",
.venv\Lib\site-packages\stripe\test_helpers\__init__.py:8:from stripe.test_helpers._confirmation_token_service import (
.venv\Lib\site-packages\stripe\test_helpers\__init__.py:9:    ConfirmationTokenService as ConfirmationTokenService,
.venv\Lib\site-packages\stripe\treasury\_outbound_payment.py:100:            Token of the FinancialAccount.
.venv\Lib\site-packages\stripe\treasury\_outbound_transfer.py:100:            Token of the FinancialAccount.
.venv\Lib\site-packages\stripe\treasury\_transaction_entry.py:135:    Token of the flow associated with the TransactionEntry.
.venv\Lib\site-packages\stripe\v2\billing\_meter_event_session.py:12:    authentication_token: str
.venv\Lib\site-packages\stripe\v2\billing\_meter_event_session.py:14:    The authentication token for this session.  Use this token when calling the
.venv\Lib\site-packages\stripe\v2\billing\_meter_event_session_service.py:22:        Creates a meter event session to send usage on the high-throughput meter event stream. Authentication tokens are only valid for 15 minutes, so you will need to create a new meter event session when your token expires.
.venv\Lib\site-packages\stripe\v2\billing\_meter_event_session_service.py:41:        Creates a meter event session to send usage on the high-throughput meter event stream. Authentication tokens are only valid for 15 minutes, so you will need to create a new meter event session when your token expires.
.venv\Lib\site-packages\stripe\_account_session.py:487:        Creates a AccountSession object that includes a single-use token that the platform can use on their front-end to grant client-side API access.
.venv\Lib\site-packages\stripe\_account_session.py:503:        Creates a AccountSession object that includes a single-use token that the platform can use on their front-end to grant client-side API access.
.venv\Lib\site-packages\stripe\_account_session_service.py:22:        Creates a AccountSession object that includes a single-use token that the platform can use on their front-end to grant client-side API access.
.venv\Lib\site-packages\stripe\_account_session_service.py:41:        Creates a AccountSession object that includes a single-use token that the platform can use on their front-end to grant client-side API access.
.venv\Lib\site-packages\stripe\_bank_account.py:483:        token = self.id
.venv\Lib\site-packages\stripe\_bank_account.py:484:        extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_bank_account.py:508:                "attached to a customer or an account." % token,
.venv\Lib\site-packages\stripe\_capability.py:389:        token = self.id
.venv\Lib\site-packages\stripe\_capability.py:395:        extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_card.py:111:    (For tokenized numbers only.) The last four digits of the device account number.
.venv\Lib\site-packages\stripe\_card.py:123:    Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_card.py:168:    tokenization_method: Optional[str]
.venv\Lib\site-packages\stripe\_card.py:170:    If the card number is tokenized, this is the method that was used. Can be `android_pay` (includes Google Pay), `apple_pay`, `masterpass`, `visa_checkout`, or null.
.venv\Lib\site-packages\stripe\_card.py:272:        token = self.id
.venv\Lib\site-packages\stripe\_card.py:273:        extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_card.py:298:                "account." % token,
.venv\Lib\site-packages\stripe\_charge.py:515:            class NetworkToken(StripeObject):
.venv\Lib\site-packages\stripe\_charge.py:518:                Indicates if Stripe used a network token, either user provided or Stripe managed when processing the transaction.
.venv\Lib\site-packages\stripe\_charge.py:761:                (For tokenized numbers only.) The last four digits of the device account number.
.venv\Lib\site-packages\stripe\_charge.py:829:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_charge.py:869:            network_token: Optional[NetworkToken]
.venv\Lib\site-packages\stripe\_charge.py:871:            If this card has network token credentials, this contains the details of the network token credentials.
.venv\Lib\site-packages\stripe\_charge.py:896:                "network_token": NetworkToken,
.venv\Lib\site-packages\stripe\_charge.py:1003:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_charge.py:1097:            token_currency: Optional[Literal["usdc", "usdg", "usdp"]]
.venv\Lib\site-packages\stripe\_charge.py:1099:            The token currency that the transaction was sent with.
.venv\Lib\site-packages\stripe\_charge.py:1354:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_confirmation_token.py:14:    from stripe.params._confirmation_token_create_params import (
.venv\Lib\site-packages\stripe\_confirmation_token.py:15:        ConfirmationTokenCreateParams,
.venv\Lib\site-packages\stripe\_confirmation_token.py:17:    from stripe.params._confirmation_token_retrieve_params import (
.venv\Lib\site-packages\stripe\_confirmation_token.py:18:        ConfirmationTokenRetrieveParams,
.venv\Lib\site-packages\stripe\_confirmation_token.py:22:class ConfirmationToken(APIResource["ConfirmationToken"]):
.venv\Lib\site-packages\stripe\_confirmation_token.py:24:    ConfirmationTokens help transport client side data collected by Stripe JS over
.venv\Lib\site-packages\stripe\_confirmation_token.py:26:    is successful, values present on the ConfirmationToken are written onto the Intent.
.venv\Lib\site-packages\stripe\_confirmation_token.py:28:    To learn more about how to use ConfirmationToken, visit the related guides:
.venv\Lib\site-packages\stripe\_confirmation_token.py:33:    OBJECT_NAME: ClassVar[Literal["confirmation_token"]] = "confirmation_token"
.venv\Lib\site-packages\stripe\_confirmation_token.py:84:            cvc_token: Optional[str]
.venv\Lib\site-packages\stripe\_confirmation_token.py:86:            The `cvc_update` Token collected from the Payment Element.
.venv\Lib\site-packages\stripe\_confirmation_token.py:353:                        Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_confirmation_token.py:631:                (For tokenized numbers only.) The last four digits of the device account number.
.venv\Lib\site-packages\stripe\_confirmation_token.py:690:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_confirmation_token.py:797:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1028:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1137:            persistent_token: Optional[str]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1624:    Time at which this ConfirmationToken expires and can no longer be used to confirm a PaymentIntent or SetupIntent.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1638:    object: Literal["confirmation_token"]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1644:    ID of the PaymentIntent that this ConfirmationToken was used to confirm, or null if this ConfirmationToken has not yet been used.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1648:    Payment-method-specific configuration for this ConfirmationToken.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1652:    Payment details collected by the Payment Element, used to create a PaymentMethod when a PaymentIntent or SetupIntent is confirmed with this ConfirmationToken.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1660:    Indicates that you intend to make future payments with this ConfirmationToken's payment method.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1666:    ID of the SetupIntent that this ConfirmationToken was used to confirm, or null if this ConfirmationToken has not yet been used.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1670:    Shipping information collected on this ConfirmationToken.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1674:    Indicates whether the Stripe SDK is used to handle confirmation flow. Defaults to `true` on ConfirmationToken.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1679:        cls, id: str, **params: Unpack["ConfirmationTokenRetrieveParams"]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1680:    ) -> "ConfirmationToken":
.venv\Lib\site-packages\stripe\_confirmation_token.py:1682:        Retrieves an existing ConfirmationToken object
.venv\Lib\site-packages\stripe\_confirmation_token.py:1690:        cls, id: str, **params: Unpack["ConfirmationTokenRetrieveParams"]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1691:    ) -> "ConfirmationToken":
.venv\Lib\site-packages\stripe\_confirmation_token.py:1693:        Retrieves an existing ConfirmationToken object
.venv\Lib\site-packages\stripe\_confirmation_token.py:1699:    class TestHelpers(APIResourceTestHelpers["ConfirmationToken"]):
.venv\Lib\site-packages\stripe\_confirmation_token.py:1700:        _resource_cls: Type["ConfirmationToken"]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1704:            cls, **params: Unpack["ConfirmationTokenCreateParams"]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1705:        ) -> "ConfirmationToken":
.venv\Lib\site-packages\stripe\_confirmation_token.py:1707:            Creates a test mode Confirmation Token server side for your integration tests.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1710:                "ConfirmationToken",
.venv\Lib\site-packages\stripe\_confirmation_token.py:1713:                    "/v1/test_helpers/confirmation_tokens",
.venv\Lib\site-packages\stripe\_confirmation_token.py:1720:            cls, **params: Unpack["ConfirmationTokenCreateParams"]
.venv\Lib\site-packages\stripe\_confirmation_token.py:1721:        ) -> "ConfirmationToken":
.venv\Lib\site-packages\stripe\_confirmation_token.py:1723:            Creates a test mode Confirmation Token server side for your integration tests.
.venv\Lib\site-packages\stripe\_confirmation_token.py:1726:                "ConfirmationToken",
.venv\Lib\site-packages\stripe\_confirmation_token.py:1729:                    "/v1/test_helpers/confirmation_tokens",
.venv\Lib\site-packages\stripe\_confirmation_token.py:1746:ConfirmationToken.TestHelpers._resource_cls = ConfirmationToken
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:3:from stripe._confirmation_token import ConfirmationToken
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:11:    from stripe.params._confirmation_token_retrieve_params import (
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:12:        ConfirmationTokenRetrieveParams,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:16:class ConfirmationTokenService(StripeService):
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:19:        confirmation_token: str,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:20:        params: Optional["ConfirmationTokenRetrieveParams"] = None,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:22:    ) -> ConfirmationToken:
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:24:        Retrieves an existing ConfirmationToken object
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:27:            ConfirmationToken,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:30:                "/v1/confirmation_tokens/{confirmation_token}".format(
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:31:                    confirmation_token=sanitize_id(confirmation_token),
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:41:        confirmation_token: str,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:42:        params: Optional["ConfirmationTokenRetrieveParams"] = None,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:44:    ) -> ConfirmationToken:
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:46:        Retrieves an existing ConfirmationToken object
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:49:            ConfirmationToken,
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:52:                "/v1/confirmation_tokens/{confirmation_token}".format(
.venv\Lib\site-packages\stripe\_confirmation_token_service.py:53:                    confirmation_token=sanitize_id(confirmation_token),
.venv\Lib\site-packages\stripe\_customer_balance_transaction.py:100:        token = self.id
.venv\Lib\site-packages\stripe\_customer_balance_transaction.py:106:        extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_event.py:215:        "issuing_token.created",
.venv\Lib\site-packages\stripe\_event.py:216:        "issuing_token.updated",
.venv\Lib\site-packages\stripe\_invoice.py:441:                "cardholder_phone_number_required",
.venv\Lib\site-packages\stripe\_invoice.py:587:                "token_already_used",
.venv\Lib\site-packages\stripe\_invoice.py:588:                "token_card_network_invalid",
.venv\Lib\site-packages\stripe\_invoice.py:589:                "token_in_use",
.venv\Lib\site-packages\stripe\_issuing_service.py:12:from stripe.issuing._token_service import TokenService
.venv\Lib\site-packages\stripe\_issuing_service.py:27:        self.tokens = TokenService(self._requestor)
.venv\Lib\site-packages\stripe\_oauth.py:15:    class OAuthToken(StripeObject):
.venv\Lib\site-packages\stripe\_oauth.py:16:        access_token: Optional[str]
.venv\Lib\site-packages\stripe\_oauth.py:18:        The access token you can use to make requests on behalf of this Stripe account. Use it as you would any Stripe secret API key.
.venv\Lib\site-packages\stripe\_oauth.py:23:        The scope granted to the access token, depending on the scope of the authorization code and scope parameter.
.venv\Lib\site-packages\stripe\_oauth.py:27:        The live mode indicator for the token. If true, the access_token can be used as a live secret key. If false, the access_token can be used as a test secret key.
.venv\Lib\site-packages\stripe\_oauth.py:30:        token_type: Optional[Literal["bearer"]]
.venv\Lib\site-packages\stripe\_oauth.py:34:        refresh_token: Optional[str]
.venv\Lib\site-packages\stripe\_oauth.py:36:        Can be used to get a new access token of an equal or lesser scope, or of a different live mode (where applicable).
.venv\Lib\site-packages\stripe\_oauth.py:44:        A publishable key that can be used with this account. Matches the modelive or testof the token.
.venv\Lib\site-packages\stripe\_oauth.py:125:        phone_number: NotRequired[str]
.venv\Lib\site-packages\stripe\_oauth.py:250:    class OAuthTokenParams(TypedDict):
.venv\Lib\site-packages\stripe\_oauth.py:251:        grant_type: Literal["authorization_code", "refresh_token"]
.venv\Lib\site-packages\stripe\_oauth.py:253:        `'authorization_code'` when turning an authorization code into an access token, or `'refresh_token'` when using a refresh token to get a new access token.
.venv\Lib\site-packages\stripe\_oauth.py:257:        The value of the code or refresh_token, depending on the grant_type.
.venv\Lib\site-packages\stripe\_oauth.py:259:        refresh_token: NotRequired[str]
.venv\Lib\site-packages\stripe\_oauth.py:261:        The value of the code or refresh_token, depending on the grant_type.
.venv\Lib\site-packages\stripe\_oauth.py:265:        When requesting a new access token from a refresh token, any scope that has an equal or lesser scope as the refresh token. Has no effect when requesting an access token from an authorization code.
.venv\Lib\site-packages\stripe\_oauth.py:266:        Defaults to the scope of the refresh token.
.venv\Lib\site-packages\stripe\_oauth.py:323:    def token(
.venv\Lib\site-packages\stripe\_oauth.py:324:        api_key: Optional[str] = None, **params: Unpack[OAuthTokenParams]
.venv\Lib\site-packages\stripe\_oauth.py:325:    ) -> OAuthToken:
.venv\Lib\site-packages\stripe\_oauth.py:329:            "OAuth.OAuthToken",
.venv\Lib\site-packages\stripe\_oauth.py:332:                "/oauth/token",
.venv\Lib\site-packages\stripe\_oauth_service.py:75:    def token(
.venv\Lib\site-packages\stripe\_oauth_service.py:77:        params: OAuth.OAuthTokenParams,
.venv\Lib\site-packages\stripe\_oauth_service.py:79:    ) -> OAuth.OAuthToken:
.venv\Lib\site-packages\stripe\_oauth_service.py:83:            OAuth.OAuthToken,
.venv\Lib\site-packages\stripe\_oauth_service.py:86:                "/oauth/token",
.venv\Lib\site-packages\stripe\_object_classes.py:41:    stripe.ConfirmationToken.OBJECT_NAME: stripe.ConfirmationToken,
.venv\Lib\site-packages\stripe\_object_classes.py:81:    stripe.issuing.Token.OBJECT_NAME: stripe.issuing.Token,
.venv\Lib\site-packages\stripe\_object_classes.py:129:    stripe.terminal.ConnectionToken.OBJECT_NAME: stripe.terminal.ConnectionToken,
.venv\Lib\site-packages\stripe\_object_classes.py:133:    stripe.Token.OBJECT_NAME: stripe.Token,
.venv\Lib\site-packages\stripe\_payment_intent.py:155:                "cardholder_phone_number_required",
.venv\Lib\site-packages\stripe\_payment_intent.py:301:                "token_already_used",
.venv\Lib\site-packages\stripe\_payment_intent.py:302:                "token_card_network_invalid",
.venv\Lib\site-packages\stripe\_payment_intent.py:303:                "token_in_use",
.venv\Lib\site-packages\stripe\_payment_intent.py:1742:            When enabled, using a card that is attached to a customer will require the CVC to be provided again (i.e. using the cvc_token parameter).
.venv\Lib\site-packages\stripe\_payment_intent.py:2027:            persistent_token: Optional[str]
.venv\Lib\site-packages\stripe\_payment_link.py:857:    phone_number_collection: PhoneNumberCollection
.venv\Lib\site-packages\stripe\_payment_link.py:1139:        "phone_number_collection": PhoneNumberCollection,
.venv\Lib\site-packages\stripe\_payment_method.py:299:                    Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_payment_method.py:577:            (For tokenized numbers only.) The last four digits of the device account number.
.venv\Lib\site-packages\stripe\_payment_method.py:636:        Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_payment_method.py:741:        Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_payment_method.py:972:        Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_payment_method.py:1081:        persistent_token: Optional[str]
.venv\Lib\site-packages\stripe\_person.py:759:        token = self.id
.venv\Lib\site-packages\stripe\_person.py:764:        extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_reversal.py:75:        token = self.id
.venv\Lib\site-packages\stripe\_reversal.py:81:        extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_setup_attempt.py:198:            Uniquely identifies this particular card number. You can use this attribute to check whether two customers who've signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.
.venv\Lib\site-packages\stripe\_setup_attempt.py:485:                "cardholder_phone_number_required",
.venv\Lib\site-packages\stripe\_setup_attempt.py:631:                "token_already_used",
.venv\Lib\site-packages\stripe\_setup_attempt.py:632:                "token_card_network_invalid",
.venv\Lib\site-packages\stripe\_setup_attempt.py:633:                "token_in_use",
.venv\Lib\site-packages\stripe\_setup_intent.py:127:                "cardholder_phone_number_required",
.venv\Lib\site-packages\stripe\_setup_intent.py:273:                "token_already_used",
.venv\Lib\site-packages\stripe\_setup_intent.py:274:                "token_card_network_invalid",
.venv\Lib\site-packages\stripe\_setup_intent.py:275:                "token_in_use",
.venv\Lib\site-packages\stripe\_setup_intent.py:596:            persistent_token: Optional[str]
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:103:        shipping_rate_token: str,
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:114:                "/v1/shipping_rates/{shipping_rate_token}".format(
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:115:                    shipping_rate_token=sanitize_id(shipping_rate_token),
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:125:        shipping_rate_token: str,
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:136:                "/v1/shipping_rates/{shipping_rate_token}".format(
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:137:                    shipping_rate_token=sanitize_id(shipping_rate_token),
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:147:        shipping_rate_token: str,
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:158:                "/v1/shipping_rates/{shipping_rate_token}".format(
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:159:                    shipping_rate_token=sanitize_id(shipping_rate_token),
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:169:        shipping_rate_token: str,
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:180:                "/v1/shipping_rates/{shipping_rate_token}".format(
.venv\Lib\site-packages\stripe\_shipping_rate_service.py:181:                    shipping_rate_token=sanitize_id(shipping_rate_token),
.venv\Lib\site-packages\stripe\_source.py:105:        tokenization_method: Optional[str]
.venv\Lib\site-packages\stripe\_source.py:163:        client_token: Optional[str]
.venv\Lib\site-packages\stripe\_source.py:481:        tokenization_method: Optional[str]
.venv\Lib\site-packages\stripe\_source.py:909:        token = self.id
.venv\Lib\site-packages\stripe\_source.py:912:            extn = sanitize_id(token)
.venv\Lib\site-packages\stripe\_source.py:924:                "to a customer object." % token,
.venv\Lib\site-packages\stripe\_stripe_client.py:58:from stripe._confirmation_token_service import ConfirmationTokenService
.venv\Lib\site-packages\stripe\_stripe_client.py:113:from stripe._token_service import TokenService
.venv\Lib\site-packages\stripe\_stripe_client.py:466:        StripeClient.confirmation_tokens is deprecated, use StripeClient.v1.confirmation_tokens instead.
.venv\Lib\site-packages\stripe\_stripe_client.py:467:          All functionality under it has been copied over to StripeClient.v1.confirmation_tokens.
.venv\Lib\site-packages\stripe\_stripe_client.py:471:    def confirmation_tokens(self) -> ConfirmationTokenService:
.venv\Lib\site-packages\stripe\_stripe_client.py:472:        return self.v1.confirmation_tokens
.venv\Lib\site-packages\stripe\_stripe_client.py:1029:        StripeClient.tokens is deprecated, use StripeClient.v1.tokens instead.
.venv\Lib\site-packages\stripe\_stripe_client.py:1030:          All functionality under it has been copied over to StripeClient.v1.tokens.
.venv\Lib\site-packages\stripe\_stripe_client.py:1034:    def tokens(self) -> TokenService:
.venv\Lib\site-packages\stripe\_stripe_client.py:1035:        return self.v1.tokens
.venv\Lib\site-packages\stripe\_terminal_service.py:5:from stripe.terminal._connection_token_service import ConnectionTokenService
.venv\Lib\site-packages\stripe\_terminal_service.py:14:        self.connection_tokens = ConnectionTokenService(self._requestor)
.venv\Lib\site-packages\stripe\_test_helpers_service.py:4:from stripe.test_helpers._confirmation_token_service import (
.venv\Lib\site-packages\stripe\_test_helpers_service.py:5:    ConfirmationTokenService,
.venv\Lib\site-packages\stripe\_test_helpers_service.py:18:        self.confirmation_tokens = ConfirmationTokenService(self._requestor)
.venv\Lib\site-packages\stripe\_token.py:10:    from stripe.params._token_create_params import TokenCreateParams
.venv\Lib\site-packages\stripe\_token.py:11:    from stripe.params._token_retrieve_params import TokenRetrieveParams
.venv\Lib\site-packages\stripe\_token.py:14:class Token(CreateableAPIResource["Token"]):
.venv\Lib\site-packages\stripe\_token.py:16:    Tokenization is the process Stripe uses to collect sensitive card or bank
.venv\Lib\site-packages\stripe\_token.py:18:    your customers in a secure manner. A token representing this information is
.venv\Lib\site-packages\stripe\_token.py:24:    If you can't use client-side tokenization, you can also create tokens using
.venv\Lib\site-packages\stripe\_token.py:28:    client-side tokenization, your customer's information isn't sent directly to
.venv\Lib\site-packages\stripe\_token.py:31:    You can't store or use tokens more than once. To store card or bank account
.venv\Lib\site-packages\stripe\_token.py:35:    performs best with integrations that use client-side tokenization.
.venv\Lib\site-packages\stripe\_token.py:38:    OBJECT_NAME: ClassVar[Literal["token"]] = "token"
.venv\Lib\site-packages\stripe\_token.py:59:    IP address of the client that generates the token.
.venv\Lib\site-packages\stripe\_token.py:73:    object: Literal["token"]
.venv\Lib\site-packages\stripe\_token.py:79:    Type of the token: `account`, `bank_account`, `card`, or `pii`.
.venv\Lib\site-packages\stripe\_token.py:83:    Determines if you have already used this token (you can only use tokens once).
.venv\Lib\site-packages\stripe\_token.py:87:    def create(cls, **params: Unpack["TokenCreateParams"]) -> "Token":
.venv\Lib\site-packages\stripe\_token.py:89:        Creates a single-use token that represents a bank account's details.
.venv\Lib\site-packages\stripe\_token.py:90:        You can use this token with any v1 API method in place of a bank account dictionary. You can only use this token once. To do so, attach it to a [connected account](https://docs.stripe.com/api#accounts) where [controller.requirement_collection](https://docs.stripe.com/api/accounts/object#account_object-controller-requirement_collection) is application, which includes Custom accounts.
.venv\Lib\site-packages\stripe\_token.py:93:            "Token",
.venv\Lib\site-packages\stripe\_token.py:103:        cls, **params: Unpack["TokenCreateParams"]
.venv\Lib\site-packages\stripe\_token.py:104:    ) -> "Token":
.venv\Lib\site-packages\stripe\_token.py:106:        Creates a single-use token that represents a bank account's details.
.venv\Lib\site-packages\stripe\_token.py:107:        You can use this token with any v1 API method in place of a bank account dictionary. You can only use this token once. To do so, attach it to a [connected account](https://docs.stripe.com/api#accounts) where [controller.requirement_collection](https://docs.stripe.com/api/accounts/object#account_object-controller-requirement_collection) is application, which includes Custom accounts.
.venv\Lib\site-packages\stripe\_token.py:110:            "Token",
.venv\Lib\site-packages\stripe\_token.py:120:        cls, id: str, **params: Unpack["TokenRetrieveParams"]
.venv\Lib\site-packages\stripe\_token.py:121:    ) -> "Token":
.venv\Lib\site-packages\stripe\_token.py:123:        Retrieves the token with the given ID.
.venv\Lib\site-packages\stripe\_token.py:131:        cls, id: str, **params: Unpack["TokenRetrieveParams"]
.venv\Lib\site-packages\stripe\_token.py:132:    ) -> "Token":
.venv\Lib\site-packages\stripe\_token.py:134:        Retrieves the token with the given ID.
.venv\Lib\site-packages\stripe\_token_service.py:5:from stripe._token import Token
.venv\Lib\site-packages\stripe\_token_service.py:11:    from stripe.params._token_create_params import TokenCreateParams
.venv\Lib\site-packages\stripe\_token_service.py:12:    from stripe.params._token_retrieve_params import TokenRetrieveParams
.venv\Lib\site-packages\stripe\_token_service.py:15:class TokenService(StripeService):
.venv\Lib\site-packages\stripe\_token_service.py:18:        token: str,
.venv\Lib\site-packages\stripe\_token_service.py:19:        params: Optional["TokenRetrieveParams"] = None,
.venv\Lib\site-packages\stripe\_token_service.py:21:    ) -> Token:
.venv\Lib\site-packages\stripe\_token_service.py:23:        Retrieves the token with the given ID.
.venv\Lib\site-packages\stripe\_token_service.py:26:            Token,
.venv\Lib\site-packages\stripe\_token_service.py:29:                "/v1/tokens/{token}".format(token=sanitize_id(token)),
.venv\Lib\site-packages\stripe\_token_service.py:38:        token: str,
.venv\Lib\site-packages\stripe\_token_service.py:39:        params: Optional["TokenRetrieveParams"] = None,
.venv\Lib\site-packages\stripe\_token_service.py:41:    ) -> Token:
.venv\Lib\site-packages\stripe\_token_service.py:43:        Retrieves the token with the given ID.
.venv\Lib\site-packages\stripe\_token_service.py:46:            Token,
.venv\Lib\site-packages\stripe\_token_service.py:49:                "/v1/tokens/{token}".format(token=sanitize_id(token)),
.venv\Lib\site-packages\stripe\_token_service.py:58:        params: Optional["TokenCreateParams"] = None,
.venv\Lib\site-packages\stripe\_token_service.py:60:    ) -> Token:
.venv\Lib\site-packages\stripe\_token_service.py:62:        Creates a single-use token that represents a bank account's details.
.venv\Lib\site-packages\stripe\_token_service.py:63:        You can use this token with any v1 API method in place of a bank account dictionary. You can only use this token once. To do so, attach it to a [connected account](https://docs.stripe.com/api#accounts) where [controller.requirement_collection](https://docs.stripe.com/api/accounts/object#account_object-controller-requirement_collection) is application, which includes Custom accounts.
.venv\Lib\site-packages\stripe\_token_service.py:66:            Token,
.venv\Lib\site-packages\stripe\_token_service.py:69:                "/v1/tokens",
.venv\Lib\site-packages\stripe\_token_service.py:78:        params: Optional["TokenCreateParams"] = None,
.venv\Lib\site-packages\stripe\_token_service.py:80:    ) -> Token:
.venv\Lib\site-packages\stripe\_token_service.py:82:        Creates a single-use token that represents a bank account's details.
.venv\Lib\site-packages\stripe\_token_service.py:83:        You can use this token with any v1 API method in place of a bank account dictionary. You can only use this token once. To do so, attach it to a [connected account](https://docs.stripe.com/api#accounts) where [controller.requirement_collection](https://docs.stripe.com/api/accounts/object#account_object-controller-requirement_collection) is application, which includes Custom accounts.
.venv\Lib\site-packages\stripe\_token_service.py:86:            Token,
.venv\Lib\site-packages\stripe\_token_service.py:89:                "/v1/tokens",
.venv\Lib\site-packages\stripe\_v1_services.py:17:from stripe._confirmation_token_service import ConfirmationTokenService
.venv\Lib\site-packages\stripe\_v1_services.py:73:from stripe._token_service import TokenService
.venv\Lib\site-packages\stripe\_v1_services.py:97:        self.confirmation_tokens = ConfirmationTokenService(self._requestor)
.venv\Lib\site-packages\stripe\_v1_services.py:158:        self.tokens = TokenService(self._requestor)
.venv\Lib\site-packages\stripe\__init__.py:297:from stripe._confirmation_token import ConfirmationToken as ConfirmationToken
.venv\Lib\site-packages\stripe\__init__.py:298:from stripe._confirmation_token_service import (
.venv\Lib\site-packages\stripe\__init__.py:299:    ConfirmationTokenService as ConfirmationTokenService,
.venv\Lib\site-packages\stripe\__init__.py:522:from stripe._token import Token as Token
.venv\Lib\site-packages\stripe\__init__.py:523:from stripe._token_service import TokenService as TokenService
.venv\Lib\site-packages\tqdm\contrib\bells.py:7:    + uses `${TQDM_TELEGRAM_TOKEN}` and `${TQDM_TELEGRAM_CHAT_ID}`
.venv\Lib\site-packages\tqdm\contrib\bells.py:9:    + uses `${TQDM_DISCORD_TOKEN}` and `${TQDM_DISCORD_CHANNEL_ID}`
.venv\Lib\site-packages\tqdm\contrib\bells.py:15:if getenv("TQDM_SLACK_TOKEN") and getenv("TQDM_SLACK_CHANNEL"):
.venv\Lib\site-packages\tqdm\contrib\bells.py:17:elif getenv("TQDM_TELEGRAM_TOKEN") and getenv("TQDM_TELEGRAM_CHAT_ID"):
.venv\Lib\site-packages\tqdm\contrib\bells.py:19:elif getenv("TQDM_DISCORD_TOKEN") and getenv("TQDM_DISCORD_CHANNEL_ID"):
.venv\Lib\site-packages\tqdm\contrib\discord.py:6:>>> for i in trange(10, token='{token}', channel_id='{channel_id}'):
.venv\Lib\site-packages\tqdm\contrib\discord.py:31:    def __init__(self, token, channel_id):
.venv\Lib\site-packages\tqdm\contrib\discord.py:34:        self.token = token
.venv\Lib\site-packages\tqdm\contrib\discord.py:47:                headers={'Authorization': f'Bot {self.token}', 'User-Agent': self.UA},
.venv\Lib\site-packages\tqdm\contrib\discord.py:74:                headers={'Authorization': f'Bot {self.token}', 'User-Agent': self.UA},
.venv\Lib\site-packages\tqdm\contrib\discord.py:87:                headers={'Authorization': f'Bot {self.token}', 'User-Agent': self.UA})
.venv\Lib\site-packages\tqdm\contrib\discord.py:102:    - copy the bot `{token}` & `{channel_id}` and paste below
.venv\Lib\site-packages\tqdm\contrib\discord.py:105:    >>> for i in tqdm(iterable, token='{token}', channel_id='{channel_id}'):
.venv\Lib\site-packages\tqdm\contrib\discord.py:112:        token  : str, required. Discord bot token
.venv\Lib\site-packages\tqdm\contrib\discord.py:113:            [default: ${TQDM_DISCORD_TOKEN}].
.venv\Lib\site-packages\tqdm\contrib\discord.py:122:                kwargs.pop('token', getenv('TQDM_DISCORD_TOKEN')),
.venv\Lib\site-packages\tqdm\contrib\slack.py:6:>>> for i in trange(10, token='{token}', channel='{channel}'):
.venv\Lib\site-packages\tqdm\contrib\slack.py:28:    def __init__(self, token, channel):
.venv\Lib\site-packages\tqdm\contrib\slack.py:31:        self.client = WebClient(token=token)
.venv\Lib\site-packages\tqdm\contrib\slack.py:66:    - copy the bot `{token}` & `{channel}` and paste below
.venv\Lib\site-packages\tqdm\contrib\slack.py:68:    >>> for i in tqdm(iterable, token='{token}', channel='{channel}'):
.venv\Lib\site-packages\tqdm\contrib\slack.py:75:        token  : str, required. Slack token
.venv\Lib\site-packages\tqdm\contrib\slack.py:76:            [default: ${TQDM_SLACK_TOKEN}].
.venv\Lib\site-packages\tqdm\contrib\slack.py:88:                kwargs.pop('token', getenv("TQDM_SLACK_TOKEN")),
.venv\Lib\site-packages\tqdm\contrib\telegram.py:6:>>> for i in trange(10, token='{token}', chat_id='{chat_id}'):
.venv\Lib\site-packages\tqdm\contrib\telegram.py:28:    def __init__(self, token, chat_id):
.venv\Lib\site-packages\tqdm\contrib\telegram.py:31:        self.token = token
.venv\Lib\site-packages\tqdm\contrib\telegram.py:43:                self.API + '%s/sendMessage' % self.token,
.venv\Lib\site-packages\tqdm\contrib\telegram.py:69:                self.session.post, self.API + '%s/editMessageText' % self.token,
.venv\Lib\site-packages\tqdm\contrib\telegram.py:81:                self.session.post, self.API + '%s/deleteMessage' % self.token,
.venv\Lib\site-packages\tqdm\contrib\telegram.py:95:    - copy its `{token}`
.venv\Lib\site-packages\tqdm\contrib\telegram.py:97:    - go to <https://api.telegram.org/bot`{token}`/getUpdates> to find out
.venv\Lib\site-packages\tqdm\contrib\telegram.py:99:    - paste the `{token}` & `{chat_id}` below
.venv\Lib\site-packages\tqdm\contrib\telegram.py:102:    >>> for i in tqdm(iterable, token='{token}', chat_id='{chat_id}'):
.venv\Lib\site-packages\tqdm\contrib\telegram.py:109:        token  : str, required. Telegram token
.venv\Lib\site-packages\tqdm\contrib\telegram.py:110:            [default: ${TQDM_TELEGRAM_TOKEN}].
.venv\Lib\site-packages\tqdm\contrib\telegram.py:119:                kwargs.pop('token', getenv('TQDM_TELEGRAM_TOKEN')),
.venv\Lib\site-packages\urllib3\connection.py:397:                f"Method cannot contain non-token characters {method!r} (found at least {match.group()!r})"
.venv\Lib\site-packages\urllib3\util\request.py:48:    token = 0
.venv\Lib\site-packages\urllib3\util\request.py:51:_FAILEDTELL: Final[_TYPE_FAILEDTELL] = _TYPE_FAILEDTELL.token
.venv\Lib\site-packages\urllib3\util\timeout.py:17:    token = -1
.venv\Lib\site-packages\urllib3\util\timeout.py:20:_DEFAULT_TIMEOUT: Final[_TYPE_DEFAULT] = _TYPE_DEFAULT.token
.venv\Lib\site-packages\websockets\asyncio\connection.py:480:                    self.protocol.send_text(message.encode())
.venv\Lib\site-packages\websockets\asyncio\connection.py:485:                    self.protocol.send_text(message)
.venv\Lib\site-packages\websockets\asyncio\connection.py:512:                            self.protocol.send_text(chunk.encode(), fin=False)
.venv\Lib\site-packages\websockets\asyncio\connection.py:517:                            self.protocol.send_text(chunk, fin=False)
.venv\Lib\site-packages\websockets\asyncio\connection.py:572:                            self.protocol.send_text(chunk.encode(), fin=False)
.venv\Lib\site-packages\websockets\asyncio\connection.py:577:                            self.protocol.send_text(chunk, fin=False)
.venv\Lib\site-packages\websockets\asyncio\connection.py:871:                self.protocol.send_text(message.encode())
.venv\Lib\site-packages\websockets\asyncio\connection.py:1184:        send_method = "send_text"
.venv\Lib\site-packages\websockets\asyncio\connection.py:1213:            # Call connection.protocol.send_text or send_binary.
.venv\Lib\site-packages\websockets\frames.py:323:            mask_bytes = secrets.token_bytes(4)
.venv\Lib\site-packages\websockets\headers.py:103:_token_re = re.compile(r"[-!#$%&\'*+.^_`|~0-9a-zA-Z]+")
.venv\Lib\site-packages\websockets\headers.py:106:def parse_token(header: str, pos: int, header_name: str) -> tuple[str, int]:
.venv\Lib\site-packages\websockets\headers.py:108:    Parse a token from ``header`` at the given position.
.venv\Lib\site-packages\websockets\headers.py:110:    Return the token value and the new position.
.venv\Lib\site-packages\websockets\headers.py:116:    match = _token_re.match(header, pos)
.venv\Lib\site-packages\websockets\headers.py:118:        raise InvalidHeaderFormat(header_name, "expected token", header, pos)
.venv\Lib\site-packages\websockets\headers.py:243:    item, pos = parse_token(header, pos, header_name)
.venv\Lib\site-packages\websockets\headers.py:315:    name, pos = parse_token(header, pos, header_name)
.venv\Lib\site-packages\websockets\headers.py:326:            # the 'token' ABNF.
.venv\Lib\site-packages\websockets\headers.py:327:            if _token_re.fullmatch(value) is None:
.venv\Lib\site-packages\websockets\headers.py:332:            value, pos = parse_token(header, pos, header_name)
.venv\Lib\site-packages\websockets\headers.py:352:    name, pos = parse_token(header, pos, header_name)
.venv\Lib\site-packages\websockets\headers.py:404:            # Quoted strings aren't necessary because values are always tokens.
.venv\Lib\site-packages\websockets\headers.py:438:    item, pos = parse_token(header, pos, header_name)
.venv\Lib\site-packages\websockets\headers.py:481:        if not _token_re.fullmatch(subprotocol):
.venv\Lib\site-packages\websockets\headers.py:499:_token68_re = re.compile(r"[A-Za-z0-9-._~+/]+=*")
.venv\Lib\site-packages\websockets\headers.py:502:def parse_token68(header: str, pos: int, header_name: str) -> tuple[str, int]:
.venv\Lib\site-packages\websockets\headers.py:504:    Parse a token68 from ``header`` at the given position.
.venv\Lib\site-packages\websockets\headers.py:506:    Return the token value and the new position.
.venv\Lib\site-packages\websockets\headers.py:512:    match = _token68_re.match(header, pos)
.venv\Lib\site-packages\websockets\headers.py:514:        raise InvalidHeaderFormat(header_name, "expected token68", header, pos)
.venv\Lib\site-packages\websockets\headers.py:543:    scheme, pos = parse_token(header, 0, "Authorization")
.venv\Lib\site-packages\websockets\headers.py:554:    basic_credentials, pos = parse_token68(header, pos, "Authorization")
.venv\Lib\site-packages\websockets\http11.py:62:_token_re = re.compile(rb"[-!#$%&\'*+.^_`|~0-9a-zA-Z]+")
.venv\Lib\site-packages\websockets\http11.py:353:        if not _token_re.fullmatch(raw_name):
.venv\Lib\site-packages\websockets\legacy\http.py:29:_token_re = re.compile(rb"[-!#$%&\'*+.^_`|~0-9a-zA-Z]+")
.venv\Lib\site-packages\websockets\legacy\http.py:170:        if not _token_re.fullmatch(raw_name):
.venv\Lib\site-packages\websockets\protocol.py:315:    def send_text(self, data: bytes, fin: bool = True) -> None:
.venv\Lib\site-packages\websockets\sync\connection.py:475:                    self.protocol.send_text(message.encode())
.venv\Lib\site-packages\websockets\sync\connection.py:484:                    self.protocol.send_text(message)
.venv\Lib\site-packages\websockets\sync\connection.py:515:                            self.protocol.send_text(chunk.encode(), fin=False)
.venv\Lib\site-packages\websockets\sync\connection.py:526:                            self.protocol.send_text(chunk, fin=False)
.venv\Lib\site-packages\websockets\sync\connection.py:918:                self.protocol.send_text(message.encode())
.venv\Lib\site-packages\websockets\utils.py:20:    key = secrets.token_bytes(16)
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:25:    Depending on the auth scheme, either :attr:`parameters` or :attr:`token` will be
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:26:    set. The ``Basic`` scheme's token is decoded into the ``username`` and ``password``
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:33:        The ``token`` parameter and attribute was added to support auth schemes that use
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:34:        a token instead of parameters, such as ``Bearer``.
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:47:        token: str | None = None,
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:56:        """A dict of parameters parsed from the header. Either this or :attr:`token`
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:60:        self.token = token
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:61:        """A token parsed from the header. Either this or :attr:`parameters` will have a
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:85:            and other.token == self.token
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:117:        # No = or only trailing =, this is a token.
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:131:        if self.token is not None:
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:132:            return f"{self.type.title()} {self.token}"
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:150:    Depending on the auth scheme, either :attr:`parameters` or :attr:`token` should be
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:152:    token.
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:159:        The ``token`` parameter and attribute was added to support auth schemes that use
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:160:        a token instead of parameters, such as ``Bearer``.
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:173:        token: str | None = None,
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:179:        self._token = token
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:198:        """A dict of parameters for the header. Only one of this or :attr:`token` should
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:209:    def token(self) -> str | None:
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:210:        """A dict of parameters for the header. Only one of this or :attr:`token` should
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:213:        return self._token
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:215:    @token.setter
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:216:    def token(self, value: str | None) -> None:
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:217:        """A token for the header. Only one of this or :attr:`parameters` should have a
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:222:        self._token = value
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:246:        if name in {"_type", "_parameters", "_token", "_on_update"}:
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:263:            and other.token == self.token
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:290:        # No = or only trailing =, this is a token.
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:295:        if self.token is not None:
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:296:            return f"{self.type.title()} {self.token}"
.venv\Lib\site-packages\werkzeug\datastructures\auth.py:303:                    value = quote_header_value(value, allow_token=False)
.venv\Lib\site-packages\werkzeug\http.py:26:_token_chars = frozenset(
.venv\Lib\site-packages\werkzeug\http.py:139:def quote_header_value(value: t.Any, allow_token: bool = True) -> str:
.venv\Lib\site-packages\werkzeug\http.py:140:    """Add double quotes around a header value. If the header contains only ASCII token
.venv\Lib\site-packages\werkzeug\http.py:147:    :param allow_token: Disable to quote the value even if it only has token characters.
.venv\Lib\site-packages\werkzeug\http.py:165:    if allow_token:
.venv\Lib\site-packages\werkzeug\http.py:166:        token_chars = _token_chars
.venv\Lib\site-packages\werkzeug\http.py:168:        if token_chars.issuperset(value_str):
.venv\Lib\site-packages\werkzeug\http.py:204:    If a value contains non-token characters, it will be quoted.
.venv\Lib\site-packages\werkzeug\http.py:246:    If a value contains non-token characters, it will be quoted.
.venv\Lib\site-packages\werkzeug\http.py:266:        The ``allow_token`` parameter is removed.
.venv\Lib\site-packages\werkzeug\http.py:309:        parse_list_header('token, "quoted value"')
.venv\Lib\site-packages\werkzeug\http.py:310:        ['token', 'quoted value']
.venv\Lib\site-packages\werkzeug\http.py:403:_parameter_token_value_re = re.compile(r"[\w!#$%&'*+\-.^`|~]+", flags=re.ASCII)
.venv\Lib\site-packages\werkzeug\http.py:409:    ([\w!#$%&'*+\-.^`|~]+)  # one or more token chars with percent encoding
.venv\Lib\site-packages\werkzeug\http.py:493:            # Value may be a token.
.venv\Lib\site-packages\werkzeug\http.py:494:            if (m := _parameter_token_value_re.match(rest)) is not None:
.venv\Lib\site-packages\werkzeug\http.py:746:    >>> hs = parse_set_header('token, "quoted value"')
.venv\Lib\site-packages\werkzeug\http.py:751:    >>> 'TOKEN' in hs
.venv\Lib\site-packages\werkzeug\http.py:756:    HeaderSet(['token', 'quoted value'])
.venv\Lib\site-packages\werkzeug\sansio\request.py:484:            :class:`Authorization` is no longer a ``dict``. The ``token`` attribute
.venv\Lib\site-packages\werkzeug\sansio\request.py:485:            was added for auth schemes that use a token instead of parameters.
.venv\Lib\site-packages\werkzeug\sansio\response.py:519:        string token only.
.venv\Lib\site-packages\werkzeug\sansio\response.py:586:            :class:`WWWAuthenticate` is no longer a ``dict``. The ``token`` attribute
.venv\Lib\site-packages\werkzeug\sansio\response.py:587:            was added for auth challenges that use a token instead of parameters.
.venv\Scripts\fixup_firestore_admin_v1_keywords.py:71:        'list_fields': ('parent', 'filter', 'page_size', 'page_token', ),
.venv\Scripts\fixup_firestore_admin_v1_keywords.py:72:        'list_indexes': ('parent', 'filter', 'page_size', 'page_token', ),
.venv\Scripts\fixup_firestore_v1_keywords.py:55:        'list_collection_ids': ('parent', 'page_size', 'page_token', 'read_time', ),
.venv\Scripts\fixup_firestore_v1_keywords.py:56:        'list_documents': ('parent', 'collection_id', 'page_size', 'page_token', 'order_by', 'mask', 'transaction', 'read_time', 'show_missing', ),
.venv\Scripts\fixup_firestore_v1_keywords.py:58:        'partition_query': ('parent', 'structured_query', 'partition_count', 'page_token', 'page_size', 'read_time', ),
.venv\Scripts\fixup_firestore_v1_keywords.py:63:        'write': ('database', 'stream_id', 'writes', 'stream_token', 'labels', ),
app.py:147:def _token_fingerprint(tok: str):
app.py:256:VERIFY_TOKEN = os.getenv("VERIFY_TOKEN", "meirobo123")
app.py:257:GRAPH_VERSION = os.getenv("GRAPH_VERSION", "v23.0")
app.py:258:PHONE_NUMBER_ID = os.getenv("WHATSAPP_PHONE_NUMBER_ID") or os.getenv("PHONE_NUMBER_ID")
app.py:302:# >>> Novo: CAPTCHA (Turnstile)  valida token e seta cookie curto
app.py:423:        has_whatsapp_token=bool(os.getenv("WHATSAPP_TOKEN")),
app.py:424:        has_phone_number_id=bool(PHONE_NUMBER_ID),
app.py:425:        graph_version=GRAPH_VERSION,
app.py:443:    fp = _token_fingerprint(os.getenv("WHATSAPP_TOKEN", ""))
app.py:445:        "graph_version": GRAPH_VERSION,
app.py:446:        "phone_number_id": PHONE_NUMBER_ID,
app.py:447:        "token_fingerprint": fp,
app.py:470:    if key != VERIFY_TOKEN:
app.py:474:        "VERIFY_TOKEN": bool(os.getenv("VERIFY_TOKEN")),
app.py:475:        "GRAPH_VERSION": GRAPH_VERSION,
app.py:476:        "PHONE_NUMBER_ID": PHONE_NUMBER_ID,
app.py:486:        "WHATSAPP_TOKEN": _mask_secret(os.getenv("WHATSAPP_TOKEN")),
app.py:606:from services.wa_send import send_text as wa_send_text
app.py:609:def api_send_text():
app.py:635:    print(f"[API][SEND_TEXT] to={to} eq_key={eq_key} cands={cands} body_preview={body[:80]}", flush=True)
app.py:639:        ok, resp = wa_send_text(cand, body)
app.py:640:        print(f"[API][SEND_TEXT][try] cand={cand} ok={ok}", flush=True)
app.py:688:    Extrai UID do Authorization: Bearer <idToken> lendo o payload do JWT (sem validar assinatura).
app.py:735:def _verify_turnstile_token(token: str) -> bool:
app.py:737:    if not secret or not token:
app.py:741:        "response": token,
app.py:759:    # 2) fallback: token passado no header ou body  verificao ao vivo
app.py:762:        or (request.get_json(silent=True) or {}).get("cf_token")
app.py:764:        or (request.get_json(silent=True) or {}).get("token")
app.py:765:        or request.headers.get("x-turnstile-token")
app.py:767:    if tok and _verify_turnstile_token(tok):
app.py:841:# ---------- Ativar (com token OU uid) ----------
app.py:894:# ---------- Legado absoluto (codigo+uid no body; sem token) ----------
app.py:902:        # >>> Blindagem: exige humano_ok OU token Turnstile vlido no header/body
mei-robo-whatsapp-webhook\app.py:30:VERIFY_TOKEN = os.environ.get("VERIFY_TOKEN", "meirobo123")
mei-robo-whatsapp-webhook\app.py:31:WHATSAPP_TOKEN = os.environ.get("WHATSAPP_TOKEN")
mei-robo-whatsapp-webhook\app.py:32:PHONE_NUMBER_ID = os.environ.get("PHONE_NUMBER_ID")
mei-robo-whatsapp-webhook\app.py:33:GRAPH_VERSION = os.environ.get("GRAPH_VERSION", "v22.0")
mei-robo-whatsapp-webhook\app.py:52:def send_text(to: str, body: str):
mei-robo-whatsapp-webhook\app.py:53:    """Envia mensagem de texto pelo WhatsApp Cloud API."""
mei-robo-whatsapp-webhook\app.py:55:    if not WHATSAPP_TOKEN or not PHONE_NUMBER_ID:
mei-robo-whatsapp-webhook\app.py:56:        print("[ERROR] CONFIG: Missing WHATSAPP_TOKEN or PHONE_NUMBER_ID", flush=True)
mei-robo-whatsapp-webhook\app.py:57:        return {"ok": False, "error": "missing_whatsapp_config"}
mei-robo-whatsapp-webhook\app.py:59:    url = f"https://graph.facebook.com/{GRAPH_VERSION}/{PHONE_NUMBER_ID}/messages"
mei-robo-whatsapp-webhook\app.py:61:        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
mei-robo-whatsapp-webhook\app.py:65:        "messaging_product": "whatsapp",
mei-robo-whatsapp-webhook\app.py:76:        print(f"[WHATSAPP][OUTBOUND] to={to_digits} status={r.status_code} resp={json.dumps(resp_json, ensure_ascii=False)[:800]}", flush=True)
mei-robo-whatsapp-webhook\app.py:93:        "has_whatsapp_token": bool(WHATSAPP_TOKEN),
mei-robo-whatsapp-webhook\app.py:94:        "has_phone_number_id": bool(PHONE_NUMBER_ID),
mei-robo-whatsapp-webhook\app.py:95:        "graph_version": GRAPH_VERSION,
mei-robo-whatsapp-webhook\app.py:96:        "service": "mei-robo-whatsapp-webhook",
mei-robo-whatsapp-webhook\app.py:109:    return {"status": "ok", "service": "mei-robo-whatsapp-webhook", "webhook": "/webhook"}, 200
mei-robo-whatsapp-webhook\app.py:115:def api_send_text():
mei-robo-whatsapp-webhook\app.py:132:    print(f"[API][SEND_TEXT] to={to} normalized={to_norm} body_preview={body[:80]}", flush=True)
mei-robo-whatsapp-webhook\app.py:133:    result = send_text(to_norm, body)
mei-robo-whatsapp-webhook\app.py:144:        token = request.args.get("hub.verify_token")
mei-robo-whatsapp-webhook\app.py:146:        if mode == "subscribe" and token == VERIFY_TOKEN:
mei-robo-whatsapp-webhook\app.py:149:        print(f"[WEBHOOK][VERIFY] fail mode={mode} token={token}", flush=True)
mei-robo-whatsapp-webhook\app.py:180:                        send_text(to_msisdn, body_preview)
providers\tts.py:256:# ========= helper opcional para envio direto por WhatsApp =========
providers\tts.py:257:def send_tts_whatsapp(
providers\tts.py:266:    Gera TTS e envia pelo WhatsApp.
routes\auth_bp.py:9:def _verify_bearer_token():
routes\auth_bp.py:10:    """Extrai e valida o token Bearer do header Authorization"""
routes\auth_bp.py:14:    token = hdr.split(" ", 1)[1]
routes\auth_bp.py:15:    return fb_auth.verify_id_token(token)
routes\auth_bp.py:20:    Endpoint protegido para validar um ID Token Firebase.
routes\auth_bp.py:21:    Retorna { ok, uid, email, provider } se o token for vlido.
routes\auth_bp.py:25:        decoded = _verify_bearer_token()
routes\auth_bp.py:27:            return jsonify({"ok": False, "error": "missing_or_invalid_token"}), 401
routes\captcha_bp.py:54:    token = data.get("token") or data.get("cf_resp") or request.form.get("token") or ""
routes\captcha_bp.py:55:    if not token:
routes\captcha_bp.py:56:        return jsonify({"ok": False, "error": "missing token"}), 400
routes\captcha_bp.py:62:        "response": token,
routes\cnpj_publica.py:5:# - Sem token (fonte pblica), limite 3 req/min/IP na origem
routes\cnpj_publica.py:67:        b) >=2 tokens da busca aparecem na ORDEM no alvo
routes\cnpj_publica.py:68:        c) existe token >=4 chars da busca presente no alvo
routes\cnpj_publica.py:73:    def tokens(s: str):
routes\cnpj_publica.py:79:    base_busca, toks_busca = tokens(nome_busca)
routes\cnpj_publica.py:84:        base_alvo, toks_alvo = tokens(alvo or "")
routes\cnpj_publica.py:93:        # Tokens em ordem (>=2)
routes\cnpj_publica.py:103:        # Token forte (>=4 chars) presente
routes\compat_licencas.py:98:            return _json_error("Unauthorized (Bearer token ausente).", 401)
routes\compat_licencas.py:99:        # Validao do token pode ser implementada depois
routes\contacts.py:26:    channel = (body.get("channel") or "whatsapp").lower()
routes\cupons.py:118:# Usa o UID do token (g.user.uid). Body: { "codigo": "ABC-123" }
routes\media.py:6:# Requer auth (ID Token Firebase). Perspectiva v1.0 (Render/Flask).
routes\verificacao_autoridade.py:7:    GET  /verificacao/convite/<token>
routes\verificacao_autoridade.py:20:# Auth (suave): tenta Firebase ID Token; se falhar, usa header de debug
routes\verificacao_autoridade.py:77:    # 1) tenta Firebase ID Token (se vier Authorization: Bearer ...)
routes\verificacao_autoridade.py:176:        token_pendente = str(uuid.uuid4())
routes\verificacao_autoridade.py:180:            "token": token_pendente,
routes\verificacao_autoridade.py:193:            "token": token_pendente
routes\verificacao_autoridade.py:199:            "detalhes": {"token": token_pendente}
routes\verificacao_autoridade.py:204:        token = str(uuid.uuid4())
routes\verificacao_autoridade.py:208:            "token": token,
routes\verificacao_autoridade.py:219:            "token": token,
routes\verificacao_autoridade.py:227:            "detalhes": {"token": token, "urlAceiteStub": f"/verificacao/convite/{token}"}
routes\verificacao_autoridade.py:233:@verificacao_bp.get("/verificacao/convite/<token>")
routes\verificacao_autoridade.py:234:def get_convite_stub(token: str):
routes\verificacao_autoridade.py:236:    GET /verificacao/convite/:token -> v1 stub (sempre pendente)
routes\verificacao_autoridade.py:243:        "token": token
routes\verificacao_autoridade.py:246:        "token": token,
routes\verificacao_autoridade.py:326:        token_pendente = str(uuid.uuid4())
routes\verificacao_autoridade.py:328:            "token": token_pendente,
routes\verificacao_autoridade.py:339:            "token": token_pendente
routes\webhook.py:4:from services.wa_send import send_text as _send_text, send_audio as _send_audio
routes\webhook.py:7:VERIFY_TOKEN = os.getenv("VERIFY_TOKEN", "meirobo123")
routes\webhook.py:30:    token = request.args.get("hub.verify_token")
routes\webhook.py:32:    if mode == "subscribe" and token == VERIFY_TOKEN:
routes\webhook.py:35:    logging.warning("[WEBHOOK][VERIFY] fail mode=%s token=%s", mode, token)
routes\webhook.py:85:                                _send_text(to, f"[FALLBACK] handler-indisponivel :: {app_tag}")
routes\webhook.py:97:                            send_text_fn=_send_text,
routes\webhook.py:103:                        wa_mod.process_change(value, _send_text, uid_default, app_tag)
routes\webhook.py:105:                    wa_mod.process_change(value, _send_text, uid_default, app_tag)
server.py:30:def _send_text_local(to: str, body: str):
server.py:33:    TOKEN = os.getenv("WHATSAPP_TOKEN")
server.py:34:    PNI = os.getenv("PHONE_NUMBER_ID")
server.py:35:    GV = os.getenv("GRAPH_VERSION", "v22.0")
server.py:36:    if not TOKEN or not PNI:
server.py:37:        print("[ERROR] CONFIG: Missing WHATSAPP_TOKEN or PHONE_NUMBER_ID", flush=True)
server.py:38:        return False, {"error": "missing_whatsapp_config"}
server.py:40:    headers = {"Authorization": f"Bearer {TOKEN}", "Content-Type": "application/json"}
server.py:42:        "messaging_product": "whatsapp",
server.py:53:        print(f"[WHATSAPP][OUTBOUND] to={to_digits} status={r.status_code} resp={json.dumps(resp_json, ensure_ascii=False)[:800]}", flush=True)
server.py:61:_send_text = getattr(module, "_send_text", _send_text_local)
server.py:87:                has_whatsapp_token=bool(os.getenv("WHATSAPP_TOKEN")),
server.py:88:                has_phone_number_id=bool(os.getenv("PHONE_NUMBER_ID")),
server.py:89:                graph_version=os.getenv("GRAPH_VERSION", "v22.0"),
server.py:95:        def api_send_text_local():
server.py:108:            print(f"[API][SEND_TEXT] to={to} normalized={to_norm} body_preview={body[:80]}", flush=True)
server.py:109:            ok, resp = _send_text(to_norm, body)
server.py:112:        app.add_url_rule("/api/send-text", endpoint="server_api_send_text", view_func=api_send_text_local, methods=["GET", "POST"])
server.py:113:        print("[server] /api/send-text (server_api_send_text) adicionado", flush=True)
services\audio_processing.py:68:            # Fallback: tenta decodificao direta (OGG_OPUS costuma vir do WhatsApp)
services\auth.py:65:        # No explode a inicializao; verify_id_token falhar se no houver credencial vlida
services\auth.py:100:# Verificao forte de ID Token
services\auth.py:102:def verify_id_token_strict(token: str) -> dict:
services\auth.py:104:    Verifica o ID Token do Firebase *com revogao*.
services\auth.py:108:    return fb_auth.verify_id_token(token, check_revoked=True)
services\auth.py:116:    token = _get_bearer()
services\auth.py:117:    if not token:
services\auth.py:120:        decoded = verify_id_token_strict(token)
services\auth.py:155:    Exige Authorization: Bearer <ID_TOKEN Firebase> vlido.
services\auth.py:161:        token = _get_bearer()
services\auth.py:162:        if not token:
services\auth.py:174:                decoded = verify_id_token_strict(token)
services\auth.py:177:                    return jsonify({"erro": "Token invlido (sem UID)"}), 401
services\auth.py:179:            except fb_auth.RevokedIdTokenError:
services\auth.py:180:                return jsonify({"erro": "Token revogado"}), 401
services\auth.py:181:            except fb_auth.ExpiredIdTokenError:
services\auth.py:182:                return jsonify({"erro": "Token expirado"}), 401
services\auth.py:185:                return jsonify({"erro": "Token invlido"}), 401
services\auth.py:195:      - Header: Authorization: Bearer <ID_TOKEN Firebase>
services\auth.py:204:        token = _get_bearer()
services\auth.py:212:        # Sem token  considerar bypass de DEV (apenas fora de produo)
services\auth.py:213:        if not token:
services\auth.py:225:                decoded = verify_id_token_strict(token)
services\auth.py:229:                    return jsonify({"erro": "Token invlido (sem UID)"}), 401
services\auth.py:231:            except fb_auth.RevokedIdTokenError:
services\auth.py:232:                return jsonify({"erro": "Token revogado"}), 401
services\auth.py:233:            except fb_auth.ExpiredIdTokenError:
services\auth.py:234:                return jsonify({"erro": "Token expirado"}), 401
services\auth.py:236:                logger.warning(f"Falha verify_id_token (discreto): {type(e).__name__}")
services\auth.py:237:                return jsonify({"erro": "Token invlido"}), 401
services\auth_bp.py:8:def _verify_bearer_token():
services\auth_bp.py:12:    token = hdr.split(" ", 1)[1]
services\auth_bp.py:13:    return fb_auth.verify_id_token(token)
services\auth_bp.py:19:        decoded = _verify_bearer_token()
services\auth_bp.py:21:            return jsonify({"ok": False, "error": "missing_or_invalid_token"}), 401
services\crm.py:62:def add_media_from_bytes(uid: str, cliente_id: str, data: bytes, *, content_type: str, caption: str = "", tags: Optional[List[str]] = None, source: str = "whatsapp") -> Dict[str, Any]:
services\humanizer.py:32:_HEXISH_TOKEN = re.compile(r"\b[A-Fa-f0-9]{10,}\b")
services\humanizer.py:40:    # remove tokens longos com cara de hash (sem pegar datas/preos)
services\humanizer.py:41:    m = _HEXISH_TOKEN.sub("", m)
services\openai\nlu_intent.py:41:        "max_tokens": 250,
services\text_to_speech.py:211:    Observao: mesmo se 'format' pedir OGG, ElevenLabs entrega MP3 (WhatsApp aceita).
services\wa_bot.backup.20250930.py:2:# Bot WhatsApp do MEI Rob
services\wa_bot.backup.20250930.py:457:GRAPH_VERSION_DEFAULT = os.getenv("GRAPH_VERSION", "v23.0")
services\wa_bot.backup.20250930.py:954:def send_reply(uid: str, to: str, text: str, inbound_type: str, send_text_fn, send_audio_fn=None, voice_hint: Optional[str]=None):
services\wa_bot.backup.20250930.py:976:    return send_text_fn(to, text)
services\wa_bot.backup.20250930.py:1402:        "canal": "whatsapp",
services\wa_bot.backup.20250930.py:1466:def _reply_prices(uid: str, to: str, send_text, channel_mode: str = "text"):
services\wa_bot.backup.20250930.py:1475:        f"[WHATSAPP][OUTBOUND] prices count={len(items)} map={counts.get('map')} precos={counts.get('precos')} ps={counts.get('ps')}"
services\wa_bot.backup.20250930.py:1477:    return send_text(to, msg)
services\wa_bot.backup.20250930.py:1480:def _reply_price_from_cache_or_data(uid: str, to: str, user_text: str, send_text, channel_mode: str = "text"):
services\wa_bot.backup.20250930.py:1486:            return send_text(to, cached)
services\wa_bot.backup.20250930.py:1493:        return _reply_prices(uid, to, send_text, channel_mode=channel_mode)
services\wa_bot.backup.20250930.py:1520:        return _reply_prices(uid, to, send_text, channel_mode=channel_mode)
services\wa_bot.backup.20250930.py:1531:    return send_text(to, msg)
services\wa_bot.backup.20250930.py:1534:def _reply_faq(uid: str, to: str, faq_key: str, send_text, channel_mode: str = "text"):
services\wa_bot.backup.20250930.py:1540:    return send_text(to, msg)
services\wa_bot.backup.20250930.py:1543:def _reply_schedule(uid: str, to: str, serviceName: Optional[str], dateText: str, timeText: str, send_text, value: dict, body_text: str, channel_mode: str = "text"):
services\wa_bot.backup.20250930.py:1546:        return send_text(to, f"No consegui agendar: {reason}")
services\wa_bot.backup.20250930.py:1565:        return send_text(to, "No entendi a data/hora. Pode enviar no formato 01/09 14:00?")
services\wa_bot.backup.20250930.py:1567:    return send_text(to, msg if ok2 else f"No consegui agendar: {msg}")
services\wa_bot.backup.20250930.py:1687:def process_change(value: Dict[str, Any], send_text_fn, uid_default: str, app_tag: str, send_audio_fn=None):
services\wa_bot.backup.20250930.py:1690:    send_text_fn: funo injetada por app.py para enviar texto
services\wa_bot.backup.20250930.py:1716:                    send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:sem-media_id"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1725:                    token = os.getenv("WHATSAPP_TOKEN")
services\wa_bot.backup.20250930.py:1726:                    gv = GRAPH_VERSION_DEFAULT
services\wa_bot.backup.20250930.py:1729:                        headers={"Authorization": f"Bearer {token}"},
services\wa_bot.backup.20250930.py:1734:                        send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:sem-url"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1736:                    r = requests.get(media_url, headers={"Authorization": f"Bearer {token}"}, timeout=30)
services\wa_bot.backup.20250930.py:1741:                    send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:bytes=0"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1748:                send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:error"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1756:            send_reply(uid_default, to_raw, help_msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1788:            send_reply(uid_default, to_raw, say(uid_default, "session_cleared"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1793:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1798:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1804:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1809:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1818:            send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1826:            send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1832:            send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1841:                send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1845:                send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.backup.20250930.py:1851:        send_reply(uid_default, to_raw, help_msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot.py:95:    """Entrada generica (ex.: webhook do WhatsApp)."""
services\wa_bot_legacy.py:2:# Bot WhatsApp do MEI Rob
services\wa_bot_legacy.py:457:GRAPH_VERSION_DEFAULT = os.getenv("GRAPH_VERSION", "v23.0")
services\wa_bot_legacy.py:954:def send_reply(uid: str, to: str, text: str, inbound_type: str, send_text_fn, send_audio_fn=None, voice_hint: Optional[str]=None):
services\wa_bot_legacy.py:976:    return send_text_fn(to, text)
services\wa_bot_legacy.py:1402:        "canal": "whatsapp",
services\wa_bot_legacy.py:1466:def _reply_prices(uid: str, to: str, send_text, channel_mode: str = "text"):
services\wa_bot_legacy.py:1475:        f"[WHATSAPP][OUTBOUND] prices count={len(items)} map={counts.get('map')} precos={counts.get('precos')} ps={counts.get('ps')}"
services\wa_bot_legacy.py:1477:    return send_text(to, msg)
services\wa_bot_legacy.py:1480:def _reply_price_from_cache_or_data(uid: str, to: str, user_text: str, send_text, channel_mode: str = "text"):
services\wa_bot_legacy.py:1486:            return send_text(to, cached)
services\wa_bot_legacy.py:1493:        return _reply_prices(uid, to, send_text, channel_mode=channel_mode)
services\wa_bot_legacy.py:1520:        return _reply_prices(uid, to, send_text, channel_mode=channel_mode)
services\wa_bot_legacy.py:1531:    return send_text(to, msg)
services\wa_bot_legacy.py:1534:def _reply_faq(uid: str, to: str, faq_key: str, send_text, channel_mode: str = "text"):
services\wa_bot_legacy.py:1540:    return send_text(to, msg)
services\wa_bot_legacy.py:1543:def _reply_schedule(uid: str, to: str, serviceName: Optional[str], dateText: str, timeText: str, send_text, value: dict, body_text: str, channel_mode: str = "text"):
services\wa_bot_legacy.py:1546:        return send_text(to, f"No consegui agendar: {reason}")
services\wa_bot_legacy.py:1565:        return send_text(to, "No entendi a data/hora. Pode enviar no formato 01/09 14:00?")
services\wa_bot_legacy.py:1567:    return send_text(to, msg if ok2 else f"No consegui agendar: {msg}")
services\wa_bot_legacy.py:1687:def process_change(value: Dict[str, Any], send_text_fn, uid_default: str, app_tag: str, send_audio_fn=None):
services\wa_bot_legacy.py:1690:    send_text_fn: funo injetada por app.py para enviar texto
services\wa_bot_legacy.py:1716:                    send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:sem-media_id"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1725:                    token = os.getenv("WHATSAPP_TOKEN")
services\wa_bot_legacy.py:1726:                    gv = GRAPH_VERSION_DEFAULT
services\wa_bot_legacy.py:1729:                        headers={"Authorization": f"Bearer {token}"},
services\wa_bot_legacy.py:1734:                        send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:sem-url"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1736:                    r = requests.get(media_url, headers={"Authorization": f"Bearer {token}"}, timeout=30)
services\wa_bot_legacy.py:1741:                    send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:bytes=0"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1748:                send_reply(uid_default, to_raw, fallback_text(app_tag, "audio:error"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1756:            send_reply(uid_default, to_raw, help_msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1788:            send_reply(uid_default, to_raw, say(uid_default, "session_cleared"), msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1793:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1798:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1804:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1809:            send = lambda _to, _msg: send_reply(uid_default, _to, _msg, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1818:            send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1826:            send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1832:            send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1841:                send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1845:                send_reply(uid_default, to_raw, reply, msg_type, send_text_fn, send_audio_fn)
services\wa_bot_legacy.py:1851:        send_reply(uid_default, to_raw, help_msg, msg_type, send_text_fn, send_audio_fn)
services\wa_send.py:9:GRAPH_VERSION = os.getenv("GRAPH_VERSION", "v23.0")
services\wa_send.py:10:WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
services\wa_send.py:11:PHONE_NUMBER_ID = os.getenv("WHATSAPP_PHONE_NUMBER_ID") or os.getenv("PHONE_NUMBER_ID")
services\wa_send.py:99:    return f"https://graph.facebook.com/{GRAPH_VERSION}/{path}"
services\wa_send.py:102:    return {"Authorization": f"Bearer {WHATSAPP_TOKEN}", "Content-Type": "application/json"}
services\wa_send.py:105:    return bool(WHATSAPP_TOKEN and PHONE_NUMBER_ID)
services\wa_send.py:110:def send_text(to: str, body: str):
services\wa_send.py:112:    Envia texto via WhatsApp Cloud API.
services\wa_send.py:116:        logging.error("[WA][SEND_TEXT] Missing WHATSAPP_TOKEN or PHONE_NUMBER_ID")
services\wa_send.py:117:        return False, {"error": "missing_whatsapp_config"}
services\wa_send.py:132:    url = _graph_url(f"{PHONE_NUMBER_ID}/messages")
services\wa_send.py:136:    logging.info("[WA][SEND_TEXT] to=%s eq_key=%s cands=%s", to, eq_key, cands)
services\wa_send.py:140:            "messaging_product": "whatsapp",
services\wa_send.py:156:            logging.exception("[WA][SEND_TEXT][ERROR] cand=%s err=%s", cand, e)
services\wa_send.py:172:        logging.error("[WA][SEND_AUDIO] Missing WHATSAPP_TOKEN or PHONE_NUMBER_ID")
services\wa_send.py:173:        return False, {"error": "missing_whatsapp_config"}
services\wa_send.py:177:        url_upload = _graph_url(f"{PHONE_NUMBER_ID}/media")
services\wa_send.py:178:        headers_up = {"Authorization": f"Bearer {WHATSAPP_TOKEN}"}
services\wa_send.py:180:        data = {"messaging_product": "whatsapp"}
services\wa_send.py:206:    url_msg = _graph_url(f"{PHONE_NUMBER_ID}/messages")
services\wa_send.py:214:            "messaging_product": "whatsapp",
services\wa_send.py:244:        logging.error("[WA][AUDIO_LINK] Missing WHATSAPP_TOKEN or PHONE_NUMBER_ID")
services\wa_send.py:245:        return False, {"error": "missing_whatsapp_config"}
services\wa_send.py:258:    url_msg = _graph_url(f"{PHONE_NUMBER_ID}/messages")
services\wa_send.py:266:            "messaging_product": "whatsapp",
services\wa_send.py:295:    if not WHATSAPP_TOKEN:
services\wa_send.py:296:        logging.error("[WA][FETCH_MEDIA] Missing WHATSAPP_TOKEN")
services\wa_send.py:302:            headers={"Authorization": f"Bearer {WHATSAPP_TOKEN}"},
services\wa_send.py:311:        r = requests.get(media_url, headers={"Authorization": f"Bearer {WHATSAPP_TOKEN}"}, timeout=30)
